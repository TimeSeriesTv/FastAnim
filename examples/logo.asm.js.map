{"version":3,"file":"examples/logo.asm.js","sources":["/Users/m8/IdeaProjects/StaticEdit/FastAnim/examples/logo.cpp","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/memory","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/detail/type_vec3.inl","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/detail/type_vec4.inl","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/vector","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/FastSet.h","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/functional","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/new","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/type_traits","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/view/../node/Node.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/detail/type_mat4x4.hpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/detail/type_mat4x4.inl","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/iterator","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/gtc/../detail/setup.hpp","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/tuple","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/value/Static.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/view/../value/Value.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/transformation/ScaleTransformation.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/transformation/Transformation.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/gtc/matrix_transform.inl","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/node/SpriteNode.h","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__split_buffer","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/algorithm","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/limits","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/utility","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/transition/LinearTransition.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/transition/Transition.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/view/../Animated.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/transformation/TranslateTransformation.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/camera/LookAtCamera.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/view/../camera/Camera.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/detail/func_common.inl","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/cmath","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/detail/func_geometric.inl","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/glm/glm/detail/func_exponential.inl","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/composition/LayerComposition.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/composition/Composition.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/view/View.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/include/../src/Animator.h","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__functional_base","/usr/local/include/boost/iterator/iterator_facade.hpp","/usr/local/include/boost/iterator/filter_iterator.hpp","/usr/local/include/boost/iterator/iterator_adaptor.hpp","/usr/local/include/boost/type_traits/integral_constant.hpp","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/typeinfo","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/Engine.cpp","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/map","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__tree","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/string","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/Sprite.h","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/libcxx/exception","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/SpriteLayer.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/fastgfx.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/deps/glm/glm/detail/type_vec2.inl","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/Layer.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/LineLayer.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/deps/glm/glm/gtc/type_ptr.inl","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/PolygonLayer.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/shaders.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/Sprite.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/SpriteFont.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/SpriteFont.h","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/SpriteLayer.cpp","/Users/m8/IdeaProjects/StaticEdit/FastAnim/deps/FastGFX/src/SpriteBuffer.cpp","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/lib/embind/bind.cpp","/Users/m8/webAssembly/emsdk_portable/emscripten/1.35.0/system/include/emscripten/wire.h"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AA;AACA;AAAA;AAAA;AACA;;;;;;;;Aax4GA;AAAA;AAAA;AAAA;;;;;;;;ANw3BA;AAAA;;;;;;;;AMx3BA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AensBA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;A5Bk0IA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AACA;;;;;;;;;AazjIA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;;AgB1RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;A7BwiIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AACA;;;;;;;;;;A4B7hIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AChBA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AX0MA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAgQA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARyOA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AQ3eA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAVA;AAAA;;;;;;;;;AYhDA;AAAA;AAAA;;;;;AR8QA;AAAA;;;;;;;;ASqjBA;AAAA;AAAA;;;;;;;;;;;;;;;;AtBn7BA;;;AAAA;AAAA;AAAA;;;;;;;AC8DA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AR+FA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AADA;AAAA;;;;;;;;;A4BrLA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ARoQA;;;;;;;;;;;;;;;;;ApB5OA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAJA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAJA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAJA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAA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AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;ApCuxHA;AAAA;;;;;;;;;;;;;;;AC/vHA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AoCnEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAFA;;;;;AAGA;AAAA;AADA;AAAA;AAAA;;;;;AACA;;;;;;;;;;;;;;;AjCmCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AmC20BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AArPA;AAAA;AAAA;;;;;;;;;AvCgsGA;AAAA;;;;;;;;;AuCtrGA;AAAA;AACA;AAAA;;;;;;;;;;;;;AC3hBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ArCi0CA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AqCh5CA;AAAA;AAAA;AASA;AACA;;;;;;;;;;;ACgMA;AAAA;AAEA;;;;;;;;;;;;;ADvKA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;;;AACA;;;;AAAA;AAAA;AAFA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;A7B8tCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;A8BljCA;;;;;;;;;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AAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAGA;AAAA;;;;;ACxCA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;A0C1IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;A1CuYA;AAAA;;;;;AA5OA;;;;;AA6OA;AAAA;;;;;AA5OA;;;;;A0C3IA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA;;;;;ACLA;AAAA;;;;;AAjBA;;;;;ADsBA","sourcesContent":["//\n// Created by Michał Łaszczewski on 09/07/16.\n//\n#include <fastgfx.h>\n#include <fastanim.h>\n#include <glm/glm.hpp>\n#include <cmath>\n#include <cstdlib>\n\n#define PI 3.141592\n\ndouble lastMoveTime = 0;\n\nint main() {\n  int res;\n  res = fgfx::init();\n  if(res!=0) {\n    fgfx_log(\"FGFX Initialization failed\\n\");\n    return res;\n  }\n\n  auto logoSprite = fgfx::engine->getSprite(\"../deps/FastGFX/assets/logo.png\");\n  auto spriteLayer = fgfx::engine->createSpriteLayer();\n\n  auto scene = std::make_shared<fanim::Node>();\n  scene->transformation = std::make_shared<fanim::ScaleTransformation>(\n      std::make_shared<fanim::Static<glm::vec3>>(glm::vec3(6,6,6))\n  );\n  auto logo = std::make_shared<fanim::SpriteNode>(spriteLayer,logoSprite,\n                                                  std::make_shared<fanim::Static<glm::vec4>>(glm::vec4(1,1,1,1)));\n  scene->children.push_back(logo);\n\n  auto logoPosition = std::make_shared<fanim::LinearTransition<glm::vec3>>(\n      std::make_shared<fanim::Static<glm::vec3>>(glm::vec3(0,0,0))\n  );\n  logo->transformation = std::make_shared<fanim::TranslateTransformation>(logoPosition);\n\n  auto camera = std::make_shared<fanim::LookAtCamera>(\n      std::make_shared<fanim::Static<glm::vec3>>(glm::vec3(0,0,20)),\n      std::make_shared<fanim::Static<glm::vec3>>(glm::vec3(0,0,0)),\n      std::make_shared<fanim::Static<glm::vec3>>(glm::vec3(0,-1,0)),\n      std::make_shared<fanim::Static<float>>(35.0),\n      0.1,\n      1000\n  );\n\n  auto composition = std::make_shared<fanim::LayerComposition>(spriteLayer);\n\n  auto view = std::make_shared<fanim::View>(scene,composition,camera);\n  view->animator.add(logoPosition);\n\n  fgfx::engine->setRenderFunction([=](double time, float delta) {\n    view->advance(delta/1000);\n    view->upload();\n    view->render();\n\n    if(time>lastMoveTime+1000) {\n      lastMoveTime = time;\n      logoPosition->setNext(\n          std::make_shared<fanim::Static<glm::vec3>>(glm::vec3(0.1*(rand()%100),0.1*(rand()%100),0)), 1.0);\n    }\n  });\n}\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/type_tvec3.inl\n/// @date 2008-08-22 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\nnamespace glm\n{\n\t// -- Implicit basic constructors --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3()\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT \n\t\t\t\t: x(0), y(0), z(0)\n#\t\t\tendif\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec3<T, P> const & v)\n\t\t\t: x(v.x), y(v.y), z(v.z)\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <precision Q>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec3<T, Q> const & v)\n\t\t: x(v.x), y(v.y), z(v.z)\n\t{}\n\n\t// -- Explicit basic constructors --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(ctor)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(T const & scalar)\n\t\t: x(scalar), y(scalar), z(scalar)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(T const & a, T const & b, T const & c)\n\t\t: x(a), y(b), z(c)\n\t{}\n\n\t// -- Conversion scalar constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(A const & a, B const & b, C const & c) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b)),\n\t\tz(static_cast<T>(c))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b)),\n\t\tz(static_cast<T>(c))\n\t{}\n\n\t// -- Conversion vector constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(A const & a, tvec2<B, Q> const & b) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :\n\t\tx(static_cast<T>(v.x)),\n\t\ty(static_cast<T>(v.y)),\n\t\tz(static_cast<T>(v.z))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :\n\t\tx(static_cast<T>(v.x)),\n\t\ty(static_cast<T>(v.y)),\n\t\tz(static_cast<T>(v.z))\n\t{}\n\n\t// -- Component accesses --\n\n#\tifdef GLM_FORCE_SIZE_FUNC\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec3<T, P>::size_type tvec3<T, P>::size() const\n\t\t{\n\t\t\treturn 3;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T & tvec3<T, P>::operator[](typename tvec3<T, P>::size_type i)\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T const & tvec3<T, P>::operator[](typename tvec3<T, P>::size_type i) const\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n#\telse\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec3<T, P>::length_type tvec3<T, P>::length() const\n\t\t{\n\t\t\treturn 3;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n#\tendif//GLM_FORCE_SIZE_FUNC\n\n\t// -- Unary arithmetic operators --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> const & v)\n\t\t{\n\t\t\tthis->x = v.x;\n\t\t\tthis->y = v.y;\n\t\t\tthis->z = v.z;\n\t\t\treturn *this;\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x = static_cast<T>(v.x);\n\t\tthis->y = static_cast<T>(v.y);\n\t\tthis->z = static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)\n\t{\n\t\tthis->x += static_cast<T>(scalar);\n\t\tthis->y += static_cast<T>(scalar);\n\t\tthis->z += static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x += static_cast<T>(v.x);\n\t\tthis->y += static_cast<T>(v.x);\n\t\tthis->z += static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x += static_cast<T>(v.x);\n\t\tthis->y += static_cast<T>(v.y);\n\t\tthis->z += static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)\n\t{\n\t\tthis->x -= static_cast<T>(scalar);\n\t\tthis->y -= static_cast<T>(scalar);\n\t\tthis->z -= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x -= static_cast<T>(v.x);\n\t\tthis->y -= static_cast<T>(v.x);\n\t\tthis->z -= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x -= static_cast<T>(v.x);\n\t\tthis->y -= static_cast<T>(v.y);\n\t\tthis->z -= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)\n\t{\n\t\tthis->x *= static_cast<T>(scalar);\n\t\tthis->y *= static_cast<T>(scalar);\n\t\tthis->z *= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.x);\n\t\tthis->z *= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.y);\n\t\tthis->z *= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(U v)\n\t{\n\t\tthis->x /= static_cast<T>(v);\n\t\tthis->y /= static_cast<T>(v);\n\t\tthis->z /= static_cast<T>(v);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.x);\n\t\tthis->z /= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.y);\n\t\tthis->z /= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\t// -- Increment and decrement operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator++()\n\t{\n\t\t++this->x;\n\t\t++this->y;\n\t\t++this->z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator--()\n\t{\n\t\t--this->x;\n\t\t--this->y;\n\t\t--this->z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator++(int)\n\t{\n\t\ttvec3<T, P> Result(*this);\n\t\t++*this;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator--(int)\n\t{\n\t\ttvec3<T, P> Result(*this);\n\t\t--*this;\n\t\treturn Result;\n\t}\n\n\t// -- Unary bit operators --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)\n\t{\n\t\tthis->x %= scalar;\n\t\tthis->y %= scalar;\n\t\tthis->z %= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x %= v.x;\n\t\tthis->y %= v.x;\n\t\tthis->z %= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x %= v.x;\n\t\tthis->y %= v.y;\n\t\tthis->z %= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)\n\t{\n\t\tthis->x &= scalar;\n\t\tthis->y &= scalar;\n\t\tthis->z &= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x &= v.x;\n\t\tthis->y &= v.x;\n\t\tthis->z &= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x &= v.x;\n\t\tthis->y &= v.y;\n\t\tthis->z &= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)\n\t{\n\t\tthis->x |= scalar;\n\t\tthis->y |= scalar;\n\t\tthis->z |= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x |= v.x;\n\t\tthis->y |= v.x;\n\t\tthis->z |= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x |= v.x;\n\t\tthis->y |= v.y;\n\t\tthis->z |= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)\n\t{\n\t\tthis->x ^= scalar;\n\t\tthis->y ^= scalar;\n\t\tthis->z ^= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x ^= v.x;\n\t\tthis->y ^= v.x;\n\t\tthis->z ^= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x ^= v.x;\n\t\tthis->y ^= v.y;\n\t\tthis->z ^= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)\n\t{\n\t\tthis->x <<= scalar;\n\t\tthis->y <<= scalar;\n\t\tthis->z <<= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.x);\n\t\tthis->z <<= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.y);\n\t\tthis->z <<= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)\n\t{\n\t\tthis->x >>= static_cast<T>(scalar);\n\t\tthis->y >>= static_cast<T>(scalar);\n\t\tthis->z >>= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.x);\n\t\tthis->z >>= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.y);\n\t\tthis->z >>= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\t// -- Unary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v)\n\t{\n\t\treturn v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\t-v.x, \n\t\t\t-v.y, \n\t\t\t-v.z);\n\t}\n\n\t// -- Binary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x + scalar,\n\t\t\tv.y + scalar,\n\t\t\tv.z + scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x + scalar.x,\n\t\t\tv.y + scalar.x,\n\t\t\tv.z + scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar + v.x,\n\t\t\tscalar + v.y,\n\t\t\tscalar + v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x + v.x,\n\t\t\tscalar.x + v.y,\n\t\t\tscalar.x + v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.y + v2.y,\n\t\t\tv1.z + v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x - scalar,\n\t\t\tv.y - scalar,\n\t\t\tv.z - scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x - scalar.x,\n\t\t\tv.y - scalar.x,\n\t\t\tv.z - scalar.x);\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar - v.x,\n\t\t\tscalar - v.y,\n\t\t\tscalar - v.z);\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x - v.x,\n\t\t\tscalar.x - v.y,\n\t\t\tscalar.x - v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.y - v2.y,\n\t\t\tv1.z - v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x * scalar,\n\t\t\tv.y * scalar,\n\t\t\tv.z * scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x * scalar.x,\n\t\t\tv.y * scalar.x,\n\t\t\tv.z * scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar * v.x,\n\t\t\tscalar * v.y,\n\t\t\tscalar * v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x * v.x,\n\t\t\tscalar.x * v.y,\n\t\t\tscalar.x * v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.y * v2.y,\n\t\t\tv1.z * v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x / scalar,\n\t\t\tv.y / scalar,\n\t\t\tv.z / scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x / scalar.x,\n\t\t\tv.y / scalar.x,\n\t\t\tv.z / scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar / v.x,\n\t\t\tscalar / v.y,\n\t\t\tscalar / v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x / v.x,\n\t\t\tscalar.x / v.y,\n\t\t\tscalar.x / v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.y / v2.y,\n\t\t\tv1.z / v2.z);\n\t}\n\n\t// -- Binary bit operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x % scalar,\n\t\t\tv.y % scalar,\n\t\t\tv.z % scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x % scalar.x,\n\t\t\tv.y % scalar.x,\n\t\t\tv.z % scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar % v.x,\n\t\t\tscalar % v.y,\n\t\t\tscalar % v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x % v.x,\n\t\t\tscalar.x % v.y,\n\t\t\tscalar.x % v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x % v2.x,\n\t\t\tv1.y % v2.y,\n\t\t\tv1.z % v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x & scalar,\n\t\t\tv.y & scalar,\n\t\t\tv.z & scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x & scalar.x,\n\t\t\tv.y & scalar.x,\n\t\t\tv.z & scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar & v.x,\n\t\t\tscalar & v.y,\n\t\t\tscalar & v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x & v.x,\n\t\t\tscalar.x & v.y,\n\t\t\tscalar.x & v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x & v2.x,\n\t\t\tv1.y & v2.y,\n\t\t\tv1.z & v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x | scalar,\n\t\t\tv.y | scalar,\n\t\t\tv.z | scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x | scalar.x,\n\t\t\tv.y | scalar.x,\n\t\t\tv.z | scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar | v.x,\n\t\t\tscalar | v.y,\n\t\t\tscalar | v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x | v.x,\n\t\t\tscalar.x | v.y,\n\t\t\tscalar.x | v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x | v2.x,\n\t\t\tv1.y | v2.y,\n\t\t\tv1.z | v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x ^ scalar,\n\t\t\tv.y ^ scalar,\n\t\t\tv.z ^ scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x ^ scalar.x,\n\t\t\tv.y ^ scalar.x,\n\t\t\tv.z ^ scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar ^ v.x,\n\t\t\tscalar ^ v.y,\n\t\t\tscalar ^ v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x ^ v.x,\n\t\t\tscalar.x ^ v.y,\n\t\t\tscalar.x ^ v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x ^ v2.x,\n\t\t\tv1.y ^ v2.y,\n\t\t\tv1.z ^ v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x << scalar,\n\t\t\tv.y << scalar,\n\t\t\tv.z << scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x << scalar.x,\n\t\t\tv.y << scalar.x,\n\t\t\tv.z << scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar << v.x,\n\t\t\tscalar << v.y,\n\t\t\tscalar << v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x << v.x,\n\t\t\tscalar.x << v.y,\n\t\t\tscalar.x << v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x << v2.x,\n\t\t\tv1.y << v2.y,\n\t\t\tv1.z << v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x >> scalar,\n\t\t\tv.y >> scalar,\n\t\t\tv.z >> scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x >> scalar.x,\n\t\t\tv.y >> scalar.x,\n\t\t\tv.z >> scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(T const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar >> v.x,\n\t\t\tscalar >> v.y,\n\t\t\tscalar >> v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x >> v.x,\n\t\t\tscalar.x >> v.y,\n\t\t\tscalar.x >> v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x >> v2.x,\n\t\t\tv1.y >> v2.y,\n\t\t\tv1.z >> v2.z);\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator~(tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\t~v.x,\n\t\t\t~v.y,\n\t\t\t~v.z);\n\t}\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);\n\t}\n}//namespace glm\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/type_tvec4.inl\n/// @date 2008-08-23 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\nnamespace glm\n{\n\t// -- Implicit basic constructors --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4()\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT\n\t\t\t\t: x(0), y(0), z(0), w(0)\n#\t\t\tendif\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec4<T, P> const & v)\n\t\t\t: x(v.x), y(v.y), z(v.z), w(v.w)\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec4<T, Q> const & v)\n\t\t: x(v.x), y(v.y), z(v.z), w(v.w)\n\t{}\n\n\t// -- Explicit basic constructors --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(ctor)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(T scalar)\n\t\t: x(scalar), y(scalar), z(scalar), w(scalar)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(T a, T b, T c, T d)\n\t\t: x(a), y(b), z(c), w(d)\n\t{}\n\n\t// -- Conversion scalar constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, typename D>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(A a, B b, C c, D d) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b)),\n\t\tz(static_cast<T>(c)),\n\t\tw(static_cast<T>(d))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, typename D>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(c.x)),\n\t\tw(static_cast<T>(d.x))\n\t{}\n\n\t// -- Conversion vector constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b)),\n\t\tw(static_cast<T>(c))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b.x)),\n\t\tw(static_cast<T>(c.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :\n\t\tx(static_cast<T>(s1)),\n\t\ty(static_cast<T>(v.x)),\n\t\tz(static_cast<T>(v.y)),\n\t\tw(static_cast<T>(s2))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y)),\n\t\tw(static_cast<T>(c.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :\n\t\tx(static_cast<T>(s1)),\n\t\ty(static_cast<T>(s2)),\n\t\tz(static_cast<T>(v.x)),\n\t\tw(static_cast<T>(v.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(c.x)),\n\t\tw(static_cast<T>(c.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(a.z)),\n\t\tw(static_cast<T>(b))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(a.z)),\n\t\tw(static_cast<T>(b.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y)),\n\t\tw(static_cast<T>(b.z))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y)),\n\t\tw(static_cast<T>(b.z))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b.x)),\n\t\tw(static_cast<T>(b.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :\n\t\tx(static_cast<T>(v.x)),\n\t\ty(static_cast<T>(v.y)),\n\t\tz(static_cast<T>(v.z)),\n\t\tw(static_cast<T>(v.w))\n\t{}\n\n\t// -- Component accesses --\n\n#\tifdef GLM_FORCE_SIZE_FUNC\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec4<T, P>::size_type tvec4<T, P>::size() const\n\t\t{\n\t\t\treturn 4;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T & tvec4<T, P>::operator[](typename tvec4<T, P>::size_type i)\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T const & tvec4<T, P>::operator[](typename tvec4<T, P>::size_type i) const\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n#\telse\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec4<T, P>::length_type tvec4<T, P>::length() const\n\t\t{\n\t\t\treturn 4;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n#\tendif//GLM_FORCE_SIZE_FUNC\n\n\t// -- Unary arithmetic operators --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator=(tvec4<T, P> const & v)\n\t\t{\n\t\t\tthis->x = v.x;\n\t\t\tthis->y = v.y;\n\t\t\tthis->z = v.z;\n\t\t\tthis->w = v.w;\n\t\t\treturn *this;\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x = static_cast<T>(v.x);\n\t\tthis->y = static_cast<T>(v.y);\n\t\tthis->z = static_cast<T>(v.z);\n\t\tthis->w = static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)\n\t{\n\t\tthis->x += static_cast<T>(scalar);\n\t\tthis->y += static_cast<T>(scalar);\n\t\tthis->z += static_cast<T>(scalar);\n\t\tthis->w += static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)\n\t{\n\t\tT const scalar = static_cast<T>(v.x);\n\t\tthis->x += scalar;\n\t\tthis->y += scalar;\n\t\tthis->z += scalar;\n\t\tthis->w += scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x += static_cast<T>(v.x);\n\t\tthis->y += static_cast<T>(v.y);\n\t\tthis->z += static_cast<T>(v.z);\n\t\tthis->w += static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)\n\t{\n\t\tthis->x -= static_cast<T>(scalar);\n\t\tthis->y -= static_cast<T>(scalar);\n\t\tthis->z -= static_cast<T>(scalar);\n\t\tthis->w -= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)\n\t{\n\t\tT const scalar = static_cast<T>(v.x);\n\t\tthis->x -= scalar;\n\t\tthis->y -= scalar;\n\t\tthis->z -= scalar;\n\t\tthis->w -= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x -= static_cast<T>(v.x);\n\t\tthis->y -= static_cast<T>(v.y);\n\t\tthis->z -= static_cast<T>(v.z);\n\t\tthis->w -= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(U v)\n\t{\n\t\tthis->x *= static_cast<T>(v);\n\t\tthis->y *= static_cast<T>(v);\n\t\tthis->z *= static_cast<T>(v);\n\t\tthis->w *= static_cast<T>(v);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.x);\n\t\tthis->z *= static_cast<T>(v.x);\n\t\tthis->w *= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.y);\n\t\tthis->z *= static_cast<T>(v.z);\n\t\tthis->w *= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(U v)\n\t{\n\t\tthis->x /= static_cast<T>(v);\n\t\tthis->y /= static_cast<T>(v);\n\t\tthis->z /= static_cast<T>(v);\n\t\tthis->w /= static_cast<T>(v);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.x);\n\t\tthis->z /= static_cast<T>(v.x);\n\t\tthis->w /= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.y);\n\t\tthis->z /= static_cast<T>(v.z);\n\t\tthis->w /= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\t// -- Increment and decrement operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator++()\n\t{\n\t\t++this->x;\n\t\t++this->y;\n\t\t++this->z;\n\t\t++this->w;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator--()\n\t{\n\t\t--this->x;\n\t\t--this->y;\n\t\t--this->z;\n\t\t--this->w;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> tvec4<T, P>::operator++(int)\n\t{\n\t\ttvec4<T, P> Result(*this);\n\t\t++*this;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> tvec4<T, P>::operator--(int)\n\t{\n\t\ttvec4<T, P> Result(*this);\n\t\t--*this;\n\t\treturn Result;\n\t}\n\n\t// -- Unary bit operators --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)\n\t{\n\t\tthis->x %= static_cast<T>(scalar);\n\t\tthis->y %= static_cast<T>(scalar);\n\t\tthis->z %= static_cast<T>(scalar);\n\t\tthis->w %= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x %= static_cast<T>(v.x);\n\t\tthis->y %= static_cast<T>(v.x);\n\t\tthis->z %= static_cast<T>(v.x);\n\t\tthis->w %= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x %= static_cast<T>(v.x);\n\t\tthis->y %= static_cast<T>(v.y);\n\t\tthis->z %= static_cast<T>(v.z);\n\t\tthis->w %= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)\n\t{\n\t\tthis->x &= static_cast<T>(scalar);\n\t\tthis->y &= static_cast<T>(scalar);\n\t\tthis->z &= static_cast<T>(scalar);\n\t\tthis->w &= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x &= static_cast<T>(v.x);\n\t\tthis->y &= static_cast<T>(v.x);\n\t\tthis->z &= static_cast<T>(v.x);\n\t\tthis->w &= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x &= static_cast<T>(v.x);\n\t\tthis->y &= static_cast<T>(v.y);\n\t\tthis->z &= static_cast<T>(v.z);\n\t\tthis->w &= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)\n\t{\n\t\tthis->x |= static_cast<T>(scalar);\n\t\tthis->y |= static_cast<T>(scalar);\n\t\tthis->z |= static_cast<T>(scalar);\n\t\tthis->w |= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x |= static_cast<T>(v.x);\n\t\tthis->y |= static_cast<T>(v.x);\n\t\tthis->z |= static_cast<T>(v.x);\n\t\tthis->w |= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x |= static_cast<T>(v.x);\n\t\tthis->y |= static_cast<T>(v.y);\n\t\tthis->z |= static_cast<T>(v.z);\n\t\tthis->w |= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)\n\t{\n\t\tthis->x ^= static_cast<T>(scalar);\n\t\tthis->y ^= static_cast<T>(scalar);\n\t\tthis->z ^= static_cast<T>(scalar);\n\t\tthis->w ^= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x ^= static_cast<T>(v.x);\n\t\tthis->y ^= static_cast<T>(v.x);\n\t\tthis->z ^= static_cast<T>(v.x);\n\t\tthis->w ^= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x ^= static_cast<T>(v.x);\n\t\tthis->y ^= static_cast<T>(v.y);\n\t\tthis->z ^= static_cast<T>(v.z);\n\t\tthis->w ^= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)\n\t{\n\t\tthis->x <<= static_cast<T>(scalar);\n\t\tthis->y <<= static_cast<T>(scalar);\n\t\tthis->z <<= static_cast<T>(scalar);\n\t\tthis->w <<= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.x);\n\t\tthis->z <<= static_cast<T>(v.x);\n\t\tthis->w <<= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.y);\n\t\tthis->z <<= static_cast<T>(v.z);\n\t\tthis->w <<= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)\n\t{\n\t\tthis->x >>= static_cast<T>(scalar);\n\t\tthis->y >>= static_cast<T>(scalar);\n\t\tthis->z >>= static_cast<T>(scalar);\n\t\tthis->w >>= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.y);\n\t\tthis->z >>= static_cast<T>(v.z);\n\t\tthis->w >>= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.y);\n\t\tthis->z >>= static_cast<T>(v.z);\n\t\tthis->w >>= static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\t// -- Unary constant operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v)\n\t{\n\t\treturn v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\t-v.x, \n\t\t\t-v.y, \n\t\t\t-v.z, \n\t\t\t-v.w);\n\t}\n\n\t// -- Binary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x + scalar,\n\t\t\tv.y + scalar,\n\t\t\tv.z + scalar,\n\t\t\tv.w + scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.y + v2.x,\n\t\t\tv1.z + v2.x,\n\t\t\tv1.w + v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar + v.x,\n\t\t\tscalar + v.y,\n\t\t\tscalar + v.z,\n\t\t\tscalar + v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.x + v2.y,\n\t\t\tv1.x + v2.z,\n\t\t\tv1.x + v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.y + v2.y,\n\t\t\tv1.z + v2.z,\n\t\t\tv1.w + v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x - scalar,\n\t\t\tv.y - scalar,\n\t\t\tv.z - scalar,\n\t\t\tv.w - scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.y - v2.x,\n\t\t\tv1.z - v2.x,\n\t\t\tv1.w - v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar - v.x,\n\t\t\tscalar - v.y,\n\t\t\tscalar - v.z,\n\t\t\tscalar - v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.x - v2.y,\n\t\t\tv1.x - v2.z,\n\t\t\tv1.x - v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.y - v2.y,\n\t\t\tv1.z - v2.z,\n\t\t\tv1.w - v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x * scalar,\n\t\t\tv.y * scalar,\n\t\t\tv.z * scalar,\n\t\t\tv.w * scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.y * v2.x,\n\t\t\tv1.z * v2.x,\n\t\t\tv1.w * v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar * v.x,\n\t\t\tscalar * v.y,\n\t\t\tscalar * v.z,\n\t\t\tscalar * v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.x * v2.y,\n\t\t\tv1.x * v2.z,\n\t\t\tv1.x * v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.y * v2.y,\n\t\t\tv1.z * v2.z,\n\t\t\tv1.w * v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x / scalar,\n\t\t\tv.y / scalar,\n\t\t\tv.z / scalar,\n\t\t\tv.w / scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.y / v2.x,\n\t\t\tv1.z / v2.x,\n\t\t\tv1.w / v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar / v.x,\n\t\t\tscalar / v.y,\n\t\t\tscalar / v.z,\n\t\t\tscalar / v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.x / v2.y,\n\t\t\tv1.x / v2.z,\n\t\t\tv1.x / v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.y / v2.y,\n\t\t\tv1.z / v2.z,\n\t\t\tv1.w / v2.w);\n\t}\n\n\t// -- Binary bit operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x % scalar,\n\t\t\tv.y % scalar,\n\t\t\tv.z % scalar,\n\t\t\tv.w % scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x % scalar.x,\n\t\t\tv.y % scalar.x,\n\t\t\tv.z % scalar.x,\n\t\t\tv.w % scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar % v.x,\n\t\t\tscalar % v.y,\n\t\t\tscalar % v.z,\n\t\t\tscalar % v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar.x % v.x,\n\t\t\tscalar.x % v.y,\n\t\t\tscalar.x % v.z,\n\t\t\tscalar.x % v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x % v2.x,\n\t\t\tv1.y % v2.y,\n\t\t\tv1.z % v2.z,\n\t\t\tv1.w % v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x & scalar,\n\t\t\tv.y & scalar,\n\t\t\tv.z & scalar,\n\t\t\tv.w & scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x & scalar.x,\n\t\t\tv.y & scalar.x,\n\t\t\tv.z & scalar.x,\n\t\t\tv.w & scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar & v.x,\n\t\t\tscalar & v.y,\n\t\t\tscalar & v.z,\n\t\t\tscalar & v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar.x & v.x,\n\t\t\tscalar.x & v.y,\n\t\t\tscalar.x & v.z,\n\t\t\tscalar.x & v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x & v2.x,\n\t\t\tv1.y & v2.y,\n\t\t\tv1.z & v2.z,\n\t\t\tv1.w & v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x | scalar,\n\t\t\tv.y | scalar,\n\t\t\tv.z | scalar,\n\t\t\tv.w | scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x | scalar.x,\n\t\t\tv.y | scalar.x,\n\t\t\tv.z | scalar.x,\n\t\t\tv.w | scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar | v.x,\n\t\t\tscalar | v.y,\n\t\t\tscalar | v.z,\n\t\t\tscalar | v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar.x | v.x,\n\t\t\tscalar.x | v.y,\n\t\t\tscalar.x | v.z,\n\t\t\tscalar.x | v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x | v2.x,\n\t\t\tv1.y | v2.y,\n\t\t\tv1.z | v2.z,\n\t\t\tv1.w | v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x ^ scalar,\n\t\t\tv.y ^ scalar,\n\t\t\tv.z ^ scalar,\n\t\t\tv.w ^ scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x ^ scalar.x,\n\t\t\tv.y ^ scalar.x,\n\t\t\tv.z ^ scalar.x,\n\t\t\tv.w ^ scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar ^ v.x,\n\t\t\tscalar ^ v.y,\n\t\t\tscalar ^ v.z,\n\t\t\tscalar ^ v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar.x ^ v.x,\n\t\t\tscalar.x ^ v.y,\n\t\t\tscalar.x ^ v.z,\n\t\t\tscalar.x ^ v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x ^ v2.x,\n\t\t\tv1.y ^ v2.y,\n\t\t\tv1.z ^ v2.z,\n\t\t\tv1.w ^ v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x << scalar,\n\t\t\tv.y << scalar,\n\t\t\tv.z << scalar,\n\t\t\tv.w << scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x << scalar.x,\n\t\t\tv.y << scalar.x,\n\t\t\tv.z << scalar.x,\n\t\t\tv.w << scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar << v.x,\n\t\t\tscalar << v.y,\n\t\t\tscalar << v.z,\n\t\t\tscalar << v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar.x << v.x,\n\t\t\tscalar.x << v.y,\n\t\t\tscalar.x << v.z,\n\t\t\tscalar.x << v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x << v2.x,\n\t\t\tv1.y << v2.y,\n\t\t\tv1.z << v2.z,\n\t\t\tv1.w << v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x >> scalar,\n\t\t\tv.y >> scalar,\n\t\t\tv.z >> scalar,\n\t\t\tv.w >> scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv.x >> scalar.x,\n\t\t\tv.y >> scalar.x,\n\t\t\tv.z >> scalar.x,\n\t\t\tv.w >> scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar >> v.x,\n\t\t\tscalar >> v.y,\n\t\t\tscalar >> v.z,\n\t\t\tscalar >> v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tscalar.x >> v.x,\n\t\t\tscalar.x >> v.y,\n\t\t\tscalar.x >> v.z,\n\t\t\tscalar.x >> v.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tv1.x >> v2.x,\n\t\t\tv1.y >> v2.y,\n\t\t\tv1.z >> v2.z,\n\t\t\tv1.w >> v2.w);\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator~(tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\t~v.x,\n\t\t\t~v.y,\n\t\t\t~v.z,\n\t\t\t~v.w);\n\t}\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);\n\t}\n}//namespace glm\n\n#if GLM_HAS_ANONYMOUS_UNION && GLM_NOT_BUGGY_VC32BITS\n#if GLM_ARCH & GLM_ARCH_SSE2\n#\tinclude \"type_vec4_sse2.inl\"\n#endif\n#if GLM_ARCH & GLM_ARCH_AVX\n#\tinclude \"type_vec4_avx.inl\"\n#endif\n#if GLM_ARCH & GLM_ARCH_AVX2\n#\tinclude \"type_vec4_avx2.inl\"\n#endif\n#endif//\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n    void __annotate_contiguous_container\n    (const void *__beg, const void *__end, const void *__old_mid, const void *__new_mid) const\n    {\n#ifndef _LIBCPP_HAS_NO_ASAN\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n#endif\n    }\n\n    void __annotate_new(size_type __current_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n    void __annotate_delete() const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __n(__n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__v.size() + __n);\n      }\n      bool __commit;\n      size_type __n;\n      const vector &__v;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}\n      inline void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        __annotator.__done();\n        ++this->__end_;\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typename iterator_traits<_ForwardIterator>::difference_type __new_size = _VSTD::distance(__first, __last);\n    if (static_cast<size_type>(__new_size) <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (static_cast<size_type>(__new_size) > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last);\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__new_size)));\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                _VSTD::advance(__m, this->__end_ - __p);\n                __construct_at_end(__m, __last);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __base::__swap_alloc(this->__alloc(), __x.__alloc());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__storage_type>\n#else\n                rebind_alloc<__storage_type>::other\n#endif\n                                                     __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a);\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __storage_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator&, __storage_allocator&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_alloc(this->__alloc(), __x.__alloc());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_RENDERLIST_H\n#define FASTANIM_RENDERLIST_H\n\n#include <vector>\n#include <memory>\n#include <functional>\n#include <boost/iterator/filter_iterator.hpp>\n\nnamespace fanim {\n\n  template<typename ElementType> class FastSet {\n  public:\n    std::vector<std::shared_ptr<ElementType>> buffer;\n\n    int search;\n\n    int add(std::shared_ptr<ElementType> element) {\n      int len = buffer.size();\n      if(len) {\n        for (int i = search + 1; i != search; i = (i + 1) % len) {\n          if (!buffer[i]) { // Found empty\n            buffer[i] = element;\n            search = i;\n            return i;\n          }\n        }\n      }\n      search = buffer.size();\n      buffer.resize(search+1024);\n      buffer[search]=element;\n      return search;\n    }\n    void remove(int id) {\n      buffer[id] = nullptr;\n    }\n    void remove(std::shared_ptr<ElementType> element) {\n      for(int i = 0; i < buffer.size(); i++) {\n        if(buffer[i] == element) {\n          buffer[i] = nullptr;\n          return;\n        }\n      }\n    }\n\n    struct is_element {\n      bool operator()(std::shared_ptr<ElementType> x) { return !!x; }\n    };\n\n    auto begin() {\n      return boost::make_filter_iterator<is_element>(buffer.begin(), buffer.end());\n    }\n    auto end() {\n      return boost::make_filter_iterator<is_element>(buffer.end(), buffer.end());\n    }\n\n  };\n\n}\n\n#endif //FASTANIM_RENDERLIST_H\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return -_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) : __f_(__f) {}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_return<type, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm)\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\ntemplate<class _Fp> class _LIBCPP_TYPE_VIS_ONLY function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    return __invoke(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TYPE_VIS_ONLY function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    template <class _Fp>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const _Fp&) {return true;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) {return __p;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const function<_R2(_Ap...)>& __p) {return !!__p;}\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value =\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp>\n      function(_Fp, typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                      >::type* = 0);\n\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f,\n               typename enable_if<__callable<_Fp>::value>::type* = 0);\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f,\n                                     typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                     >::type*)\n    : __f_(0)\n{\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,\n                                     typename enable_if<__callable<_Fp>::value>::type*)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<_FF>\n#else\n            rebind_alloc<_FF>::other\n#endif\n            _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = (__base*)&__tempbuf;\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = (__base*)&__buf_;\n        __t->__clone((__base*)&__f.__buf_);\n        __t->destroy();\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f_ == (__base*)&__buf_)\n    {\n        __f_->__clone((__base*)&__f.__buf_);\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = (__base*)&__buf_;\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__f_ == 0)\n        throw bad_function_call();\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n_LIBCPP_FUNC_VIS extern __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern __ph<10> _10;\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_bind_expression<_Ti>::value,\n    typename __invoke_of<_Ti&, _Uj...>::type\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = _is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(const __bind& __b)\n        : __f_(__b.__f_),\n          __bound_args_(__b.__bound_args_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(const __bind& __b)\n    {\n        __f_ = __b.__f_;\n        __bound_args_ = __b.__bound_args_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(__bind&& __b)\n        : __f_(_VSTD::move(__b.__f_)),\n          __bound_args_(_VSTD::move(__b.__bound_args_)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(__bind&& __b)\n    {\n        __f_ = _VSTD::move(__b.__f_);\n        __bound_args_ = _VSTD::move(__b.__bound_args_);\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(const __bind_r& __b)\n        : base(_VSTD::forward<const base&>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(const __bind_r& __b)\n    {\n        base::operator=(_VSTD::forward<const base&>(__b));\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(__bind_r&& __b)\n        : base(_VSTD::forward<base>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(__bind_r&& __b)\n    {\n        base::operator=(_VSTD::forward<base>(__b));\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__c = 0;\n        __u.__d = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b ^ __u.__c ^ __u.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash\n    : public unary_function<_Tp, size_t>\n{\n    static_assert(is_enum<_Tp>::value, \"This hash only works for enumeration types\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;\n    typedef integral_constant<bool, false> false_type;\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n}  // std\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\ntypedef integral_constant<bool, true>  true_type;\ntypedef integral_constant<bool, false> false_type;\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(long);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\nnamespace __libcpp_is_member_function_pointer_imp {\n    template <typename _Tp>\n    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);\n\n    template <typename>\n    std::__two __test(...);\n};\n    \ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(nullptr)) == 1> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename remove_reference<_Tp>::type* type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n// is_final\n\n#if _LIBCPP_STD_VER > 11 && __has_feature(is_final)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY \nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n// is_convertible\n\n#if __has_feature(is_convertible_to)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> char  __test(_Tp);\ntemplate <class _Tp> __two __test(...);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> _Tp&& __source();\n#else\ntemplate <class _Tp> typename remove_reference<_Tp>::type& __source();\n#endif\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n#else\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[_Len];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[_Len];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote\n{\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\n    typedef typename __promote<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n    static const bool __does_not_throw = _NOEXCEPT_OR_FALSE(static_cast<type>(declval<_A1>()));\n};\n\n#ifdef _LIBCPP_STORE_AS_OPTIMIZATION\n\n// __transform\n\ntemplate <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};\ntemplate <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};\ntemplate <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};\ntemplate <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};\ntemplate <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};\n\n#endif  // _LIBCPP_STORE_AS_OPTIMIZATION\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class V = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp&& __t();\n    static _Up&& __u();\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp __t();\n    static _Up __u();\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\npublic:\n    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class ..._Tp> struct common_type;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n{\nprivate:\n    static _Tp&& __t();\n    static _Up&& __u();\n    static bool __f();\npublic:\n    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n{\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n// is_destructible\n\n//\tif it's a reference, return true\n//\tif it's a function, return false\n//\tif it's   void,     return false\n//\tif it's an array of unknown bound, return false\n//\tOtherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n\ttemplate <typename _Tp1>\n\tstatic char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n\ttemplate <typename _Tp1>\n\tstatic __two __test (...);\n\t\n\tstatic const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<true, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<false, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\n#endif\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\ntemplate <class ..._Args>\nauto\n__invoke(__any, _Args&& ...__args)\n    -> __nat;\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f);\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));\n\n// __invokable\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable_imp\n    : private __check_complete<_Fp>\n{\n    typedef decltype(\n            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)\n                    ) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable\n    : public integral_constant<bool,\n          __invokable_imp<_Fp, _Args...>::value>\n{\n};\n\n// __invoke_of\n\ntemplate <bool _Invokable, class _Fp, class ..._Args>\nstruct __invoke_of_imp  // false\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of_imp<true, _Fp, _Args...>\n{\n    typedef typename __invokable_imp<_Fp, _Args...>::type type;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp>\nstruct __swappable\n{\n    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable<_Tp>::value>\n{\n};\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp>\nstruct __is_nothrow_swappable_imp\n    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),\n                                                   _VSTD::declval<_Tp&>()))>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable_imp<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public false_type\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_imp\n{\n    template <class>\n        static auto __test(__any) -> false_type;\n    template <class _Up>\n        static auto __test(_Up* __u)\n            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;\n\n    static const bool value = decltype(__test<_Tp>(nullptr))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","#ifndef FASTANIM_NODE_H\n#define FASTANIM_NODE_H\n\n#include <glm/glm.hpp>\n#include \"../transformation/Transformation.h\"\n#include \"../camera/Camera.h\"\n\nnamespace fanim {\n\n  class Node {\n  public:\n    std::shared_ptr<Transformation> transformation;\n    std::vector<std::shared_ptr<Node>> children;\n\n    int debugMode;\n    glm::vec4 debugColor;\n\n    glm::mat4 computedMatrix;\n\n    Node() {}\n    virtual ~Node() {}\n\n    virtual void render() {\n      for(auto it = children.begin(); it != children.end(); it++) {\n        (*it)->render();\n      }\n    }\n    virtual void remove() {\n      for(auto it = children.begin(); it != children.end(); it++) {\n        (*it)->remove();\n      }\n    }\n    void computeMatrix(const glm::mat4& parentMatrix, const Camera& camera) {\n      computedMatrix = transformation ? parentMatrix * transformation->getMatrix() : parentMatrix;\n      for(auto it = children.begin(); it != children.end(); it++) {\n        (*it)->computeMatrix(computedMatrix, camera);\n      }\n    }\n    virtual void renderDebug(int debugMode, fgfx::LineLayer *lines) {\n      int d = debugMode | this->debugMode;\n      if(d>=1) {\n        glm::vec3 ul(computedMatrix*glm::vec4(-1,1,0,1));\n        glm::vec3 ur(computedMatrix*glm::vec4(1,1,0,1));\n        glm::vec3 bl(computedMatrix*glm::vec4(-1,-1,0,1));\n        glm::vec3 br(computedMatrix*glm::vec4(1,-1,0,1));\n        lines->bufferLine(ul,ur,debugColor);\n        lines->bufferLine(ur,br,debugColor);\n        lines->bufferLine(br,bl,debugColor);\n        lines->bufferLine(bl,ul,debugColor);\n      }\n\n      for(auto it = children.begin(); it != children.end(); it++) {\n        (*it)->renderDebug(debugMode, lines);\n      }\n    }\n  };\n\n}\n\n#endif //FASTANIM_NODE_H\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n///\n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n///\n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n///\n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/type_mat4x4.hpp\n/// @date 2005-01-27 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#pragma once\n\n#include \"../fwd.hpp\"\n#include \"type_vec4.hpp\"\n#include \"type_mat.hpp\"\n#include <limits>\n#include <cstddef>\n\nnamespace glm\n{\n\ttemplate <typename T, precision P = defaultp>\n\tstruct tmat4x4\n\t{\n\t\ttypedef tvec4<T, P> col_type;\n\t\ttypedef tvec4<T, P> row_type;\n\t\ttypedef tmat4x4<T, P> type;\n\t\ttypedef tmat4x4<T, P> transpose_type;\n\t\ttypedef T value_type;\n\n#\t\tifdef GLM_META_PROG_HELPERS\n\t\t\tstatic GLM_RELAXED_CONSTEXPR length_t components = 4;\n\t\t\tstatic GLM_RELAXED_CONSTEXPR length_t cols = 4;\n\t\t\tstatic GLM_RELAXED_CONSTEXPR length_t rows = 4;\n\t\t\tstatic GLM_RELAXED_CONSTEXPR precision prec = P;\n#\t\tendif//GLM_META_PROG_HELPERS\n\n\t\ttemplate <typename U, precision Q>\n\t\tfriend tvec4<U, Q> operator/(tmat4x4<U, Q> const & m, tvec4<U, Q> const & v);\n\t\ttemplate <typename U, precision Q>\n\t\tfriend tvec4<U, Q> operator/(tvec4<U, Q> const & v, tmat4x4<U, Q> const & m);\n\n\tprivate:\n\t\tcol_type value[4];\n\n\tpublic:\n\t\t// -- Constructors --\n\n\t\tGLM_FUNC_DECL tmat4x4() GLM_DEFAULT_CTOR;\n\t\tGLM_FUNC_DECL tmat4x4(tmat4x4<T, P> const & m) GLM_DEFAULT;\n\t\ttemplate <precision Q>\n\t\tGLM_FUNC_DECL tmat4x4(tmat4x4<T, Q> const & m);\n\n\t\tGLM_FUNC_DECL explicit tmat4x4(ctor);\n\t\tGLM_FUNC_DECL explicit tmat4x4(T const & x);\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\tT const & x0, T const & y0, T const & z0, T const & w0,\n\t\t\tT const & x1, T const & y1, T const & z1, T const & w1,\n\t\t\tT const & x2, T const & y2, T const & z2, T const & w2,\n\t\t\tT const & x3, T const & y3, T const & z3, T const & w3);\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\tcol_type const & v0,\n\t\t\tcol_type const & v1,\n\t\t\tcol_type const & v2,\n\t\t\tcol_type const & v3);\n\n\t\t// -- Conversions --\n\n\t\ttemplate <\n\t\t\ttypename X1, typename Y1, typename Z1, typename W1,\n\t\t\ttypename X2, typename Y2, typename Z2, typename W2,\n\t\t\ttypename X3, typename Y3, typename Z3, typename W3,\n\t\t\ttypename X4, typename Y4, typename Z4, typename W4>\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\tX1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,\n\t\t\tX2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,\n\t\t\tX3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,\n\t\t\tX4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);\n\n\t\ttemplate <typename V1, typename V2, typename V3, typename V4>\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\ttvec4<V1, P> const & v1,\n\t\t\ttvec4<V2, P> const & v2,\n\t\t\ttvec4<V3, P> const & v3,\n\t\t\ttvec4<V4, P> const & v4);\n\n\t\t// -- Matrix conversions --\n\n\t\ttemplate <typename U, precision Q>\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat4x4<U, Q> const & m);\n\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat2x2<T, P> const & x);\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat3x3<T, P> const & x);\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat2x3<T, P> const & x);\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat3x2<T, P> const & x);\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat2x4<T, P> const & x);\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat4x2<T, P> const & x);\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat3x4<T, P> const & x);\n\t\tGLM_FUNC_DECL explicit tmat4x4(tmat4x3<T, P> const & x);\n\n\t\t// -- Accesses --\n\n#\t\tifdef GLM_FORCE_SIZE_FUNC\n\t\t\ttypedef size_t size_type;\n\t\t\tGLM_FUNC_DECL GLM_CONSTEXPR size_t size() const;\n\n\t\t\tGLM_FUNC_DECL col_type & operator[](size_type i);\n\t\t\tGLM_FUNC_DECL col_type const & operator[](size_type i) const;\n#\t\telse\n\t\t\ttypedef length_t length_type;\n\t\t\tGLM_FUNC_DECL GLM_CONSTEXPR length_type length() const;\n\n\t\t\tGLM_FUNC_DECL col_type & operator[](length_type i);\n\t\t\tGLM_FUNC_DECL col_type const & operator[](length_type i) const;\n#\t\tendif//GLM_FORCE_SIZE_FUNC\n\n\t\t// -- Unary arithmetic operators --\n\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator=(tmat4x4<T, P> const & m) GLM_DEFAULT;\n\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator+=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator-=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator*=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator/=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);\n\n\t\t// -- Increment and decrement operators --\n\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator++();\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator--();\n\t\tGLM_FUNC_DECL tmat4x4<T, P> operator++(int);\n\t\tGLM_FUNC_DECL tmat4x4<T, P> operator--(int);\n\t};\n\n\t// -- Unary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m);\n\n\t// -- Binary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1,\ttmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1,\ttmat4x4<T, P> const & m2);\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n}//namespace glm\n\n#ifndef GLM_EXTERNAL_TEMPLATE\n#include \"type_mat4x4.inl\"\n#endif//GLM_EXTERNAL_TEMPLATE\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/type_mat4x4.inl\n/// @date 2005-01-27 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\nnamespace glm{\nnamespace detail\n{\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> compute_inverse(tmat4x4<T, P> const & m)\n\t{\n\t\tT Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n\t\tT Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n\t\tT Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n\n\t\tT Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n\t\tT Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n\t\tT Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n\n\t\tT Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n\t\tT Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n\t\tT Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n\n\t\tT Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n\t\tT Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n\t\tT Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n\n\t\tT Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n\t\tT Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n\t\tT Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n\n\t\tT Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n\t\tT Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n\t\tT Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n\n\t\ttvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);\n\t\ttvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);\n\t\ttvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);\n\t\ttvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);\n\t\ttvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);\n\t\ttvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);\n\n\t\ttvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);\n\t\ttvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);\n\t\ttvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);\n\t\ttvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);\n\n\t\ttvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);\n\t\ttvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);\n\t\ttvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);\n\t\ttvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);\n\n\t\ttvec4<T, P> SignA(+1, -1, +1, -1);\n\t\ttvec4<T, P> SignB(-1, +1, -1, +1);\n\t\ttmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);\n\n\t\ttvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);\n\n\t\ttvec4<T, P> Dot0(m[0] * Row0);\n\t\tT Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);\n\n\t\tT OneOverDeterminant = static_cast<T>(1) / Dot1;\n\n\t\treturn Inverse * OneOverDeterminant;\n\t}\n}//namespace detail\n\n\t// -- Constructors --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4()\n\t\t{\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT \n\t\t\t\tthis->value[0] = col_type(1, 0, 0, 0);\n\t\t\t\tthis->value[1] = col_type(0, 1, 0, 0);\n\t\t\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\t\t\tthis->value[3] = col_type(0, 0, 0, 1);\n#\t\t\tendif\n\t\t}\n#\tendif\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x4<T, P> const & m)\n\t\t{\n\t\t\tthis->value[0] = m[0];\n\t\t\tthis->value[1] = m[1];\n\t\t\tthis->value[2] = m[2];\n\t\t\tthis->value[3] = m[3];\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <precision Q>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)\n\t{\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = m[2];\n\t\tthis->value[3] = m[3];\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(ctor)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(T const & s)\n\t{\n\t\tthis->value[0] = col_type(s, 0, 0, 0);\n\t\tthis->value[1] = col_type(0, s, 0, 0);\n\t\tthis->value[2] = col_type(0, 0, s, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\tT const & x0, T const & y0, T const & z0, T const & w0,\n\t\tT const & x1, T const & y1, T const & z1, T const & w1,\n\t\tT const & x2, T const & y2, T const & z2, T const & w2,\n\t\tT const & x3, T const & y3, T const & z3, T const & w3\n\t)\n\t{\n\t\tthis->value[0] = col_type(x0, y0, z0, w0);\n\t\tthis->value[1] = col_type(x1, y1, z1, w1);\n\t\tthis->value[2] = col_type(x2, y2, z2, w2);\n\t\tthis->value[3] = col_type(x3, y3, z3, w3);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\tcol_type const & v0,\n\t\tcol_type const & v1,\n\t\tcol_type const & v2,\n\t\tcol_type const & v3\n\t)\n\t{\n\t\tthis->value[0] = v0;\n\t\tthis->value[1] = v1;\n\t\tthis->value[2] = v2;\n\t\tthis->value[3] = v3;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\ttmat4x4<U, Q> const & m\n\t)\n\t{\n\t\tthis->value[0] = col_type(m[0]);\n\t\tthis->value[1] = col_type(m[1]);\n\t\tthis->value[2] = col_type(m[2]);\n\t\tthis->value[3] = col_type(m[3]);\n\t}\n\n\t// -- Conversions --\n\n\ttemplate <typename T, precision P> \n\ttemplate <\n\t\ttypename X1, typename Y1, typename Z1, typename W1,\n\t\ttypename X2, typename Y2, typename Z2, typename W2,\n\t\ttypename X3, typename Y3, typename Z3, typename W3,\n\t\ttypename X4, typename Y4, typename Z4, typename W4>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\tX1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,\n\t\tX2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,\n\t\tX3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,\n\t\tX4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4\n\t)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\n\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer, \"*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer, \"*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer, \"*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer, \"*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.\");\n\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer, \"*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer, \"*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer, \"*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer, \"*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.\");\n\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer, \"*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer, \"*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer, \"*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer, \"*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.\");\n\n\t\tthis->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));\n\t\tthis->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));\n\t\tthis->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));\n\t\tthis->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));\n\t}\n\t\n\ttemplate <typename T, precision P>\n\ttemplate <typename V1, typename V2, typename V3, typename V4>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\ttvec4<V1, P> const & v1,\n\t\ttvec4<V2, P> const & v2,\n\t\ttvec4<V3, P> const & v3,\n\t\ttvec4<V4, P> const & v4\n\t)\t\t\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\n\n\t\tthis->value[0] = col_type(v1);\n\t\tthis->value[1] = col_type(v2);\n\t\tthis->value[2] = col_type(v3);\n\t\tthis->value[3] = col_type(v4);\n\t}\n\n\t// -- Matrix conversions --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0, 0);\n\t\tthis->value[1] = col_type(m[1], 0, 0);\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0);\n\t\tthis->value[1] = col_type(m[1], 0);\n\t\tthis->value[2] = col_type(m[2], 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0);\n\t\tthis->value[1] = col_type(m[1], 0);\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0, 0);\n\t\tthis->value[1] = col_type(m[1], 0, 0);\n\t\tthis->value[2] = col_type(m[2], 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)\n\t{\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0, 0);\n\t\tthis->value[1] = col_type(m[1], 0, 0);\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)\n\t{\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = m[2];\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0);\n\t\tthis->value[1] = col_type(m[1], 0);\n\t\tthis->value[2] = col_type(m[2], 0);\n\t\tthis->value[3] = col_type(m[3], 1);\n\t}\n\n\t// -- Accesses --\n\n#\tifdef GLM_FORCE_SIZE_FUNC\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tmat4x4<T, P>::size_type tmat4x4<T, P>::size() const\n\t\t{\n\t\t\treturn 4;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::size_type i)\n\t\t{\n\t\t\tassert(i < this->size());\n\t\t\treturn this->value[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::size_type i) const\n\t\t{\n\t\t\tassert(i < this->size());\n\t\t\treturn this->value[i];\n\t\t}\n#\telse\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tmat4x4<T, P>::length_type tmat4x4<T, P>::length() const\n\t\t{\n\t\t\treturn 4;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)\n\t\t{\n\t\t\tassert(i < this->length());\n\t\t\treturn this->value[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const\n\t\t{\n\t\t\tassert(i < this->length());\n\t\t\treturn this->value[i];\n\t\t}\n#\tendif//GLM_FORCE_SIZE_FUNC\n\n\t// -- Unary arithmetic operators --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<T, P> const & m)\n\t\t{\n\t\t\t//memcpy could be faster\n\t\t\t//memcpy(&this->value, &m.value, 16 * sizeof(valType));\n\t\t\tthis->value[0] = m[0];\n\t\t\tthis->value[1] = m[1];\n\t\t\tthis->value[2] = m[2];\n\t\t\tthis->value[3] = m[3];\n\t\t\treturn *this;\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P> \n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)\n\t{\n\t\t//memcpy could be faster\n\t\t//memcpy(&this->value, &m.value, 16 * sizeof(valType));\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = m[2];\n\t\tthis->value[3] = m[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)\n\t{\n\t\tthis->value[0] += s;\n\t\tthis->value[1] += s;\n\t\tthis->value[2] += s;\n\t\tthis->value[3] += s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)\n\t{\n\t\tthis->value[0] += m[0];\n\t\tthis->value[1] += m[1];\n\t\tthis->value[2] += m[2];\n\t\tthis->value[3] += m[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)\n\t{\n\t\tthis->value[0] -= s;\n\t\tthis->value[1] -= s;\n\t\tthis->value[2] -= s;\n\t\tthis->value[3] -= s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)\n\t{\n\t\tthis->value[0] -= m[0];\n\t\tthis->value[1] -= m[1];\n\t\tthis->value[2] -= m[2];\n\t\tthis->value[3] -= m[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)\n\t{\n\t\tthis->value[0] *= s;\n\t\tthis->value[1] *= s;\n\t\tthis->value[2] *= s;\n\t\tthis->value[3] *= s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)\n\t{\n\t\treturn (*this = *this * m);\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)\n\t{\n\t\tthis->value[0] /= s;\n\t\tthis->value[1] /= s;\n\t\tthis->value[2] /= s;\n\t\tthis->value[3] /= s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)\n\t{\n\t\treturn (*this = *this * detail::compute_inverse<T, P>(m));\n\t}\n\n\t// -- Increment and decrement operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator++()\n\t{\n\t\t++this->value[0];\n\t\t++this->value[1];\n\t\t++this->value[2];\n\t\t++this->value[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator--()\n\t{\n\t\t--this->value[0];\n\t\t--this->value[1];\n\t\t--this->value[2];\n\t\t--this->value[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> tmat4x4<T, P>::operator++(int)\n\t{\n\t\ttmat4x4<T, P> Result(*this);\n\t\t++*this;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> tmat4x4<T, P>::operator--(int)\n\t{\n\t\ttmat4x4<T, P> Result(*this);\n\t\t--*this;\n\t\treturn Result;\n\t}\n\n\t// -- Unary constant operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m)\n\t{\n\t\treturn m;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\t-m[0],\n\t\t\t-m[1],\n\t\t\t-m[2],\n\t\t\t-m[3]);\n\t}\n\n\t// -- Binary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] + s,\n\t\t\tm[1] + s,\n\t\t\tm[2] + s,\n\t\t\tm[3] + s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] + s,\n\t\t\tm[1] + s,\n\t\t\tm[2] + s,\n\t\t\tm[3] + s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm1[0] + m2[0],\n\t\t\tm1[1] + m2[1],\n\t\t\tm1[2] + m2[2],\n\t\t\tm1[3] + m2[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] - s,\n\t\t\tm[1] - s,\n\t\t\tm[2] - s,\n\t\t\tm[3] - s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\ts - m[0],\n\t\t\ts - m[1],\n\t\t\ts - m[2],\n\t\t\ts - m[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm1[0] - m2[0],\n\t\t\tm1[1] - m2[1],\n\t\t\tm1[2] - m2[2],\n\t\t\tm1[3] - m2[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const  & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] * s,\n\t\t\tm[1] * s,\n\t\t\tm[2] * s,\n\t\t\tm[3] * s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] * s,\n\t\t\tm[1] * s,\n\t\t\tm[2] * s,\n\t\t\tm[3] * s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type operator*\n\t(\n\t\ttmat4x4<T, P> const & m,\n\t\ttypename tmat4x4<T, P>::row_type const & v\n\t)\n\t{\n/*\n\t\t__m128 v0 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(0, 0, 0, 0));\n\t\t__m128 v1 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(1, 1, 1, 1));\n\t\t__m128 v2 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(2, 2, 2, 2));\n\t\t__m128 v3 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(3, 3, 3, 3));\n\n\t\t__m128 m0 = _mm_mul_ps(m[0].data, v0);\n\t\t__m128 m1 = _mm_mul_ps(m[1].data, v1);\n\t\t__m128 a0 = _mm_add_ps(m0, m1);\n\n\t\t__m128 m2 = _mm_mul_ps(m[2].data, v2);\n\t\t__m128 m3 = _mm_mul_ps(m[3].data, v3);\n\t\t__m128 a1 = _mm_add_ps(m2, m3);\n\n\t\t__m128 a2 = _mm_add_ps(a0, a1);\n\n\t\treturn typename tmat4x4<T, P>::col_type(a2);\n*/\n\n\t\ttypename tmat4x4<T, P>::col_type const Mov0(v[0]);\n\t\ttypename tmat4x4<T, P>::col_type const Mov1(v[1]);\n\t\ttypename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;\n\t\ttypename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;\n\t\ttypename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;\n\t\ttypename tmat4x4<T, P>::col_type const Mov2(v[2]);\n\t\ttypename tmat4x4<T, P>::col_type const Mov3(v[3]);\n\t\ttypename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;\n\t\ttypename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;\n\t\ttypename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;\n\t\ttypename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;\n\t\treturn Add2;\n\n/*\n\t\treturn typename tmat4x4<T, P>::col_type(\n\t\t\tm[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3],\n\t\t\tm[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3],\n\t\t\tm[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3],\n\t\t\tm[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3]);\n*/\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::row_type operator*\n\t(\n\t\ttypename tmat4x4<T, P>::col_type const & v,\n\t\ttmat4x4<T, P> const & m\n\t)\n\t{\n\t\treturn typename tmat4x4<T, P>::row_type(\n\t\t\tm[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],\n\t\t\tm[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],\n\t\t\tm[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],\n\t\t\tm[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)\n\t{\n\t\treturn tmat2x4<T, P>(\n\t\t\tm1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],\n\t\t\tm1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],\n\t\t\tm1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],\n\t\t\tm1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],\n\t\t\tm1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],\n\t\t\tm1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],\n\t\t\tm1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],\n\t\t\tm1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)\n\t{\n\t\treturn tmat3x4<T, P>(\n\t\t\tm1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],\n\t\t\tm1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],\n\t\t\tm1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],\n\t\t\tm1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],\n\t\t\tm1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],\n\t\t\tm1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],\n\t\t\tm1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],\n\t\t\tm1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],\n\t\t\tm1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],\n\t\t\tm1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],\n\t\t\tm1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],\n\t\t\tm1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\ttypename tmat4x4<T, P>::col_type const SrcA0 = m1[0];\n\t\ttypename tmat4x4<T, P>::col_type const SrcA1 = m1[1];\n\t\ttypename tmat4x4<T, P>::col_type const SrcA2 = m1[2];\n\t\ttypename tmat4x4<T, P>::col_type const SrcA3 = m1[3];\n\n\t\ttypename tmat4x4<T, P>::col_type const SrcB0 = m2[0];\n\t\ttypename tmat4x4<T, P>::col_type const SrcB1 = m2[1];\n\t\ttypename tmat4x4<T, P>::col_type const SrcB2 = m2[2];\n\t\ttypename tmat4x4<T, P>::col_type const SrcB3 = m2[3];\n\n\t\ttmat4x4<T, P> Result(uninitialize);\n\t\tResult[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];\n\t\tResult[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];\n\t\tResult[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];\n\t\tResult[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] / s,\n\t\t\tm[1] / s,\n\t\t\tm[2] / s,\n\t\t\tm[3] / s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(T const & s,\ttmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\ts / m[0],\n\t\t\ts / m[1],\n\t\t\ts / m[2],\n\t\t\ts / m[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)\n\t{\n\t\treturn detail::compute_inverse<T, P>(m) * v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)\n\t{\n\t\treturn v * detail::compute_inverse<T, P>(m);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\ttmat4x4<T, P> m1_copy(m1);\n\t\treturn m1_copy /= m2;\n\t}\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);\n\t}\n}//namespace glm\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n///\n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n///\n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n///\n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/setup.hpp\n/// @date 2006-11-13 / 2014-10-05\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#pragma once\n\n#include <cassert>\n#include <cstddef>\n\n///////////////////////////////////////////////////////////////////////////////////\n// Version\n\n#define GLM_VERSION\t\t\t\t\t97\n#define GLM_VERSION_MAJOR\t\t\t0\n#define GLM_VERSION_MINOR\t\t\t9\n#define GLM_VERSION_PATCH\t\t\t7\n#define GLM_VERSION_REVISION\t\t5\n\n#if(defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_VERSION_DISPLAYED))\n#\tdefine GLM_MESSAGE_VERSION_DISPLAYED\n#\tpragma message (\"GLM: version 0.9.7.5\")\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// Platform\n\n#define GLM_PLATFORM_UNKNOWN\t\t0x00000000\n#define GLM_PLATFORM_WINDOWS\t\t0x00010000\n#define GLM_PLATFORM_LINUX\t\t\t0x00020000\n#define GLM_PLATFORM_APPLE\t\t\t0x00040000\n//#define GLM_PLATFORM_IOS\t\t\t0x00080000\n#define GLM_PLATFORM_ANDROID\t\t0x00100000\n#define GLM_PLATFORM_CHROME_NACL\t0x00200000\n#define GLM_PLATFORM_UNIX\t\t\t0x00400000\n#define GLM_PLATFORM_QNXNTO\t\t\t0x00800000\n#define GLM_PLATFORM_WINCE\t\t\t0x01000000\n#define GLM_PLATFORM_CYGWIN\t\t\t0x02000000\n\n#ifdef GLM_FORCE_PLATFORM_UNKNOWN\n#\tdefine GLM_PLATFORM GLM_PLATFORM_UNKNOWN\n#elif defined(__CYGWIN__)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_CYGWIN\n#elif defined(__QNXNTO__)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_QNXNTO\n#elif defined(__APPLE__)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_APPLE\n#elif defined(WINCE)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_WINCE\n#elif defined(_WIN32)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_WINDOWS\n#elif defined(__native_client__)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_CHROME_NACL\n#elif defined(__ANDROID__)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_ANDROID\n#elif defined(__linux)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_LINUX\n#elif defined(__unix)\n#\tdefine GLM_PLATFORM GLM_PLATFORM_UNIX\n#else\n#\tdefine GLM_PLATFORM GLM_PLATFORM_UNKNOWN\n#endif//\n\n// Report platform detection\n#if(defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_PLATFORM_DISPLAYED))\n#\tdefine GLM_MESSAGE_PLATFORM_DISPLAYED\n#\tif(GLM_PLATFORM & GLM_PLATFORM_QNXNTO)\n#\t\tpragma message(\"GLM: QNX platform detected\")\n//#\telif(GLM_PLATFORM & GLM_PLATFORM_IOS)\n//#\t\tpragma message(\"GLM: iOS platform detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_APPLE)\n#\t\tpragma message(\"GLM: Apple platform detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_WINCE)\n#\t\tpragma message(\"GLM: WinCE platform detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_WINDOWS)\n#\t\tpragma message(\"GLM: Windows platform detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_CHROME_NACL)\n#\t\tpragma message(\"GLM: Native Client detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_ANDROID)\n#\t\tpragma message(\"GLM: Android platform detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_LINUX)\n#\t\tpragma message(\"GLM: Linux platform detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_UNIX)\n#\t\tpragma message(\"GLM: UNIX platform detected\")\n#\telif(GLM_PLATFORM & GLM_PLATFORM_UNKNOWN)\n#\t\tpragma message(\"GLM: platform unknown\")\n#\telse\n#\t\tpragma message(\"GLM: platform not detected\")\n#\tendif\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// Compiler\n\n// User defines: GLM_FORCE_COMPILER_UNKNOWN\n// TODO ? __llvm__\n\n#define GLM_COMPILER_UNKNOWN\t\t0x00000000\n\n// Intel\n#define GLM_COMPILER_INTEL\t\t\t0x00100000\n#define GLM_COMPILER_INTEL12\t\t0x00100010\n#define GLM_COMPILER_INTEL12_1\t\t0x00100020\n#define GLM_COMPILER_INTEL13\t\t0x00100030\n#define GLM_COMPILER_INTEL14\t\t0x00100040\n#define GLM_COMPILER_INTEL15\t\t0x00100050\n#define GLM_COMPILER_INTEL16\t\t0x00100060\n\n// Visual C++ defines\n#define GLM_COMPILER_VC\t\t\t\t0x01000000\n#define GLM_COMPILER_VC2010\t\t\t0x01000090\n#define GLM_COMPILER_VC2012\t\t\t0x010000A0\n#define GLM_COMPILER_VC2013\t\t\t0x010000B0\n#define GLM_COMPILER_VC2015\t\t\t0x010000C0\n\n// GCC defines\n#define GLM_COMPILER_GCC\t\t\t0x02000000\n#define GLM_COMPILER_GCC44\t\t\t0x020000B0\n#define GLM_COMPILER_GCC45\t\t\t0x020000C0\n#define GLM_COMPILER_GCC46\t\t\t0x020000D0\n#define GLM_COMPILER_GCC47\t\t\t0x020000E0\n#define GLM_COMPILER_GCC48\t\t\t0x020000F0\n#define GLM_COMPILER_GCC49\t\t\t0x02000100\n#define GLM_COMPILER_GCC50\t\t\t0x02000200\n#define GLM_COMPILER_GCC51\t\t\t0x02000300\n#define GLM_COMPILER_GCC52\t\t\t0x02000400\n#define GLM_COMPILER_GCC53\t\t\t0x02000500\n#define GLM_COMPILER_GCC60\t\t\t0x02000600\n\n// CUDA\n#define GLM_COMPILER_CUDA\t\t\t0x10000000\n#define GLM_COMPILER_CUDA40\t\t\t0x10000040\n#define GLM_COMPILER_CUDA41\t\t\t0x10000050\n#define GLM_COMPILER_CUDA42\t\t\t0x10000060\n#define GLM_COMPILER_CUDA50\t\t\t0x10000070\n#define GLM_COMPILER_CUDA60\t\t\t0x10000080\n#define GLM_COMPILER_CUDA65\t\t\t0x10000090\n#define GLM_COMPILER_CUDA70\t\t\t0x100000A0\n#define GLM_COMPILER_CUDA75\t\t\t0x100000B0\n\n// LLVM\n#define GLM_COMPILER_LLVM\t\t\t0x20000000\n#define GLM_COMPILER_LLVM32\t\t\t0x20000030\n#define GLM_COMPILER_LLVM33\t\t\t0x20000040\n#define GLM_COMPILER_LLVM34\t\t\t0x20000050\n#define GLM_COMPILER_LLVM35\t\t\t0x20000060\n#define GLM_COMPILER_LLVM36\t\t\t0x20000070\n#define GLM_COMPILER_LLVM37\t\t\t0x20000080\n#define GLM_COMPILER_LLVM38\t\t\t0x20000090\n#define GLM_COMPILER_LLVM39\t\t\t0x200000A0\n\n// Apple Clang\n#define GLM_COMPILER_APPLE_CLANG\t0x40000000\n#define GLM_COMPILER_APPLE_CLANG40\t0x40000010\n#define GLM_COMPILER_APPLE_CLANG41\t0x40000020\n#define GLM_COMPILER_APPLE_CLANG42\t0x40000030\n#define GLM_COMPILER_APPLE_CLANG50\t0x40000040\n#define GLM_COMPILER_APPLE_CLANG51\t0x40000050\n#define GLM_COMPILER_APPLE_CLANG60\t0x40000060\n#define GLM_COMPILER_APPLE_CLANG61\t0x40000070\n\n// Build model\n#define GLM_MODEL_32\t\t\t\t0x00000010\n#define GLM_MODEL_64\t\t\t\t0x00000020\n\n// Force generic C++ compiler\n#ifdef GLM_FORCE_COMPILER_UNKNOWN\n#\tdefine GLM_COMPILER GLM_COMPILER_UNKNOWN\n\n#elif defined(__INTEL_COMPILER)\n#\tif __INTEL_COMPILER == 1200\n#\t\tdefine GLM_COMPILER GLM_COMPILER_INTEL12\n#\telif __INTEL_COMPILER == 1210\n#\t\tdefine GLM_COMPILER GLM_COMPILER_INTEL12_1\n#\telif __INTEL_COMPILER == 1300\n#\t\tdefine GLM_COMPILER GLM_COMPILER_INTEL13\n#\telif __INTEL_COMPILER == 1400\n#\t\tdefine GLM_COMPILER GLM_COMPILER_INTEL14\n#\telif __INTEL_COMPILER == 1500\n#\t\tdefine GLM_COMPILER GLM_COMPILER_INTEL15\n#\telif __INTEL_COMPILER >= 1600\n#\t\tdefine GLM_COMPILER GLM_COMPILER_INTEL16\n#\telse\n#\t\tdefine GLM_COMPILER GLM_COMPILER_INTEL\n#\tendif\n\n// CUDA\n#elif defined(__CUDACC__)\n#\tif !defined(CUDA_VERSION) && !defined(GLM_FORCE_CUDA)\n#\t\tinclude <cuda.h>  // make sure version is defined since nvcc does not define it itself!\n#\tendif\n#\tif CUDA_VERSION < 3000\n#\t\terror \"GLM requires CUDA 3.0 or higher\"\n#\telse\n#\t\tdefine GLM_COMPILER GLM_COMPILER_CUDA\n#\tendif\n\n// Visual C++\n#elif defined(_MSC_VER)\n#\tif _MSC_VER < 1600\n#\t\terror \"GLM requires Visual C++ 2010 or higher\"\n#\telif _MSC_VER == 1600\n#\t\tdefine GLM_COMPILER GLM_COMPILER_VC2010\n#\telif _MSC_VER == 1700\n#\t\tdefine GLM_COMPILER GLM_COMPILER_VC2012\n#\telif _MSC_VER == 1800\n#\t\tdefine GLM_COMPILER GLM_COMPILER_VC2013\n#\telif _MSC_VER >= 1900\n#\t\tdefine GLM_COMPILER GLM_COMPILER_VC2015\n#\telse//_MSC_VER\n#\t\tdefine GLM_COMPILER GLM_COMPILER_VC\n#\tendif//_MSC_VER\n\n// Clang\n#elif defined(__clang__)\n#\tif GLM_PLATFORM & GLM_PLATFORM_APPLE\n#\t\tif __clang_major__ == 4 && __clang_minor__ == 0\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG40\n#\t\telif __clang_major__ == 4 && __clang_minor__ == 1\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG41\n#\t\telif __clang_major__ == 4 && __clang_minor__ == 2\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG42\n#\t\telif __clang_major__ == 5 && __clang_minor__ == 0\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG50\n#\t\telif __clang_major__ == 5 && __clang_minor__ == 1\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG51\n#\t\telif __clang_major__ == 6 && __clang_minor__ == 0\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG60\n#\t\telif __clang_major__ == 6 && __clang_minor__ >= 1\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG61\n#\t\telif __clang_major__ >= 7\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG61\n#\t\telse\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_APPLE_CLANG\n#\t\tendif\n#\telse\n#\t\tif __clang_major__ == 3 && __clang_minor__ == 0\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM30\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 1\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM31\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 2\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM32\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 3\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM33\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 4\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM34\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 5\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM35\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 6\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM36\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 7\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM37\n#\t\telif __clang_major__ == 3 && __clang_minor__ == 8\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM38\n#\t\telif __clang_major__ == 3 && __clang_minor__ >= 9\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM39\n#\t\telif __clang_major__ >= 4\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM39\n#\t\telse\n#\t\t\tdefine GLM_COMPILER GLM_COMPILER_LLVM\n#\t\tendif\n#\tendif\n\n// G++\n#elif defined(__GNUC__) || defined(__MINGW32__)\n#\tif (__GNUC__ == 4) && (__GNUC_MINOR__ == 2)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC42)\n#\telif (__GNUC__ == 4) && (__GNUC_MINOR__ == 3)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC43)\n#\telif (__GNUC__ == 4) && (__GNUC_MINOR__ == 4)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC44)\n#\telif (__GNUC__ == 4) && (__GNUC_MINOR__ == 5)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC45)\n#\telif (__GNUC__ == 4) && (__GNUC_MINOR__ == 6)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC46)\n#\telif (__GNUC__ == 4) && (__GNUC_MINOR__ == 7)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC47)\n#\telif (__GNUC__ == 4) && (__GNUC_MINOR__ == 8)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC48)\n#\telif (__GNUC__ == 4) && (__GNUC_MINOR__ >= 9)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC49)\n#\telif (__GNUC__ == 5) && (__GNUC_MINOR__ == 0)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC50)\n#\telif (__GNUC__ == 5) && (__GNUC_MINOR__ == 1)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC51)\n#\telif (__GNUC__ == 5) && (__GNUC_MINOR__ == 2)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC52)\n#\telif (__GNUC__ == 5) && (__GNUC_MINOR__ >= 3)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC53)\n#\telif (__GNUC__ >= 6)\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC60)\n#\telse\n#\t\tdefine GLM_COMPILER (GLM_COMPILER_GCC)\n#\tendif\n\n#else\n#\tdefine GLM_COMPILER GLM_COMPILER_UNKNOWN\n#endif\n\n#ifndef GLM_COMPILER\n#error \"GLM_COMPILER undefined, your compiler may not be supported by GLM. Add #define GLM_COMPILER 0 to ignore this message.\"\n#endif//GLM_COMPILER\n\n// Report compiler detection\n#if defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_COMPILER_DISPLAYED)\n#\tdefine GLM_MESSAGE_COMPILER_DISPLAYED\n#\tif GLM_COMPILER & GLM_COMPILER_CUDA\n#\t\tpragma message(\"GLM: CUDA compiler detected\")\n#\telif GLM_COMPILER & GLM_COMPILER_VC\n#\t\tpragma message(\"GLM: Visual C++ compiler detected\")\n#\telif GLM_COMPILER & GLM_COMPILER_APPLE_CLANG\n#\t\tpragma message(\"GLM: Clang compiler detected\")\n#\telif GLM_COMPILER & GLM_COMPILER_LLVM\n#\t\tpragma message(\"GLM: LLVM compiler detected\")\n#\telif GLM_COMPILER & GLM_COMPILER_INTEL\n#\t\tpragma message(\"GLM: Intel Compiler detected\")\n#\telif GLM_COMPILER & GLM_COMPILER_GCC\n#\t\tpragma message(\"GLM: GCC compiler detected\")\n#\telse\n#\t\tpragma message(\"GLM: Compiler not detected\")\n#\tendif\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// Build model\n\n#if defined(__arch64__) || defined(__LP64__) || defined(_M_X64) || defined(__ppc64__) || defined(__x86_64__)\n#\t\tdefine GLM_MODEL\tGLM_MODEL_64\n#elif defined(__i386__) || defined(__ppc__)\n#\tdefine GLM_MODEL\tGLM_MODEL_32\n#else\n#\tdefine GLM_MODEL\tGLM_MODEL_32\n#endif//\n\n#if !defined(GLM_MODEL) && GLM_COMPILER != 0\n#\terror \"GLM_MODEL undefined, your compiler may not be supported by GLM. Add #define GLM_MODEL 0 to ignore this message.\"\n#endif//GLM_MODEL\n\n#if defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_MODEL_DISPLAYED)\n#\tdefine GLM_MESSAGE_MODEL_DISPLAYED\n#\tif(GLM_MODEL == GLM_MODEL_64)\n#\t\tpragma message(\"GLM: 64 bits model\")\n#\telif(GLM_MODEL == GLM_MODEL_32)\n#\t\tpragma message(\"GLM: 32 bits model\")\n#\tendif//GLM_MODEL\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// Platform\n\n// User defines: GLM_FORCE_PURE GLM_FORCE_SSE2 GLM_FORCE_SSE3 GLM_FORCE_AVX GLM_FORCE_AVX2 GLM_FORCE_AVX2\n\n#define GLM_ARCH_PURE\t\t0x0000\n#define GLM_ARCH_ARM\t\t0x0001\n#define GLM_ARCH_X86\t\t0x0002\n#define GLM_ARCH_SSE2\t\t0x0004\n#define GLM_ARCH_SSE3\t\t0x0008\n#define GLM_ARCH_SSE4\t\t0x0010\n#define GLM_ARCH_AVX\t\t0x0020\n#define GLM_ARCH_AVX2\t\t0x0040\n#define GLM_ARCH_AVX512\t\t0x0080 // Skylake set\n\n#if defined(GLM_FORCE_PURE)\n#\tdefine GLM_ARCH GLM_ARCH_PURE\n#elif defined(GLM_FORCE_AVX512)\n#\tdefine GLM_ARCH (GLM_ARCH_AVX512 | GLM_ARCH_AVX2 | GLM_ARCH_AVX | GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#elif defined(GLM_FORCE_AVX2)\n#\tdefine GLM_ARCH (GLM_ARCH_AVX2 | GLM_ARCH_AVX | GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#elif defined(GLM_FORCE_AVX)\n#\tdefine GLM_ARCH (GLM_ARCH_AVX | GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#elif defined(GLM_FORCE_SSE4)\n#\tdefine GLM_ARCH (GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#elif defined(GLM_FORCE_SSE3)\n#\tdefine GLM_ARCH (GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#elif defined(GLM_FORCE_SSE2)\n#\tdefine GLM_ARCH (GLM_ARCH_SSE2)\n#elif (GLM_COMPILER & (GLM_COMPILER_APPLE_CLANG | GLM_COMPILER_LLVM | GLM_COMPILER_GCC)) || ((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_PLATFORM & GLM_PLATFORM_LINUX))\n//\tThis is Skylake set of instruction set\n#\tif defined(__AVX512BW__) && defined(__AVX512F__) && defined(__AVX512CD__) && defined(__AVX512VL__) && defined(__AVX512DQ__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_AVX512 | GLM_ARCH_AVX2 | GLM_ARCH_AVX | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__AVX2__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_AVX2 | GLM_ARCH_AVX | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__AVX__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_AVX | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__SSE3__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__SSE2__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_SSE2)\n#\telse\n#\t\tdefine GLM_ARCH GLM_ARCH_PURE\n#\tendif\n#elif (GLM_COMPILER & GLM_COMPILER_VC) || ((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_PLATFORM & GLM_PLATFORM_WINDOWS))\n#\tif defined(_M_ARM_FP)\n#\t\tdefine GLM_ARCH (GLM_ARCH_ARM)\n#\telif defined(__AVX2__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_AVX2 | GLM_ARCH_AVX | GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__AVX__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_AVX | GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(_M_X64)\n#\t\tdefine GLM_ARCH (GLM_ARCH_SSE2)\n#\telif defined(_M_IX86_FP)\n#\t\tif _M_IX86_FP >= 2\n#\t\t\tdefine GLM_ARCH (GLM_ARCH_SSE2)\n#\t\telse\n#\t\t\tdefine GLM_ARCH (GLM_ARCH_PURE)\n#\t\tendif\n#\telse\n#\t\tdefine GLM_ARCH (GLM_ARCH_PURE)\n#\tendif\n#elif (GLM_COMPILER & GLM_COMPILER_GCC) && (defined(__i386__) || defined(__x86_64__))\n#\tif defined(__AVX2__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_AVX2 | GLM_ARCH_AVX | GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__AVX__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_AVX | GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__SSE4_1__ )\n#\t\tdefine GLM_ARCH (GLM_ARCH_SSE4 | GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__SSE3__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_SSE3 | GLM_ARCH_SSE2)\n#\telif defined(__SSE2__)\n#\t\tdefine GLM_ARCH (GLM_ARCH_SSE2)\n#\telse\n#\t\tdefine GLM_ARCH (GLM_ARCH_PURE)\n#\tendif\n#else\n#\tdefine GLM_ARCH GLM_ARCH_PURE\n#endif\n\n// With MinGW-W64, including intrinsic headers before intrin.h will produce some errors. The problem is\n// that windows.h (and maybe other headers) will silently include intrin.h, which of course causes problems.\n// To fix, we just explicitly include intrin.h here.\n#if defined(__MINGW64__) && (GLM_ARCH != GLM_ARCH_PURE)\n#\tinclude <intrin.h>\n#endif\n\n#if GLM_ARCH & GLM_ARCH_AVX2\n#\tinclude <immintrin.h>\n#endif//GLM_ARCH\n#if GLM_ARCH & GLM_ARCH_AVX\n#\tinclude <immintrin.h>\n#endif//GLM_ARCH\n#if GLM_ARCH & GLM_ARCH_SSE4\n#\tinclude <smmintrin.h>\n#endif//GLM_ARCH\n#if GLM_ARCH & GLM_ARCH_SSE3\n#\tinclude <pmmintrin.h>\n#endif//GLM_ARCH\n#if GLM_ARCH & GLM_ARCH_SSE2\n#\tinclude <emmintrin.h>\n#endif//GLM_ARCH\n\n#if defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_ARCH_DISPLAYED)\n#\tdefine GLM_MESSAGE_ARCH_DISPLAYED\n#\tif(GLM_ARCH == GLM_ARCH_PURE)\n#\t\tpragma message(\"GLM: Platform independent code\")\n#\telif(GLM_ARCH & GLM_ARCH_ARM)\n#\t\tpragma message(\"GLM: ARM instruction set\")\n#\telif(GLM_ARCH & GLM_ARCH_AVX2)\n#\t\tpragma message(\"GLM: AVX2 instruction set\")\n#\telif(GLM_ARCH & GLM_ARCH_AVX)\n#\t\tpragma message(\"GLM: AVX instruction set\")\n#\telif(GLM_ARCH & GLM_ARCH_SSE3)\n#\t\tpragma message(\"GLM: SSE3 instruction set\")\n#\telif(GLM_ARCH & GLM_ARCH_SSE2)\n#\t\tpragma message(\"GLM: SSE2 instruction set\")\n#\tendif//GLM_ARCH\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// C++ Version\n\n// User defines: GLM_FORCE_CXX98, GLM_FORCE_CXX03, GLM_FORCE_CXX11, GLM_FORCE_CXX14\n\n#define GLM_LANG_CXX98_FLAG\t\t\t(1 << 1)\n#define GLM_LANG_CXX03_FLAG\t\t\t(1 << 2)\n#define GLM_LANG_CXX0X_FLAG\t\t\t(1 << 3)\n#define GLM_LANG_CXX11_FLAG\t\t\t(1 << 4)\n#define GLM_LANG_CXX1Y_FLAG\t\t\t(1 << 5)\n#define GLM_LANG_CXX14_FLAG\t\t\t(1 << 6)\n#define GLM_LANG_CXX1Z_FLAG\t\t\t(1 << 7)\n#define GLM_LANG_CXXMS_FLAG\t\t\t(1 << 8)\n#define GLM_LANG_CXXGNU_FLAG\t\t(1 << 9)\n\n#define GLM_LANG_CXX98\t\t\tGLM_LANG_CXX98_FLAG\n#define GLM_LANG_CXX03\t\t\t(GLM_LANG_CXX98 | GLM_LANG_CXX03_FLAG)\n#define GLM_LANG_CXX0X\t\t\t(GLM_LANG_CXX03 | GLM_LANG_CXX0X_FLAG)\n#define GLM_LANG_CXX11\t\t\t(GLM_LANG_CXX0X | GLM_LANG_CXX11_FLAG)\n#define GLM_LANG_CXX1Y\t\t\t(GLM_LANG_CXX11 | GLM_LANG_CXX1Y_FLAG)\n#define GLM_LANG_CXX14\t\t\t(GLM_LANG_CXX1Y | GLM_LANG_CXX14_FLAG)\n#define GLM_LANG_CXX1Z\t\t\t(GLM_LANG_CXX14 | GLM_LANG_CXX1Z_FLAG)\n#define GLM_LANG_CXXMS\t\t\tGLM_LANG_CXXMS_FLAG\n#define GLM_LANG_CXXGNU\t\t\tGLM_LANG_CXXGNU_FLAG\n\n#if defined(GLM_FORCE_CXX14)\n#\tundef GLM_FORCE_CXX11\n#\tundef GLM_FORCE_CXX03\n#\tundef GLM_FORCE_CXX98\n#\tdefine GLM_LANG GLM_LANG_CXX14\n#elif defined(GLM_FORCE_CXX11)\n#\tundef GLM_FORCE_CXX03\n#\tundef GLM_FORCE_CXX98\n#\tdefine GLM_LANG GLM_LANG_CXX11\n#elif defined(GLM_FORCE_CXX03)\n#\tundef GLM_FORCE_CXX98\n#\tdefine GLM_LANG GLM_LANG_CXX03\n#elif defined(GLM_FORCE_CXX98)\n#\tdefine GLM_LANG GLM_LANG_CXX98\n#else\n#\tif GLM_COMPILER & (GLM_COMPILER_APPLE_CLANG | GLM_COMPILER_LLVM)\n#\t\tif __cplusplus >= 201402L // GLM_COMPILER_LLVM34 + -std=c++14\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX14\n#\t\telif __has_feature(cxx_decltype_auto) && __has_feature(cxx_aggregate_nsdmi) // GLM_COMPILER_LLVM33 + -std=c++1y\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX1Y\n#\t\telif __cplusplus >= 201103L // GLM_COMPILER_LLVM33 + -std=c++11\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX11\n#\t\telif __has_feature(cxx_static_assert) // GLM_COMPILER_LLVM29 + -std=c++11\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX0X\n#\t\telif __cplusplus >= 199711L\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX98\n#\t\telse\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX\n#\t\tendif\n#\telif GLM_COMPILER & GLM_COMPILER_GCC\n#\t\tif __cplusplus >= 201402L\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX14\n#\t\telif __cplusplus >= 201103L\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX11\n#\t\telif defined(__GXX_EXPERIMENTAL_CXX0X__)\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX0X\n#\t\telse\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX98\n#\t\tendif\n#\telif GLM_COMPILER & GLM_COMPILER_VC\n#\t\tifdef _MSC_EXTENSIONS\n#\t\t\tif __cplusplus >= 201402L\n#\t\t\t\tdefine GLM_LANG (GLM_LANG_CXX14 | GLM_LANG_CXXMS_FLAG)\n//#\t\t\telif GLM_COMPILER >= GLM_COMPILER_VC2015\n//#\t\t\t\tdefine GLM_LANG (GLM_LANG_CXX1Y | GLM_LANG_CXXMS_FLAG)\n#\t\t\telif __cplusplus >= 201103L\n#\t\t\t\tdefine GLM_LANG (GLM_LANG_CXX11 | GLM_LANG_CXXMS_FLAG)\n#\t\t\telif GLM_COMPILER >= GLM_COMPILER_VC2010\n#\t\t\t\tdefine GLM_LANG (GLM_LANG_CXX0X | GLM_LANG_CXXMS_FLAG)\n#\t\t\telif __cplusplus >= 199711L\n#\t\t\t\tdefine GLM_LANG (GLM_LANG_CXX98 | GLM_LANG_CXXMS_FLAG)\n#\t\t\telse\n#\t\t\t\tdefine GLM_LANG (GLM_LANG_CXX | GLM_LANG_CXXMS_FLAG)\n#\t\t\tendif\n#\t\telse\n#\t\t\tif __cplusplus >= 201402L\n#\t\t\t\tdefine GLM_LANG GLM_LANG_CXX14\n//#\t\t\telif GLM_COMPILER >= GLM_COMPILER_VC2015\n//#\t\t\t\tdefine GLM_LANG GLM_LANG_CXX1Y\n#\t\t\telif __cplusplus >= 201103L\n#\t\t\t\tdefine GLM_LANG GLM_LANG_CXX11\n#\t\t\telif GLM_COMPILER >= GLM_COMPILER_VC2010\n#\t\t\t\tdefine GLM_LANG GLM_LANG_CXX0X\n#\t\t\telif __cplusplus >= 199711L\n#\t\t\t\tdefine GLM_LANG GLM_LANG_CXX98\n#\t\t\telse\n#\t\t\t\tdefine GLM_LANG GLM_LANG_CXX\n#\t\t\tendif\n#\t\tendif\n#\telif GLM_COMPILER & GLM_COMPILER_INTEL\n#\t\tifdef _MSC_EXTENSIONS\n#\t\t\tdefine GLM_MSC_EXT GLM_LANG_CXXMS_FLAG\n#\t\telse\n#\t\t\tdefine GLM_MSC_EXT 0\n#\t\tendif\n#\t\tif __cplusplus >= 201402L\n#\t\t\tdefine GLM_LANG (GLM_LANG_CXX14 | GLM_MSC_EXT)\n#\t\telif __cplusplus >= 201103L\n#\t\t\tdefine GLM_LANG (GLM_LANG_CXX11 | GLM_MSC_EXT)\n#\t\telif __INTEL_CXX11_MODE__\n#\t\t\tdefine GLM_LANG (GLM_LANG_CXX0X | GLM_MSC_EXT)\n#\t\telif __cplusplus >= 199711L\n#\t\t\tdefine GLM_LANG (GLM_LANG_CXX98 | GLM_MSC_EXT)\n#\t\telse\n#\t\t\tdefine GLM_LANG (GLM_LANG_CXX | GLM_MSC_EXT)\n#\t\tendif\n#\telse // Unkown compiler\n#\t\tif __cplusplus >= 201402L\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX14\n#\t\telif __cplusplus >= 201103L\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX11\n#\t\telif __cplusplus >= 199711L\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX98\n#\t\telse\n#\t\t\tdefine GLM_LANG GLM_LANG_CXX // Good luck with that!\n#\t\tendif\n#\t\tifndef GLM_FORCE_PURE\n#\t\t\tdefine GLM_FORCE_PURE\n#\t\tendif\n#\tendif\n#endif\n\n#if defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_LANG_DISPLAYED)\n#\tdefine GLM_MESSAGE_LANG_DISPLAYED\n\n#\tif GLM_LANG & GLM_LANG_CXX1Z_FLAG\n#\t\tpragma message(\"GLM: C++1z\")\n#\telif GLM_LANG & GLM_LANG_CXX14_FLAG\n#\t\tpragma message(\"GLM: C++14\")\n#\telif GLM_LANG & GLM_LANG_CXX1Y_FLAG\n#\t\tpragma message(\"GLM: C++1y\")\n#\telif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\t\tpragma message(\"GLM: C++11\")\n#\telif GLM_LANG & GLM_LANG_CXX0X_FLAG\n#\t\tpragma message(\"GLM: C++0x\")\n#\telif GLM_LANG & GLM_LANG_CXX03_FLAG\n#\t\tpragma message(\"GLM: C++03\")\n#\telif GLM_LANG & GLM_LANG_CXX98_FLAG\n#\t\tpragma message(\"GLM: C++98\")\n#\telse\n#\t\tpragma message(\"GLM: C++ language undetected\")\n#\tendif//GLM_LANG\n\n#\tif GLM_LANG & (GLM_LANG_CXXGNU_FLAG | GLM_LANG_CXXMS_FLAG)\n#\t\tpragma message(\"GLM: Language extensions enabled\")\n#\tendif//GLM_LANG\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// Has of C++ features\n\n// http://clang.llvm.org/cxx_status.html\n// http://gcc.gnu.org/projects/cxx0x.html\n// http://msdn.microsoft.com/en-us/library/vstudio/hh567368(v=vs.120).aspx\n\n#if GLM_PLATFORM == GLM_PLATFORM_ANDROID || GLM_PLATFORM == GLM_PLATFORM_CYGWIN\n#\tdefine GLM_HAS_CXX11_STL 0\n#elif GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tif __has_include(<__config>) // libc++\n#\t\tinclude <__config>\n//#\telse // libstdc++\n//#\t\tinclude <bits/c++config.h>\n#\tendif\n#\tif defined(_LIBCPP_VERSION)// || defined(__GLIBCXX__)\n#\t\tdefine GLM_HAS_CXX11_STL 1\n#\telse\n#\t\tdefine GLM_HAS_CXX11_STL 0\n#\tendif\n#else\n#\tdefine GLM_HAS_CXX11_STL ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && \\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC48)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2013)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_COMPILER >= GLM_COMPILER_INTEL15)))\n#endif\n\n// N1720\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_STATIC_ASSERT __has_feature(cxx_static_assert)\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_STATIC_ASSERT 1\n#else\n#\tdefine GLM_HAS_STATIC_ASSERT ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC43)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2010))))\n#endif\n\n// N1988\n#if GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_EXTENDED_INTEGER_TYPE 1\n#else\n#\tdefine GLM_HAS_EXTENDED_INTEGER_TYPE (\\\n\t\t((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2012)) || \\\n\t\t((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC43)) || \\\n\t\t((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (GLM_COMPILER & GLM_COMPILER_LLVM) && (GLM_COMPILER >= GLM_COMPILER_LLVM30)) || \\\n\t\t((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (GLM_COMPILER & GLM_COMPILER_APPLE_CLANG) && (GLM_COMPILER >= GLM_COMPILER_APPLE_CLANG40)))\n#endif\n\n// N2235\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_CONSTEXPR __has_feature(cxx_constexpr)\n#\tdefine GLM_HAS_CONSTEXPR_PARTIAL GLM_HAS_CONSTEXPR\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_CONSTEXPR 1\n#\tdefine GLM_HAS_CONSTEXPR_PARTIAL GLM_HAS_CONSTEXPR\n#else\n#\tdefine GLM_HAS_CONSTEXPR ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC46))))\n#\tdefine GLM_HAS_CONSTEXPR_PARTIAL (GLM_HAS_CONSTEXPR || ((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2015)))\n#endif\n\n// N2672\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_INITIALIZER_LISTS __has_feature(cxx_generalized_initializers)\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_INITIALIZER_LISTS 1\n#else\n#\tdefine GLM_HAS_INITIALIZER_LISTS ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC44)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2013))))\n#endif\n\n// N2544 Unrestricted unions\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_UNRESTRICTED_UNIONS __has_feature(cxx_unrestricted_unions)\n#elif GLM_LANG & (GLM_LANG_CXX11_FLAG | GLM_LANG_CXXMS_FLAG)\n#\tdefine GLM_HAS_UNRESTRICTED_UNIONS 1\n#else\n#\tdefine GLM_HAS_UNRESTRICTED_UNIONS (GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC46)))\n#endif\n\n// N2346\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_DEFAULTED_FUNCTIONS __has_feature(cxx_defaulted_functions)\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_DEFAULTED_FUNCTIONS 1\n#else\n#\tdefine GLM_HAS_DEFAULTED_FUNCTIONS ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC44)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2013)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_COMPILER >= GLM_COMPILER_INTEL12))))\n#endif\n\n// N2118\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_RVALUE_REFERENCES __has_feature(cxx_rvalue_references)\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_RVALUE_REFERENCES 1\n#else\n#\tdefine GLM_HAS_RVALUE_REFERENCES ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC43)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2012))))\n#endif\n\n// N2437 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_EXPLICIT_CONVERSION_OPERATORS __has_feature(cxx_explicit_conversions)\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_EXPLICIT_CONVERSION_OPERATORS 1\n#else\n#\tdefine GLM_HAS_EXPLICIT_CONVERSION_OPERATORS ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC45)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_COMPILER >= GLM_COMPILER_INTEL14)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2013))))\n#endif\n\n// N2258 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_TEMPLATE_ALIASES __has_feature(cxx_alias_templates)\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_TEMPLATE_ALIASES 1\n#else\n#\tdefine GLM_HAS_TEMPLATE_ALIASES ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_COMPILER >= GLM_COMPILER_INTEL12_1)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC47)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2013))))\n#endif\n\n// N2930 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html\n#if GLM_COMPILER & (GLM_COMPILER_LLVM | GLM_COMPILER_APPLE_CLANG)\n#\tdefine GLM_HAS_RANGE_FOR __has_feature(cxx_range_for)\n#elif GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_RANGE_FOR 1\n#else\n#\tdefine GLM_HAS_RANGE_FOR ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC46)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_COMPILER >= GLM_COMPILER_INTEL13)) || \\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2012))))\n#endif\n\n//\n#if GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_ASSIGNABLE 1\n#else\n#\tdefine GLM_HAS_ASSIGNABLE ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_GCC) && (GLM_COMPILER >= GLM_COMPILER_GCC49))))\n#endif\n\n//\n#define GLM_HAS_TRIVIAL_QUERIES 0\n\n//\n#if GLM_LANG & GLM_LANG_CXX11_FLAG\n#\tdefine GLM_HAS_MAKE_SIGNED 1\n#else\n#\tdefine GLM_HAS_MAKE_SIGNED ((GLM_LANG & GLM_LANG_CXX0X_FLAG) && (\\\n\t\t((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2013))))\n#endif\n\n#if GLM_ARCH == GLM_ARCH_PURE\n#\tdefine GLM_HAS_BITSCAN_WINDOWS 0\n#else\n#\tdefine GLM_HAS_BITSCAN_WINDOWS ((GLM_PLATFORM & GLM_PLATFORM_WINDOWS) && (\\\n\t\t(GLM_COMPILER & (GLM_COMPILER_VC | GLM_COMPILER_INTEL))))\n#endif\n\n// OpenMP\n#ifdef _OPENMP\n#\tif GLM_COMPILER & GLM_COMPILER_GCC\n#\t\tif GLM_COMPILER >= GLM_COMPILER_GCC47\n#\t\t\tdefine GLM_HAS_OPENMP 31\n#\t\telif GLM_COMPILER >= GLM_COMPILER_GCC44\n#\t\t\tdefine GLM_HAS_OPENMP 30\n#\t\telif GLM_COMPILER >= GLM_COMPILER_GCC42\n#\t\t\tdefine GLM_HAS_OPENMP 25\n#\t\tendif\n#\tendif// GLM_COMPILER & GLM_COMPILER_GCC\n\n#\tif GLM_COMPILER & GLM_COMPILER_VC\n#\t\tif GLM_COMPILER >= GLM_COMPILER_VC2010\n#\t\t\tdefine GLM_HAS_OPENMP 20\n#\t\tendif\n#\tendif// GLM_COMPILER & GLM_COMPILER_VC\n#endif\n\n// Not standard\n#define GLM_HAS_ANONYMOUS_UNION (GLM_LANG & GLM_LANG_CXXMS_FLAG)\n\n///////////////////////////////////////////////////////////////////////////////////\n// Static assert\n\n#if GLM_HAS_STATIC_ASSERT\n#\tdefine GLM_STATIC_ASSERT(x, message) static_assert(x, message)\n#elif defined(BOOST_STATIC_ASSERT)\n#\tdefine GLM_STATIC_ASSERT(x, message) BOOST_STATIC_ASSERT(x)\n#elif GLM_COMPILER & GLM_COMPILER_VC\n#\tdefine GLM_STATIC_ASSERT(x, message) typedef char __CASSERT__##__LINE__[(x) ? 1 : -1]\n#else\n#\tdefine GLM_STATIC_ASSERT(x, message)\n#\tdefine GLM_STATIC_ASSERT_NULL\n#endif//GLM_LANG\n\n///////////////////////////////////////////////////////////////////////////////////\n// Qualifiers\n\n#if GLM_COMPILER & GLM_COMPILER_CUDA\n#\tdefine GLM_CUDA_FUNC_DEF __device__ __host__\n#\tdefine GLM_CUDA_FUNC_DECL __device__ __host__\n#else\n#\tdefine GLM_CUDA_FUNC_DEF\n#\tdefine GLM_CUDA_FUNC_DECL\n#endif\n\n#if GLM_COMPILER & GLM_COMPILER_GCC\n#\tdefine GLM_VAR_USED __attribute__ ((unused))\n#else\n#\tdefine GLM_VAR_USED\n#endif\n\n#if defined(GLM_FORCE_INLINE)\n#\tif GLM_COMPILER & GLM_COMPILER_VC\n#\t\tdefine GLM_INLINE __forceinline\n#\t\tdefine GLM_NEVER_INLINE __declspec((noinline))\n#\telif GLM_COMPILER & (GLM_COMPILER_GCC | GLM_COMPILER_APPLE_CLANG | GLM_COMPILER_LLVM)\n#\t\tdefine GLM_INLINE inline __attribute__((__always_inline__))\n#\t\tdefine GLM_NEVER_INLINE __attribute__((__noinline__))\n#\telse\n#\t\tdefine GLM_INLINE inline\n#\t\tdefine GLM_NEVER_INLINE\n#\tendif//GLM_COMPILER\n#else\n#\tdefine GLM_INLINE inline\n#\tdefine GLM_NEVER_INLINE\n#endif//defined(GLM_FORCE_INLINE)\n\n#define GLM_FUNC_DECL GLM_CUDA_FUNC_DECL\n#define GLM_FUNC_QUALIFIER GLM_CUDA_FUNC_DEF GLM_INLINE\n\n///////////////////////////////////////////////////////////////////////////////////\n// Swizzle operators\n\n// User defines: GLM_SWIZZLE\n\n#if defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_SWIZZLE_DISPLAYED)\n#\tdefine GLM_MESSAGE_SWIZZLE_DISPLAYED\n#\tif defined(GLM_SWIZZLE)\n#\t\tpragma message(\"GLM: Swizzling operators enabled\")\n#\telse\n#\t\tpragma message(\"GLM: Swizzling operators disabled, #define GLM_SWIZZLE to enable swizzle operators\")\n#\tendif\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// Qualifiers\n\n#if (GLM_COMPILER & GLM_COMPILER_VC) || ((GLM_COMPILER & GLM_COMPILER_INTEL) && (GLM_PLATFORM & GLM_PLATFORM_WINDOWS))\n#\tdefine GLM_DEPRECATED __declspec(deprecated)\n#\tdefine GLM_ALIGN(x) __declspec(align(x))\n#\tdefine GLM_ALIGNED_STRUCT(x) struct __declspec(align(x))\n#\tdefine GLM_ALIGNED_TYPEDEF(type, name, alignment) typedef __declspec(align(alignment)) type name\n#\tdefine GLM_RESTRICT __declspec(restrict)\n#\tdefine GLM_RESTRICT_VAR __restrict\n#elif GLM_COMPILER & (GLM_COMPILER_GCC | GLM_COMPILER_APPLE_CLANG | GLM_COMPILER_LLVM | GLM_COMPILER_CUDA | GLM_COMPILER_INTEL)\n#\tdefine GLM_DEPRECATED __attribute__((__deprecated__))\n#\tdefine GLM_ALIGN(x) __attribute__((aligned(x)))\n#\tdefine GLM_ALIGNED_STRUCT(x) struct __attribute__((aligned(x)))\n#\tdefine GLM_ALIGNED_TYPEDEF(type, name, alignment) typedef type name __attribute__((aligned(alignment)))\n#\tdefine GLM_RESTRICT __restrict__\n#\tdefine GLM_RESTRICT_VAR __restrict__\n#else\n#\tdefine GLM_DEPRECATED\n#\tdefine GLM_ALIGN\n#\tdefine GLM_ALIGNED_STRUCT(x) struct\n#\tdefine GLM_ALIGNED_TYPEDEF(type, name, alignment) typedef type name\n#\tdefine GLM_RESTRICT\n#\tdefine GLM_RESTRICT_VAR\n#endif//GLM_COMPILER\n\n#if GLM_HAS_DEFAULTED_FUNCTIONS\n#\tdefine GLM_DEFAULT = default\n#\tifdef GLM_FORCE_NO_CTOR_INIT\n#\t\tdefine GLM_DEFAULT_CTOR = default\n#\telse\n#\t\tdefine GLM_DEFAULT_CTOR\n#\tendif\n#else\n#\tdefine GLM_DEFAULT\n#\tdefine GLM_DEFAULT_CTOR\n#endif\n\n#if GLM_HAS_CONSTEXPR\n#\tdefine GLM_CONSTEXPR constexpr\n#\tdefine GLM_RELAXED_CONSTEXPR constexpr\n#else\n#\tdefine GLM_CONSTEXPR\n#\tdefine GLM_RELAXED_CONSTEXPR const\n#endif\n\n#ifdef GLM_FORCE_EXPLICIT_CTOR\n#\tdefine GLM_EXPLICIT explicit\n#else\n#\tdefine GLM_EXPLICIT\n#endif\n\n///////////////////////////////////////////////////////////////////////////////////\n// Length type\n\n// User defines: GLM_FORCE_SIZE_T_LENGTH GLM_FORCE_SIZE_FUNC\n\nnamespace glm\n{\n\tusing std::size_t;\n#\tif defined(GLM_FORCE_SIZE_T_LENGTH) || defined(GLM_FORCE_SIZE_FUNC)\n\t\ttypedef size_t length_t;\n#\telse\n\t\ttypedef int length_t;\n#\tendif\n\nnamespace detail\n{\n#\tifdef GLM_FORCE_SIZE_FUNC\n\t\ttypedef size_t component_count_t;\n#\telse\n\t\ttypedef length_t component_count_t;\n#\tendif\n\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR component_count_t component_count(genType const & m)\n\t{\n#\t\tifdef GLM_FORCE_SIZE_FUNC\n\t\t\treturn m.size();\n#\t\telse\n\t\t\treturn m.length();\n#\t\tendif\n\t}\n}//namespace detail\n}//namespace glm\n\n#if defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_FORCE_SIZE_T_LENGTH)\n#\tdefine GLM_MESSAGE_FORCE_SIZE_T_LENGTH\n#\tif defined GLM_FORCE_SIZE_FUNC\n#\t\tpragma message(\"GLM: .length() is replaced by .size() and returns a std::size_t\")\n#\telif defined GLM_FORCE_SIZE_T_LENGTH\n#\t\tpragma message(\"GLM: .length() returns glm::length_t, a typedef of std::size_t\")\n#\telse\n#\t\tpragma message(\"GLM: .length() returns glm::length_t, a typedef of int following the GLSL specification\")\n#\tendif\n#endif//GLM_MESSAGE\n\n///////////////////////////////////////////////////////////////////////////////////\n// countof\n\n#ifndef __has_feature\n#\tdefine __has_feature(x) 0 // Compatibility with non-clang compilers.\n#endif\n\n#if GLM_HAS_CONSTEXPR_PARTIAL\n\tnamespace glm\n\t{\n\t\ttemplate <typename T, std::size_t N>\n\t\tconstexpr std::size_t countof(T const (&)[N])\n\t\t{\n\t\t\treturn N;\n\t\t}\n\t}//namespace glm\n#\tdefine GLM_COUNTOF(arr) glm::countof(arr)\n#elif defined(_MSC_VER)\n#\tdefine GLM_COUNTOF(arr) _countof(arr)\n#else\n#\tdefine GLM_COUNTOF(arr) sizeof(arr) / sizeof(arr[0])\n#endif\n\n///////////////////////////////////////////////////////////////////////////////////\n// Uninitialize constructors\n\nnamespace glm\n{\n\tenum ctor{uninitialize};\n}//namespace glm\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n  \n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <intsize_t I, class T> class tuple_element; // undefined\ntemplate <intsize_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t _Ip, class ..._Tp>\n  using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <intsize_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <intsize_t I, class... T>\n    typename const tuple_element<I, tuple<T...>>::type &\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <intsize_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr T1 const& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// tuple_size\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<tuple<_Tp...> >\n    : public integral_constant<size_t, sizeof...(_Tp)>\n{\n};\n\n// tuple_element\n\ntemplate <size_t _Ip, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, tuple<_Tp...> >\n{\npublic:\n    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Ip, class ..._Tp>\nusing tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;\n#endif\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp, bool=is_empty<_Hp>::value\n#if __has_feature(is_final)\n                                 && !__is_final(_Hp)\n#endif\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)) ||\n                        (is_rvalue_reference<_Hp>::value &&\n                         !is_lvalue_reference<_Tp>::value),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <bool ...> struct __all;\n\ntemplate <>\nstruct __all<>\n{\n    static const bool value = true;\n};\n\ntemplate <bool _B0, bool ... _Bp>\nstruct __all<_B0, _Bp...>\n{\n    static const bool value = _B0 && __all<_Bp...>::value;\n};\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value)) \n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_constructible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value &&\n                         !__tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value,\n                         bool\n                      >::type =false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              class = typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple>::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple>::value &&\n                         !__tuple_convertible<_Tuple, tuple>::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n// get by type\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_helper;\n\n// -- find exactly one\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_checker {\n    static constexpr size_t value = _Idx;\n//  Check the rest of the list to make sure there's only one\n    static_assert ( __find_exactly_one_t_helper<_T1, 0, _Args...>::value == -1, \"type can only occur once in type list\" );\n    };\n\n\ntemplate <typename _T1, size_t _Idx>\nstruct __find_exactly_one_t_helper <_T1, _Idx> {\n    static constexpr size_t value = -1;\n    };\n\ntemplate <typename _T1, size_t _Idx, typename _Head, typename... _Args>\nstruct __find_exactly_one_t_helper <_T1, _Idx, _Head, _Args...> {\n    static constexpr size_t value =\n        std::conditional<\n            std::is_same<_T1, _Head>::value,\n            __find_exactly_one_t_checker<_T1, _Idx,   _Args...>,\n            __find_exactly_one_t_helper <_T1, _Idx+1, _Args...>\n        >::type::value;\n    };\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t {\n    static constexpr size_t value = __find_exactly_one_t_helper<_T1, 0, _Args...>::value;\n    static_assert ( value != -1, \"type not found in type list\" );\n    };\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_less<_Ip-1>()(__x, __y) ||\n             (!__tuple_less<_Ip-1>()(__y, __x) && _VSTD::get<_Ip-1>(__x) < _VSTD::get<_Ip-1>(__y));\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_STATIC_H\n#define FASTANIM_STATIC_H\n\n#include \"Value.h\"\n\nnamespace fanim {\n\n  template<typename ValueType> class Static : public Value<ValueType> {\n  private:\n    ValueType value;\n  public:\n    Static(const ValueType& valuep) : value(valuep) {}\n    virtual ~Static() {}\n    virtual ValueType get() {\n      return value;\n    }\n  };\n\n}\n\n#endif //FASTANIM_VALUE_H\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_VALUE_H\n#define FASTANIM_VALUE_H\n\nnamespace fanim {\n\n  template<typename ValueType> class Value {\n  public:\n    virtual ~Value() {};\n    virtual ValueType get() = 0;\n  };\n\n}\n\n#endif //FASTANIM_VALUE_H\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_SCALETRANSFORMATION_H\n#define FASTANIM_SCALETRANSFORMATION_H\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include \"Transformation.h\"\n\nnamespace fanim {\n\n  class ScaleTransformation : public Transformation {\n  public:\n    std::shared_ptr<Value<glm::vec3>> vector;\n    virtual glm::mat4 getMatrix() {\n      return glm::scale(glm::mat4(), vector->get());\n    }\n    ScaleTransformation(std::shared_ptr<Value<glm::vec3>> vectorp) : vector(vectorp) {}\n    ~ScaleTransformation() {}\n  };\n\n}\n\n#endif //FASTANIM_POSITIONTRANSFORMATION_H\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_TRANSFORMATION_H\n#define FASTANIM_TRANSFORMATION_H\n\n#include \"glm/glm.hpp\"\n\nnamespace fanim {\n\n  class Transformation {\n  public:\n    virtual glm::mat4 getMatrix() = 0;\n    virtual ~Transformation() {};\n  };\n\n}\n\n\n#endif //FASTANIM_TRANSFORMATION_H\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref gtc_matrix_transform\n/// @file glm/gtc/matrix_transform.inl\n/// @date 2009-04-29 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#include \"../geometric.hpp\"\n#include \"../trigonometric.hpp\"\n#include \"../matrix.hpp\"\n\nnamespace glm\n{\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> translate\n\t(\n\t\ttmat4x4<T, P> const & m,\n\t\ttvec3<T, P> const & v\n\t)\n\t{\n\t\ttmat4x4<T, P> Result(m);\n\t\tResult[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];\n\t\treturn Result;\n\t}\n\t\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> rotate\n\t(\n\t\ttmat4x4<T, P> const & m,\n\t\tT angle,\n\t\ttvec3<T, P> const & v\n\t)\n\t{\n\t\tT const a = angle;\n\t\tT const c = cos(a);\n\t\tT const s = sin(a);\n\n\t\ttvec3<T, P> axis(normalize(v));\n\t\ttvec3<T, P> temp((T(1) - c) * axis);\n\n\t\ttmat4x4<T, P> Rotate(uninitialize);\n\t\tRotate[0][0] = c + temp[0] * axis[0];\n\t\tRotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];\n\t\tRotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];\n\n\t\tRotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];\n\t\tRotate[1][1] = c + temp[1] * axis[1];\n\t\tRotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];\n\n\t\tRotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];\n\t\tRotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];\n\t\tRotate[2][2] = c + temp[2] * axis[2];\n\n\t\ttmat4x4<T, P> Result(uninitialize);\n\t\tResult[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];\n\t\tResult[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];\n\t\tResult[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];\n\t\tResult[3] = m[3];\n\t\treturn Result;\n\t}\n\t\t\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> rotate_slow\n\t(\n\t\ttmat4x4<T, P> const & m,\n\t\tT angle, \n\t\ttvec3<T, P> const & v\n\t)\n\t{\n\t\tT const a = angle;\n\t\tT const c = cos(a);\n\t\tT const s = sin(a);\n\t\ttmat4x4<T, P> Result;\n\n\t\ttvec3<T, P> axis = normalize(v);\n\n\t\tResult[0][0] = c + (1 - c)      * axis.x     * axis.x;\n\t\tResult[0][1] = (1 - c) * axis.x * axis.y + s * axis.z;\n\t\tResult[0][2] = (1 - c) * axis.x * axis.z - s * axis.y;\n\t\tResult[0][3] = 0;\n\n\t\tResult[1][0] = (1 - c) * axis.y * axis.x - s * axis.z;\n\t\tResult[1][1] = c + (1 - c) * axis.y * axis.y;\n\t\tResult[1][2] = (1 - c) * axis.y * axis.z + s * axis.x;\n\t\tResult[1][3] = 0;\n\n\t\tResult[2][0] = (1 - c) * axis.z * axis.x + s * axis.y;\n\t\tResult[2][1] = (1 - c) * axis.z * axis.y - s * axis.x;\n\t\tResult[2][2] = c + (1 - c) * axis.z * axis.z;\n\t\tResult[2][3] = 0;\n\n\t\tResult[3] = tvec4<T, P>(0, 0, 0, 1);\n\t\treturn m * Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> scale\n\t(\n\t\ttmat4x4<T, P> const & m,\n\t\ttvec3<T, P> const & v\n\t)\n\t{\n\t\ttmat4x4<T, P> Result(uninitialize);\n\t\tResult[0] = m[0] * v[0];\n\t\tResult[1] = m[1] * v[1];\n\t\tResult[2] = m[2] * v[2];\n\t\tResult[3] = m[3];\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> scale_slow\n\t(\n\t\ttmat4x4<T, P> const & m,\n\t\ttvec3<T, P> const & v\n\t)\n\t{\n\t\ttmat4x4<T, P> Result(T(1));\n\t\tResult[0][0] = v.x;\n\t\tResult[1][1] = v.y;\n\t\tResult[2][2] = v.z;\n\t\treturn m * Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> ortho\n\t(\n\t\tT left,\n\t\tT right,\n\t\tT bottom,\n\t\tT top,\n\t\tT zNear,\n\t\tT zFar\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(1);\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\n\t\tResult[2][2] = - static_cast<T>(2) / (zFar - zNear);\n\t\tResult[3][0] = - (right + left) / (right - left);\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\n\t\tResult[3][2] = - (zFar + zNear) / (zFar - zNear);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> ortho\n\t(\n\t\tT left,\n\t\tT right,\n\t\tT bottom,\n\t\tT top\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(1);\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\n\t\tResult[2][2] = - static_cast<T>(1);\n\t\tResult[3][0] = - (right + left) / (right - left);\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> frustum\n\t(\n\t\tT left,\n\t\tT right,\n\t\tT bottom,\n\t\tT top,\n\t\tT nearVal,\n\t\tT farVal\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(0);\n\t\tResult[0][0] = (static_cast<T>(2) * nearVal) / (right - left);\n\t\tResult[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);\n\t\tResult[2][0] = (right + left) / (right - left);\n\t\tResult[2][1] = (top + bottom) / (top - bottom);\n\t\tResult[2][2] = -(farVal + nearVal) / (farVal - nearVal);\n\t\tResult[2][3] = static_cast<T>(-1);\n\t\tResult[3][2] = -(static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspective\n\t(\n\t\tT fovy,\n\t\tT aspect,\n\t\tT zNear,\n\t\tT zFar\n\t)\n\t{\n\t\t#ifdef GLM_LEFT_HANDED\n\t\t\treturn perspectiveLH(fovy, aspect, zNear, zFar);\n\t\t#else\n\t\t\treturn perspectiveRH(fovy, aspect, zNear, zFar);\n\t\t#endif\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveRH\n\t(\n\t\tT fovy,\n\t\tT aspect,\n\t\tT zNear,\n\t\tT zFar\n\t)\n\t{\n\t\tassert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));\n\n\t\tT const tanHalfFovy = tan(fovy / static_cast<T>(2));\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);\n\t\tResult[1][1] = static_cast<T>(1) / (tanHalfFovy);\n\t\tResult[2][2] = - (zFar + zNear) / (zFar - zNear);\n\t\tResult[2][3] = - static_cast<T>(1);\n\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n\t\treturn Result;\n\t}\n\t\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveLH\n\t\t(\n\t\tT fovy,\n\t\tT aspect,\n\t\tT zNear,\n\t\tT zFar\n\t\t)\n\t{\n\t\tassert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));\n\n\t\tT const tanHalfFovy = tan(fovy / static_cast<T>(2));\n\t\t\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);\n\t\tResult[1][1] = static_cast<T>(1) / (tanHalfFovy);\n\t\tResult[2][2] = (zFar + zNear) / (zFar - zNear);\n\t\tResult[2][3] = static_cast<T>(1);\n\t\tResult[3][2] = -(static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFov\n\t(\n\t\tT fov,\n\t\tT width,\n\t\tT height,\n\t\tT zNear,\n\t\tT zFar\n\t)\n\t{\n\t\t#ifdef GLM_LEFT_HANDED\n\t\t\treturn perspectiveFovLH(fov, width, height, zNear, zFar);\n\t\t#else\n\t\t\treturn perspectiveFovRH(fov, width, height, zNear, zFar);\n\t\t#endif\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFovRH\n\t(\n\t\tT fov,\n\t\tT width,\n\t\tT height,\n\t\tT zNear,\n\t\tT zFar\n\t)\n\t{\n\t\tassert(width > static_cast<T>(0));\n\t\tassert(height > static_cast<T>(0));\n\t\tassert(fov > static_cast<T>(0));\n\t\n\t\tT const rad = fov;\n\t\tT const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);\n\t\tT const w = h * height / width; ///todo max(width , Height) / min(width , Height)?\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = w;\n\t\tResult[1][1] = h;\n\t\tResult[2][2] = - (zFar + zNear) / (zFar - zNear);\n\t\tResult[2][3] = - static_cast<T>(1);\n\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFovLH\n\t(\n\t\tT fov,\n\t\tT width,\n\t\tT height,\n\t\tT zNear,\n\t\tT zFar\n\t)\n\t{\n\t\tassert(width > static_cast<T>(0));\n\t\tassert(height > static_cast<T>(0));\n\t\tassert(fov > static_cast<T>(0));\n\t\n\t\tT const rad = fov;\n\t\tT const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);\n\t\tT const w = h * height / width; ///todo max(width , Height) / min(width , Height)?\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = w;\n\t\tResult[1][1] = h;\n\t\tResult[2][2] = (zFar + zNear) / (zFar - zNear);\n\t\tResult[2][3] = static_cast<T>(1);\n\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> infinitePerspective\n\t(\n\t\tT fovy,\n\t\tT aspect,\n\t\tT zNear\n\t)\n\t{\n\t\tT const range = tan(fovy / T(2)) * zNear;\n\t\tT const left = -range * aspect;\n\t\tT const right = range * aspect;\n\t\tT const bottom = -range;\n\t\tT const top = range;\n\n\t\ttmat4x4<T, defaultp> Result(T(0));\n\t\tResult[0][0] = (T(2) * zNear) / (right - left);\n\t\tResult[1][1] = (T(2) * zNear) / (top - bottom);\n\t\tResult[2][2] = - T(1);\n\t\tResult[2][3] = - T(1);\n\t\tResult[3][2] = - T(2) * zNear;\n\t\treturn Result;\n\t}\n\n\t// Infinite projection matrix: http://www.terathon.com/gdc07_lengyel.pdf\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> tweakedInfinitePerspective\n\t(\n\t\tT fovy,\n\t\tT aspect,\n\t\tT zNear,\n\t\tT ep\n\t)\n\t{\n\t\tT const range = tan(fovy / T(2)) * zNear;\t\n\t\tT const left = -range * aspect;\n\t\tT const right = range * aspect;\n\t\tT const bottom = -range;\n\t\tT const top = range;\n\n\t\ttmat4x4<T, defaultp> Result(T(0));\n\t\tResult[0][0] = (static_cast<T>(2) * zNear) / (right - left);\n\t\tResult[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);\n\t\tResult[2][2] = ep - static_cast<T>(1);\n\t\tResult[2][3] = static_cast<T>(-1);\n\t\tResult[3][2] = (ep - static_cast<T>(2)) * zNear;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> tweakedInfinitePerspective\n\t(\n\t\tT fovy,\n\t\tT aspect,\n\t\tT zNear\n\t)\n\t{\n\t\treturn tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());\n\t}\n\n\ttemplate <typename T, typename U, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> project\n\t(\n\t\ttvec3<T, P> const & obj,\n\t\ttmat4x4<T, P> const & model,\n\t\ttmat4x4<T, P> const & proj,\n\t\ttvec4<U, P> const & viewport\n\t)\n\t{\n\t\ttvec4<T, P> tmp = tvec4<T, P>(obj, T(1));\n\t\ttmp = model * tmp;\n\t\ttmp = proj * tmp;\n\n\t\ttmp /= tmp.w;\n\t\ttmp = tmp * T(0.5) + T(0.5);\n\t\ttmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);\n\t\ttmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);\n\n\t\treturn tvec3<T, P>(tmp);\n\t}\n\n\ttemplate <typename T, typename U, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> unProject\n\t(\n\t\ttvec3<T, P> const & win,\n\t\ttmat4x4<T, P> const & model,\n\t\ttmat4x4<T, P> const & proj,\n\t\ttvec4<U, P> const & viewport\n\t)\n\t{\n\t\ttmat4x4<T, P> Inverse = inverse(proj * model);\n\n\t\ttvec4<T, P> tmp = tvec4<T, P>(win, T(1));\n\t\ttmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);\n\t\ttmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);\n\t\ttmp = tmp * T(2) - T(1);\n\n\t\ttvec4<T, P> obj = Inverse * tmp;\n\t\tobj /= obj.w;\n\n\t\treturn tvec3<T, P>(obj);\n\t}\n\n\ttemplate <typename T, precision P, typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> pickMatrix\n\t(\n\t\ttvec2<T, P> const & center,\n\t\ttvec2<T, P> const & delta,\n\t\ttvec4<U, P> const & viewport\n\t)\n\t{\n\t\tassert(delta.x > T(0) && delta.y > T(0));\n\t\ttmat4x4<T, P> Result(1.0f);\n\n\t\tif(!(delta.x > T(0) && delta.y > T(0)))\n\t\t\treturn Result; // Error\n\n\t\ttvec3<T, P> Temp(\n\t\t\t(T(viewport[2]) - T(2) * (center.x - T(viewport[0]))) / delta.x,\n\t\t\t(T(viewport[3]) - T(2) * (center.y - T(viewport[1]))) / delta.y,\n\t\t\tT(0));\n\n\t\t// Translate and scale the picked region to the entire window\n\t\tResult = translate(Result, Temp);\n\t\treturn scale(Result, tvec3<T, P>(T(viewport[2]) / delta.x, T(viewport[3]) / delta.y, T(1)));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAt\n\t(\n\t\ttvec3<T, P> const & eye,\n\t\ttvec3<T, P> const & center,\n\t\ttvec3<T, P> const & up\n\t)\n\t{\n\t\t#ifdef GLM_LEFT_HANDED\n\t\t\treturn lookAtLH(eye, center, up);\n\t\t#else\n\t\t\treturn lookAtRH(eye, center, up);\n\t\t#endif\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAtRH\n\t(\n\t\ttvec3<T, P> const & eye,\n\t\ttvec3<T, P> const & center,\n\t\ttvec3<T, P> const & up\n\t)\n\t{\n\t\ttvec3<T, P> const f(normalize(center - eye));\n\t\ttvec3<T, P> const s(normalize(cross(f, up)));\n\t\ttvec3<T, P> const u(cross(s, f));\n\n\t\ttmat4x4<T, P> Result(1);\n\t\tResult[0][0] = s.x;\n\t\tResult[1][0] = s.y;\n\t\tResult[2][0] = s.z;\n\t\tResult[0][1] = u.x;\n\t\tResult[1][1] = u.y;\n\t\tResult[2][1] = u.z;\n\t\tResult[0][2] =-f.x;\n\t\tResult[1][2] =-f.y;\n\t\tResult[2][2] =-f.z;\n\t\tResult[3][0] =-dot(s, eye);\n\t\tResult[3][1] =-dot(u, eye);\n\t\tResult[3][2] = dot(f, eye);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAtLH\n\t(\n\t\ttvec3<T, P> const & eye,\n\t\ttvec3<T, P> const & center,\n\t\ttvec3<T, P> const & up\n\t)\n\t{\n\t\ttvec3<T, P> const f(normalize(center - eye));\n\t\ttvec3<T, P> const s(normalize(cross(up, f)));\n\t\ttvec3<T, P> const u(cross(f, s));\n\n\t\ttmat4x4<T, P> Result(1);\n\t\tResult[0][0] = s.x;\n\t\tResult[1][0] = s.y;\n\t\tResult[2][0] = s.z;\n\t\tResult[0][1] = u.x;\n\t\tResult[1][1] = u.y;\n\t\tResult[2][1] = u.z;\n\t\tResult[0][2] = f.x;\n\t\tResult[1][2] = f.y;\n\t\tResult[2][2] = f.z;\n\t\tResult[3][0] = -dot(s, eye);\n\t\tResult[3][1] = -dot(u, eye);\n\t\tResult[3][2] = -dot(f, eye);\n\t\treturn Result;\n\t}\n}//namespace glm\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_SPRITENODE_H\n#define FASTANIM_SPRITENODE_H\n\n#include <fastgfx.h>\n#include <memory>\n#include \"Node.h\"\n#include \"../value/Value.h\"\n\nnamespace fanim {\n\n  class SpriteNode : public Node {\n  public:\n    std::shared_ptr<fgfx::SpriteLayer> layer;\n    std::shared_ptr<fgfx::Sprite> sprite;\n    std::shared_ptr<Value<glm::vec4>> color;\n\n    SpriteNode(\n        const std::shared_ptr<fgfx::SpriteLayer>& layerp,\n        const std::shared_ptr<fgfx::Sprite>& spritep,\n        const std::shared_ptr<Value<glm::vec4>>& colorp\n    ) : layer(layerp), sprite(spritep), color(colorp) {}\n\n    virtual ~SpriteNode() override {}\n\n    virtual void render() override {\n      /*const float *values = (const float*)(&computedMatrix);\n      fgfx_log(\"COMPUTED SPACE MATRIX: %d -> %d\\n%f %f %f %f\\n%f %f %f %f\\n%f %f %f %f\\n%f %f %f %f\\n\",this,values,\n                     values[0],values[1],values[2],values[3],values[4],values[5],values[6],values[7],\n                     values[8],values[9],values[10],values[11],values[12],values[13],values[14],values[15]);*/\n\n      layer->bufferSprite(sprite, computedMatrix, color->get());\n      Node::render();\n    }\n\n\n\n  };\n\n}\n\n#endif //FASTANIM_SPRITENODE_H\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    explicit __split_buffer(__alloc_rr& __a);\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__alloc_rr>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr&, __alloc_rr&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_alloc(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility>\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _VSTD::move(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return __first1;  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return __first1;\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __first1;\n    _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return __last1;\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return __first1;\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return __first1;\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __n, __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            swap(*__first, *__last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __min_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *__min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __max_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *__max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result ( *__first, *__first );\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n    \n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(__prev, *__first)) {\n            if (__comp(__prev, __result.first))    __result.first  = __prev;\n            if (__comp(__result.second, *__first)) __result.second = *__first;\n            }\n        else {\n            if (__comp(*__first, __result.first)) __result.first  = *__first;\n            if (__comp(__result.second, __prev))  __result.second = __prev;\n            }\n                \n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __merge<_Compare>(move_iterator<value_type*>(__buff),\n                          move_iterator<value_type*>(__p),\n                          move_iterator<_BidirectionalIterator>(__middle),\n                          move_iterator<_BidirectionalIterator>(__last),\n                          __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),\n                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),\n                _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n        {\n            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);\n            return;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _Tp>\nstruct __inplace_merge_switch\n{\n    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_left(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_right(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===---------------------------- limits ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LIMITS\n#define _LIBCPP_LIMITS\n\n/*\n    limits synopsis\n\nnamespace std\n{\n\ntemplate<class T>\nclass numeric_limits\n{\npublic:\n    static constexpr bool is_specialized = false;\n    static constexpr T min() noexcept;\n    static constexpr T max() noexcept;\n    static constexpr T lowest() noexcept;\n\n    static constexpr int  digits = 0;\n    static constexpr int  digits10 = 0;\n    static constexpr int  max_digits10 = 0;\n    static constexpr bool is_signed = false;\n    static constexpr bool is_integer = false;\n    static constexpr bool is_exact = false;\n    static constexpr int  radix = 0;\n    static constexpr T epsilon() noexcept;\n    static constexpr T round_error() noexcept;\n\n    static constexpr int  min_exponent = 0;\n    static constexpr int  min_exponent10 = 0;\n    static constexpr int  max_exponent = 0;\n    static constexpr int  max_exponent10 = 0;\n\n    static constexpr bool has_infinity = false;\n    static constexpr bool has_quiet_NaN = false;\n    static constexpr bool has_signaling_NaN = false;\n    static constexpr float_denorm_style has_denorm = denorm_absent;\n    static constexpr bool has_denorm_loss = false;\n    static constexpr T infinity() noexcept;\n    static constexpr T quiet_NaN() noexcept;\n    static constexpr T signaling_NaN() noexcept;\n    static constexpr T denorm_min() noexcept;\n\n    static constexpr bool is_iec559 = false;\n    static constexpr bool is_bounded = false;\n    static constexpr bool is_modulo = false;\n\n    static constexpr bool traps = false;\n    static constexpr bool tinyness_before = false;\n    static constexpr float_round_style round_style = round_toward_zero;\n};\n\nenum float_round_style\n{\n    round_indeterminate       = -1,\n    round_toward_zero         =  0,\n    round_to_nearest          =  1,\n    round_toward_infinity     =  2,\n    round_toward_neg_infinity =  3\n};\n\nenum float_denorm_style\n{\n    denorm_indeterminate = -1,\n    denorm_absent = 0,\n    denorm_present = 1\n};\n\ntemplate<> class numeric_limits<cv bool>;\n\ntemplate<> class numeric_limits<cv char>;\ntemplate<> class numeric_limits<cv signed char>;\ntemplate<> class numeric_limits<cv unsigned char>;\ntemplate<> class numeric_limits<cv wchar_t>;\ntemplate<> class numeric_limits<cv char16_t>;\ntemplate<> class numeric_limits<cv char32_t>;\n\ntemplate<> class numeric_limits<cv short>;\ntemplate<> class numeric_limits<cv int>;\ntemplate<> class numeric_limits<cv long>;\ntemplate<> class numeric_limits<cv long long>;\ntemplate<> class numeric_limits<cv unsigned short>;\ntemplate<> class numeric_limits<cv unsigned int>;\ntemplate<> class numeric_limits<cv unsigned long>;\ntemplate<> class numeric_limits<cv unsigned long long>;\n\ntemplate<> class numeric_limits<cv float>;\ntemplate<> class numeric_limits<cv double>;\ntemplate<> class numeric_limits<cv long double>;\n\n}  // std\n\n*/\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include <__config>\n#include <type_traits>\n\n#include <__undef_min_max>\n\n#if defined(_LIBCPP_MSVCRT)\n#include \"support/win32/limits_win32.h\"\n#endif // _LIBCPP_MSVCRT\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/limits.h\"\n#endif // __IBMCPP__\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nenum float_round_style\n{\n    round_indeterminate       = -1,\n    round_toward_zero         =  0,\n    round_to_nearest          =  1,\n    round_toward_infinity     =  2,\n    round_toward_neg_infinity =  3\n};\n\nenum float_denorm_style\n{\n    denorm_indeterminate = -1,\n    denorm_absent = 0,\n    denorm_present = 1\n};\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nclass __libcpp_numeric_limits\n{\nprotected:\n    typedef _Tp type;\n\n    static _LIBCPP_CONSTEXPR const  bool is_specialized = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return type();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = 0;\n    static _LIBCPP_CONSTEXPR const int  digits10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;\n    static _LIBCPP_CONSTEXPR const bool is_signed = false;\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = 0;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = false;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = false;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;\n};\n\ntemplate <class _Tp, int digits, bool is_signed>\nstruct __libcpp_compute_min\n{\n    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(_Tp(1) << digits);\n};\n\ntemplate <class _Tp, int digits>\nstruct __libcpp_compute_min<_Tp, digits, false>\n{\n    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(0);\n};\n\ntemplate <class _Tp>\nclass __libcpp_numeric_limits<_Tp, true>\n{\nprotected:\n    typedef _Tp type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = type(-1) < type(0);\n    static _LIBCPP_CONSTEXPR const int  digits = static_cast<int>(sizeof(type) * __CHAR_BIT__ - is_signed);\n    static _LIBCPP_CONSTEXPR const int  digits10 = digits * 3 / 10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;\n    static _LIBCPP_CONSTEXPR const type __min = __libcpp_compute_min<type, digits, is_signed>::value;\n    static _LIBCPP_CONSTEXPR const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = true;\n    static _LIBCPP_CONSTEXPR const bool is_exact = true;\n    static _LIBCPP_CONSTEXPR const int  radix = 2;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = false;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = !_VSTD::is_signed<_Tp>::value;\n\n#if __i386__ || __x86_64__\n    static _LIBCPP_CONSTEXPR const bool traps = true;\n#else\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n#endif\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<bool, true>\n{\nprotected:\n    typedef bool type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = false;\n    static _LIBCPP_CONSTEXPR const int  digits = 1;\n    static _LIBCPP_CONSTEXPR const int  digits10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;\n    static _LIBCPP_CONSTEXPR const type __min = false;\n    static _LIBCPP_CONSTEXPR const type __max = true;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = true;\n    static _LIBCPP_CONSTEXPR const bool is_exact = true;\n    static _LIBCPP_CONSTEXPR const int  radix = 2;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = false;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<float, true>\n{\nprotected:\n    typedef float type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = true;\n    static _LIBCPP_CONSTEXPR const int  digits = __FLT_MANT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __FLT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __FLT_MIN__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __FLT_MAX__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __FLT_EPSILON__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5F;}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __FLT_MIN_EXP__;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __FLT_MIN_10_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __FLT_MAX_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __FLT_MAX_10_EXP__;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = true;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valf();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __FLT_DENORM_MIN__;}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<double, true>\n{\nprotected:\n    typedef double type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = true;\n    static _LIBCPP_CONSTEXPR const int  digits = __DBL_MANT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __DBL_DIG__;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __DBL_MIN__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __DBL_MAX__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __DBL_EPSILON__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __DBL_MIN_EXP__;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __DBL_MIN_10_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __DBL_MAX_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __DBL_MAX_10_EXP__;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = true;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_val();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __DBL_DENORM_MIN__;}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<long double, true>\n{\nprotected:\n    typedef long double type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = true;\n    static _LIBCPP_CONSTEXPR const int  digits = __LDBL_MANT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __LDBL_DIG__;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __LDBL_MIN__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __LDBL_MAX__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __LDBL_EPSILON__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __LDBL_MIN_EXP__;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __LDBL_MIN_10_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __LDBL_MAX_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __LDBL_MAX_10_EXP__;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = true;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_vall();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __LDBL_DENORM_MIN__;}\n\n#if (defined(__ppc__) || defined(__ppc64__))\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n#else\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;\n#endif\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits\n    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>\n{\n    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;\n    typedef typename __base::type type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<_Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits<const _Tp>\n    : private numeric_limits<_Tp>\n{\n    typedef numeric_limits<_Tp> __base;\n    typedef _Tp type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const _Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits<volatile _Tp>\n    : private numeric_limits<_Tp>\n{\n    typedef numeric_limits<_Tp> __base;\n    typedef _Tp type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits<const volatile _Tp>\n    : private numeric_limits<_Tp>\n{\n    typedef numeric_limits<_Tp> __base;\n    typedef _Tp type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LIMITS\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","//\n// Created by Michał Łaszczewski on 04/07/16.\n//\n\n#ifndef ENGINE_LINEARTRANSITION_H\n#define ENGINE_LINEARTRANSITION_H\n\n#include <glm/glm.hpp>\nnamespace fanim {\n\n  template<typename ValueType>\n  class LinearTransition : public Transition<ValueType> {\n  public:\n    ValueType currentValue;\n    std::shared_ptr<Value<ValueType>> lastValue;\n    std::shared_ptr<Value<ValueType>> nextValue;\n    float remainingTime;\n    float transitionTime;\n\n    LinearTransition(std::shared_ptr<Value<ValueType>> firstValuep) {\n      setCurrent(firstValuep);\n    }\n\n    virtual ~LinearTransition() override { }\n\n    virtual void advance(float delta) override {\n      ValueType next = nextValue->get();\n      ValueType last = lastValue->get();\n      remainingTime -= delta;\n      if (remainingTime <= 0) {\n        remainingTime = 0;\n        currentValue = next;\n        return;\n      }\n      currentValue = next - (next - last) * (remainingTime / transitionTime);\n      return;\n    }\n\n    virtual void setNext(std::shared_ptr<Value<ValueType>> nextValuep, float timep) override {\n      lastValue = nextValue;\n      nextValue = nextValuep;\n      transitionTime = timep;\n      remainingTime = timep;\n      if(remainingTime != 0) {\n        lastValue = std::make_shared < Static < ValueType >> (currentValue);\n      }\n    }\n\n    virtual void setCurrent(std::shared_ptr<Value<ValueType>> currentp) override {\n      nextValue = currentp;\n      lastValue = currentp;\n      currentValue = currentp->get();\n      remainingTime = 0;\n      transitionTime = 0;\n    }\n\n    virtual ValueType get() override {\n      return currentValue;\n    }\n\n  };\n\n}\n\n#endif //ENGINE_LINEARTRANSITION_H\n","//\n// Created by Michał Łaszczewski on 04/07/16.\n//\n\n#ifndef ENGINE_TRANSITION_H\n#define ENGINE_TRANSITION_H\n\nnamespace fanim {\n\n  template<typename ValueType> class Transition : public Value<ValueType>, public Animated {\n  public:\n\n    virtual ~Transition() {};\n    virtual void advance(float delta) = 0;\n    virtual void setNext(std::shared_ptr<Value<ValueType>> nextValuep, float timep) = 0;\n    virtual void setCurrent(std::shared_ptr<Value<ValueType>> currentp) = 0;\n    virtual ValueType get() = 0;\n  };\n\n}\n\n#endif //ENGINE_TRANSITION_H\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_ANIMATED_H\n#define FASTANIM_ANIMATED_H\n\nnamespace fanim {\n\n  class Animated {\n  public:\n    virtual void advance(float delta) = 0;\n  };\n\n}\n\n\n#endif //FASTANIM_ANIMATED_H\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_TRANSLATETRANSFORMATION_H\n#define FASTANIM_TRANSLATETRANSFORMATION_H\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include \"Transformation.h\"\n\nnamespace fanim {\n\n  class TranslateTransformation : public Transformation {\n  public:\n    std::shared_ptr<Value<glm::vec3>> vector;\n    virtual glm::mat4 getMatrix() {\n      return glm::translate(glm::mat4(), vector->get());\n    }\n    TranslateTransformation(std::shared_ptr<Value<glm::vec3>> vectorp) : vector(vectorp) {}\n    ~TranslateTransformation() {}\n  };\n\n}\n\n#endif //FASTANIM_POSITIONTRANSFORMATION_H\n","//\n// Created by Michał Łaszczewski on 18/08/16.\n//\n\n#ifndef FASTANIM_LOOKATCAMERA_H\n#define FASTANIM_LOOKATCAMERA_H\n\n#include \"Camera.h\"\n\nnamespace fanim {\n\n  class LookAtCamera : public Camera{\n  public:\n    std::shared_ptr<Value<glm::vec3>> position;\n    std::shared_ptr<Value<glm::vec3>> target;\n    std::shared_ptr<Value<glm::vec3>> up;\n\n    std::shared_ptr<Value<float>> fov;\n    float zNear;\n    float zFar;\n\n    LookAtCamera(\n        std::shared_ptr<Value<glm::vec3>> positionp,\n        std::shared_ptr<Value<glm::vec3>> targetp,\n        std::shared_ptr<Value<glm::vec3>> upp,\n        std::shared_ptr<Value<float>> fovp,\n        float zNearp,\n        float zFarp\n    ) : position(positionp), target(targetp), up(upp), fov(fovp), zNear(zNearp), zFar(zFarp) {}\n    virtual ~LookAtCamera() {}\n\n    virtual void computeMatrix(int width, int height) override {\n      float aspectRatio = 1.0 * width / height;\n      projection = glm::perspective(35.0f, aspectRatio, 0.1f, 1000.0f);\n      view = glm::lookAt(glm::vec3(0, 0, 20), glm::vec3(0, 0, 0),glm::vec3(0, -1, 0));\n      camera = projection * view;\n    }\n  };\n\n}\n\n#endif //FASTANIM_LOOKATCAMERA_H\n","//\n// Created by Michał Łaszczewski on 17/08/16.\n//\n\n#ifndef FASTANIM_CAMERA_H\n#define FASTANIM_CAMERA_H\n\n#include <fastgfx.h>\n#include <memory>\n#include \"../value/Value.h\"\n\nnamespace fanim {\n\n  class Camera {\n  public:\n\n    glm::mat4 projection;\n    glm::mat4 view;\n    glm::mat4 camera;\n\n    virtual ~Camera() {}\n    virtual void computeMatrix(int width, int height) = 0;\n\n  };\n\n}\n\n#endif //FASTANIM_CAMERA_H\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/func_common.inl\n/// @date 2008-08-03 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#include \"func_vector_relational.hpp\"\n#include \"type_vec2.hpp\"\n#include \"type_vec3.hpp\"\n#include \"type_vec4.hpp\"\n#include \"_vectorize.hpp\"\n#include <limits>\n\nnamespace glm{\nnamespace detail\n{\n\ttemplate <typename genFIType, bool /*signed*/>\n\tstruct compute_abs\n\t{};\n\n\ttemplate <typename genFIType>\n\tstruct compute_abs<genFIType, true>\n\t{\n\t\tGLM_FUNC_QUALIFIER static genFIType call(genFIType x)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(\n\t\t\t\tstd::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed,\n\t\t\t\t\"'abs' only accept floating-point and integer scalar or vector inputs\");\n\n\t\t\treturn x >= genFIType(0) ? x : -x;\n\t\t\t// TODO, perf comp with: *(((int *) &x) + 1) &= 0x7fffffff;\n\t\t}\n\t};\n\n\ttemplate <typename genFIType>\n\tstruct compute_abs<genFIType, false>\n\t{\n\t\tGLM_FUNC_QUALIFIER static genFIType call(genFIType x)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(\n\t\t\t\t!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer,\n\t\t\t\t\"'abs' only accept floating-point and integer scalar or vector inputs\");\n\t\t\treturn x;\n\t\t}\n\t};\n\n\ttemplate <typename T, typename U, precision P, template <class, precision> class vecType>\n\tstruct compute_mix_vector\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<U>::is_iec559, \"'mix' only accept floating-point inputs for the interpolator a\");\n\n\t\t\treturn vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, template <class, precision> class vecType>\n\tstruct compute_mix_vector<T, bool, P, vecType>\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<bool, P> const & a)\n\t\t{\n\t\t\tvecType<T, P> Result(uninitialize);\n\t\t\tfor(detail::component_count_t i = 0; i < detail::component_count(x); ++i)\n\t\t\t\tResult[i] = a[i] ? y[i] : x[i];\n\t\t\treturn Result;\n\t\t}\n\t};\n\n\ttemplate <typename T, typename U, precision P, template <class, precision> class vecType>\n\tstruct compute_mix_scalar\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, U const & a)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<U>::is_iec559, \"'mix' only accept floating-point inputs for the interpolator a\");\n\n\t\t\treturn vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, template <class, precision> class vecType>\n\tstruct compute_mix_scalar<T, bool, P, vecType>\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, bool const & a)\n\t\t{\n\t\t\treturn a ? y : x;\n\t\t}\n\t};\n\n\ttemplate <typename T, typename U>\n\tstruct compute_mix\n\t{\n\t\tGLM_FUNC_QUALIFIER static T call(T const & x, T const & y, U const & a)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<U>::is_iec559, \"'mix' only accept floating-point inputs for the interpolator a\");\n\n\t\t\treturn static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));\n\t\t}\n\t};\n\n\ttemplate <typename T>\n\tstruct compute_mix<T, bool>\n\t{\n\t\tGLM_FUNC_QUALIFIER static T call(T const & x, T const & y, bool const & a)\n\t\t{\n\t\t\treturn a ? y : x;\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, template <class, precision> class vecType, bool isFloat = true, bool isSigned = true>\n\tstruct compute_sign\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x)\n\t\t{\n\t\t\treturn vecType<T, P>(glm::lessThan(vecType<T, P>(0), x)) - vecType<T, P>(glm::lessThan(x, vecType<T, P>(0)));\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, template <class, precision> class vecType>\n\tstruct compute_sign<T, P, vecType, false, false>\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x)\n\t\t{\n\t\t\treturn vecType<T, P>(glm::greaterThan(x , vecType<T, P>(0)));\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, template <class, precision> class vecType>\n\tstruct compute_sign<T, P, vecType, false, true>\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x)\n\t\t{\n\t\t\tT const Shift(static_cast<T>(sizeof(T) * 8 - 1));\n\t\t\tvecType<T, P> const y(vecType<typename make_unsigned<T>::type, P>(-x) >> typename make_unsigned<T>::type(Shift));\n\n\t\t\treturn (x >> Shift) | y;\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, template <class, precision> class vecType, typename genType, bool isFloat = true>\n\tstruct compute_mod\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & a, genType const & b)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.\");\n\t\t\treturn a - b * floor(a / b);\n\t\t}\n\t};\n}//namespace detail\n\n\t// abs\n\ttemplate <>\n\tGLM_FUNC_QUALIFIER int32 abs(int32 x)\n\t{\n\t\tint32 const y = x >> 31;\n\t\treturn (x ^ y) - y;\n\t}\n\n\ttemplate <typename genFIType>\n\tGLM_FUNC_QUALIFIER genFIType abs(genFIType x)\n\t{\n\t\treturn detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> abs(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(abs, x);\n\t}\n\n\t// sign\n\t// fast and works for any type\n\ttemplate <typename genFIType> \n\tGLM_FUNC_QUALIFIER genFIType sign(genFIType x)\n\t{\n\t\tGLM_STATIC_ASSERT(\n\t\t\tstd::numeric_limits<genFIType>::is_iec559 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer),\n\t\t\t\"'sign' only accept signed inputs\");\n\t\t\n\t\treturn detail::compute_sign<genFIType, defaultp, tvec1, std::numeric_limits<genFIType>::is_iec559>::call(tvec1<genFIType>(x)).x;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> sign(vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(\n\t\t\tstd::numeric_limits<T>::is_iec559 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer),\n\t\t\t\"'sign' only accept signed inputs\");\n\n\t\treturn detail::compute_sign<T, P, vecType, std::numeric_limits<T>::is_iec559>::call(x);\n\t}\n\n\t// floor\n\tusing ::std::floor;\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> floor(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(floor, x);\n\t}\n\n\t// trunc\n#\tif GLM_HAS_CXX11_STL\n\t\tusing ::std::trunc;\n#\telse\n\t\ttemplate <typename genType>\n\t\tGLM_FUNC_QUALIFIER genType trunc(genType x)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'trunc' only accept floating-point inputs\");\n\n\t\t\treturn x < static_cast<genType>(0) ? -floor(-x) : floor(x);\n\t\t}\n#\tendif\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> trunc(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(trunc, x);\n\t}\n\n\t// round\n#\tif GLM_HAS_CXX11_STL\n\t\tusing ::std::round;\n#\telse\n\t\ttemplate <typename genType>\n\t\tGLM_FUNC_QUALIFIER genType round(genType x)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'round' only accept floating-point inputs\");\n\n\t\t\treturn x < static_cast<genType>(0) ? static_cast<genType>(int(x - static_cast<genType>(0.5))) : static_cast<genType>(int(x + static_cast<genType>(0.5)));\n\t\t}\n#\tendif\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> round(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(round, x);\n\t}\n\n/*\n\t// roundEven\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType roundEven(genType const& x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'roundEven' only accept floating-point inputs\");\n\n\t\treturn genType(int(x + genType(int(x) % 2)));\n\t}\n*/\n\n\t// roundEven\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType roundEven(genType x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'roundEven' only accept floating-point inputs\");\n\t\t\n\t\tint Integer = static_cast<int>(x);\n\t\tgenType IntegerPart = static_cast<genType>(Integer);\n\t\tgenType FractionalPart = fract(x);\n\n\t\tif(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))\n\t\t{\n\t\t\treturn round(x);\n\t\t}\n\t\telse if((Integer % 2) == 0)\n\t\t{\n\t\t\treturn IntegerPart;\n\t\t}\n\t\telse if(x <= static_cast<genType>(0)) // Work around... \n\t\t{\n\t\t\treturn IntegerPart - static_cast<genType>(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn IntegerPart + static_cast<genType>(1);\n\t\t}\n\t\t//else // Bug on MinGW 4.5.2\n\t\t//{\n\t\t//\treturn mix(IntegerPart + genType(-1), IntegerPart + genType(1), x <= genType(0));\n\t\t//}\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> roundEven(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(roundEven, x);\n\t}\n\n\t// ceil\n\tusing ::std::ceil;\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> ceil(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(ceil, x);\n\t}\n\n\t// fract\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType fract(genType x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'fract' only accept floating-point inputs\");\n\n\t\treturn fract(tvec1<genType>(x)).x;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> fract(vecType<T, P> const & x)\n\t{\n\t\treturn x - floor(x);\n\t}\n\n\t// mod\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType mod(genType x, genType y)\n\t{\n\t\treturn mod(tvec1<genType>(x), y).x;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> mod(vecType<T, P> const & x, T y)\n\t{\n\t\treturn detail::compute_mod<T, P, vecType, T, std::numeric_limits<T>::is_iec559>::call(x, y);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y)\n\t{\n\t\treturn detail::compute_mod<T, P, vecType, vecType<T, P>, std::numeric_limits<T>::is_iec559>::call(x, y);\n\t}\n\n\t// modf\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType modf(genType x, genType & i)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'modf' only accept floating-point inputs\");\n\n\t\treturn std::modf(x, &i);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec1<T, P> modf(tvec1<T, P> const & x, tvec1<T, P> & i)\n\t{\n\t\treturn tvec1<T, P>(\n\t\t\tmodf(x.x, i.x));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> modf(tvec2<T, P> const & x, tvec2<T, P> & i)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tmodf(x.x, i.x),\n\t\t\tmodf(x.y, i.y));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> modf(tvec3<T, P> const & x, tvec3<T, P> & i)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tmodf(x.x, i.x),\n\t\t\tmodf(x.y, i.y),\n\t\t\tmodf(x.z, i.z));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> modf(tvec4<T, P> const & x, tvec4<T, P> & i)\n\t{\n\t\treturn tvec4<T, P>(\n\t\t\tmodf(x.x, i.x),\n\t\t\tmodf(x.y, i.y),\n\t\t\tmodf(x.z, i.z),\n\t\t\tmodf(x.w, i.w));\n\t}\n\n\t//// Only valid if (INT_MIN <= x-y <= INT_MAX)\n\t//// min(x,y)\n\t//r = y + ((x - y) & ((x - y) >> (sizeof(int) *\n\t//CHAR_BIT - 1)));\n\t//// max(x,y)\n\t//r = x - ((x - y) & ((x - y) >> (sizeof(int) *\n\t//CHAR_BIT - 1)));\n\n\t// min\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType min(genType x, genType y)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, \"'min' only accept floating-point or integer inputs\");\n\n\t\treturn x < y ? x : y;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> min(vecType<T, P> const & a, T b)\n\t{\n\t\treturn detail::functor2_vec_sca<T, P, vecType>::call(min, a, b);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> min(vecType<T, P> const & a, vecType<T, P> const & b)\n\t{\n\t\treturn detail::functor2<T, P, vecType>::call(min, a, b);\n\t}\n\n\t// max\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType max(genType x, genType y)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, \"'max' only accept floating-point or integer inputs\");\n\n\t\treturn x > y ? x : y;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> max(vecType<T, P> const & a, T b)\n\t{\n\t\treturn detail::functor2_vec_sca<T, P, vecType>::call(max, a, b);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> max(vecType<T, P> const & a, vecType<T, P> const & b)\n\t{\n\t\treturn detail::functor2<T, P, vecType>::call(max, a, b);\n\t}\n\n\t// clamp\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType clamp(genType x, genType minVal, genType maxVal)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, \"'clamp' only accept floating-point or integer inputs\");\n\t\t\n\t\treturn min(max(x, minVal), maxVal);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, \"'clamp' only accept floating-point or integer inputs\");\n\n\t\treturn min(max(x, minVal), maxVal);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, \"'clamp' only accept floating-point or integer inputs\");\n\n\t\treturn min(max(x, minVal), maxVal);\n\t}\n\n\ttemplate <typename genTypeT, typename genTypeU>\n\tGLM_FUNC_QUALIFIER genTypeT mix(genTypeT x, genTypeT y, genTypeU a)\n\t{\n\t\treturn detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);\n\t}\n\n\ttemplate <typename T, typename U, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a)\n\t{\n\t\treturn detail::compute_mix_scalar<T, U, P, vecType>::call(x, y, a);\n\t}\n\t\n\ttemplate <typename T, typename U, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)\n\t{\n\t\treturn detail::compute_mix_vector<T, U, P, vecType>::call(x, y, a);\n\t}\n\n\t// step\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType step(genType edge, genType x)\n\t{\n\t\treturn mix(static_cast<genType>(1), static_cast<genType>(0), glm::lessThan(x, edge));\n\t}\n\n\ttemplate <template <typename, precision> class vecType, typename T, precision P>\n\tGLM_FUNC_QUALIFIER vecType<T, P> step(T edge, vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'step' only accept floating-point inputs\");\n\n\t\treturn mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, vecType<T, P>(edge)));\n\t}\n\n\ttemplate <template <typename, precision> class vecType, typename T, precision P>\n\tGLM_FUNC_QUALIFIER vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x)\n\t{\n\t\treturn mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, edge));\n\t}\n\n\t// smoothstep\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType smoothstep(genType edge0, genType edge1, genType x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'smoothstep' only accept floating-point inputs\");\n\n\t\tgenType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));\n\t\treturn tmp * tmp * (genType(3) - genType(2) * tmp);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'smoothstep' only accept floating-point inputs\");\n\n\t\tvecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));\n\t\treturn tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'smoothstep' only accept floating-point inputs\");\n\n\t\tvecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));\n\t\treturn tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);\n\t}\n\n#\tif GLM_HAS_CXX11_STL\n\t\tusing std::isnan;\n#\telse\n\t\ttemplate <typename genType> \n\t\tGLM_FUNC_QUALIFIER bool isnan(genType x)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'isnan' only accept floating-point inputs\");\n\n#\t\t\tif GLM_HAS_CXX11_STL\n\t\t\t\treturn std::isnan(x);\n#\t\t\telif GLM_COMPILER & GLM_COMPILER_VC\n\t\t\t\treturn _isnan(x) != 0;\n#\t\t\telif GLM_COMPILER & GLM_COMPILER_INTEL\n#\t\t\t\tif GLM_PLATFORM & GLM_PLATFORM_WINDOWS\n\t\t\t\t\treturn _isnan(x) != 0;\n#\t\t\t\telse\n\t\t\t\t\treturn ::isnan(x) != 0;\n#\t\t\t\tendif\n#\t\t\telif (GLM_COMPILER & (GLM_COMPILER_GCC | (GLM_COMPILER_APPLE_CLANG | GLM_COMPILER_LLVM))) && (GLM_PLATFORM & GLM_PLATFORM_ANDROID) && __cplusplus < 201103L\n\t\t\t\treturn _isnan(x) != 0;\n#\t\t\telif GLM_COMPILER & GLM_COMPILER_CUDA\n\t\t\t\treturn isnan(x) != 0;\n#\t\t\telse\n\t\t\t\treturn std::isnan(x);\n#\t\t\tendif\n\t\t}\n#\tendif\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<bool, P> isnan(vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'isnan' only accept floating-point inputs\");\n\n\t\treturn detail::functor1<bool, T, P, vecType>::call(isnan, x);\n\t}\n\n#\tif GLM_HAS_CXX11_STL\n\t\tusing std::isinf;\n#\telse\n\t\ttemplate <typename genType> \n\t\tGLM_FUNC_QUALIFIER bool isinf(genType x)\n\t\t{\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'isinf' only accept floating-point inputs\");\n\n#\t\t\tif GLM_HAS_CXX11_STL\n\t\t\t\treturn std::isinf(x);\n#\t\t\telif GLM_COMPILER & (GLM_COMPILER_INTEL | GLM_COMPILER_VC)\n#\t\t\t\tif(GLM_PLATFORM & GLM_PLATFORM_WINDOWS)\n\t\t\t\t\treturn _fpclass(x) == _FPCLASS_NINF || _fpclass(x) == _FPCLASS_PINF;\n#\t\t\t\telse\n\t\t\t\t\treturn ::isinf(x);\n#\t\t\t\tendif\n#\t\t\telif GLM_COMPILER & (GLM_COMPILER_GCC | (GLM_COMPILER_APPLE_CLANG | GLM_COMPILER_LLVM))\n#\t\t\t\tif(GLM_PLATFORM & GLM_PLATFORM_ANDROID && __cplusplus < 201103L)\n\t\t\t\t\treturn _isinf(x) != 0;\n#\t\t\t\telse\n\t\t\t\t\treturn std::isinf(x);\n#\t\t\t\tendif\n#\t\t\telif GLM_COMPILER & GLM_COMPILER_CUDA\n\t\t\t\t// http://developer.download.nvidia.com/compute/cuda/4_2/rel/toolkit/docs/online/group__CUDA__MATH__DOUBLE_g13431dd2b40b51f9139cbb7f50c18fab.html#g13431dd2b40b51f9139cbb7f50c18fab\n\t\t\t\treturn isinf(double(x)) != 0;\n#\t\t\telse\n\t\t\t\treturn std::isinf(x);\n#\t\t\tendif\n\t}\n#\tendif\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<bool, P> isinf(vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'isnan' only accept floating-point inputs\");\n\n\t\treturn detail::functor1<bool, T, P, vecType>::call(isinf, x);\n\t}\n\n\tGLM_FUNC_QUALIFIER int floatBitsToInt(float const & v)\n\t{\n\t\treturn reinterpret_cast<int&>(const_cast<float&>(v));\n\t}\n\n\ttemplate <template <typename, precision> class vecType, precision P>\n\tGLM_FUNC_QUALIFIER vecType<int, P> floatBitsToInt(vecType<float, P> const & v)\n\t{\n\t\treturn reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));\n\t}\n\n\tGLM_FUNC_QUALIFIER uint floatBitsToUint(float const & v)\n\t{\n\t\treturn reinterpret_cast<uint&>(const_cast<float&>(v));\n\t}\n\n\ttemplate <template <typename, precision> class vecType, precision P>\n\tGLM_FUNC_QUALIFIER vecType<uint, P> floatBitsToUint(vecType<float, P> const & v)\n\t{\n\t\treturn reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));\n\t}\n\n\tGLM_FUNC_QUALIFIER float intBitsToFloat(int const & v)\n\t{\n\t\treturn reinterpret_cast<float&>(const_cast<int&>(v));\n\t}\n\n\ttemplate <template <typename, precision> class vecType, precision P>\n\tGLM_FUNC_QUALIFIER vecType<float, P> intBitsToFloat(vecType<int, P> const & v)\n\t{\n\t\treturn reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));\n\t}\n\n\tGLM_FUNC_QUALIFIER float uintBitsToFloat(uint const & v)\n\t{\n\t\treturn reinterpret_cast<float&>(const_cast<uint&>(v));\n\t}\n\n\ttemplate <template <typename, precision> class vecType, precision P>\n\tGLM_FUNC_QUALIFIER vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v)\n\t{\n\t\treturn reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));\n\t}\n\t\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType fma(genType const & a, genType const & b, genType const & c)\n\t{\n\t\treturn a * b + c;\n\t}\n\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType frexp(genType x, int & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'frexp' only accept floating-point inputs\");\n\n\t\treturn std::frexp(x, &exp);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec1<T, P> frexp(tvec1<T, P> const & x, tvec1<int, P> & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'frexp' only accept floating-point inputs\");\n\n\t\treturn tvec1<T, P>(std::frexp(x.x, &exp.x));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> frexp(tvec2<T, P> const & x, tvec2<int, P> & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'frexp' only accept floating-point inputs\");\n\n\t\treturn tvec2<T, P>(\n\t\t\tfrexp(x.x, exp.x),\n\t\t\tfrexp(x.y, exp.y));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> frexp(tvec3<T, P> const & x, tvec3<int, P> & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'frexp' only accept floating-point inputs\");\n\n\t\treturn tvec3<T, P>(\n\t\t\tfrexp(x.x, exp.x),\n\t\t\tfrexp(x.y, exp.y),\n\t\t\tfrexp(x.z, exp.z));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> frexp(tvec4<T, P> const & x, tvec4<int, P> & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'frexp' only accept floating-point inputs\");\n\n\t\treturn tvec4<T, P>(\n\t\t\tfrexp(x.x, exp.x),\n\t\t\tfrexp(x.y, exp.y),\n\t\t\tfrexp(x.z, exp.z),\n\t\t\tfrexp(x.w, exp.w));\n\t}\n\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType ldexp(genType const & x, int const & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'ldexp' only accept floating-point inputs\");\n\n\t\treturn std::ldexp(x, exp);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec1<T, P> ldexp(tvec1<T, P> const & x, tvec1<int, P> const & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'ldexp' only accept floating-point inputs\");\n\n\t\treturn tvec1<T, P>(\n\t\t\tldexp(x.x, exp.x));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> ldexp(tvec2<T, P> const & x, tvec2<int, P> const & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'ldexp' only accept floating-point inputs\");\n\n\t\treturn tvec2<T, P>(\n\t\t\tldexp(x.x, exp.x),\n\t\t\tldexp(x.y, exp.y));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> ldexp(tvec3<T, P> const & x, tvec3<int, P> const & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'ldexp' only accept floating-point inputs\");\n\n\t\treturn tvec3<T, P>(\n\t\t\tldexp(x.x, exp.x),\n\t\t\tldexp(x.y, exp.y),\n\t\t\tldexp(x.z, exp.z));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> ldexp(tvec4<T, P> const & x, tvec4<int, P> const & exp)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'ldexp' only accept floating-point inputs\");\n\n\t\treturn tvec4<T, P>(\n\t\t\tldexp(x.x, exp.x),\n\t\t\tldexp(x.y, exp.y),\n\t\t\tldexp(x.z, exp.z),\n\t\t\tldexp(x.w, exp.w));\n\t}\n}//namespace glm\n","// -*- C++ -*-\n//===---------------------------- cmath -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CMATH\n#define _LIBCPP_CMATH\n\n/*\n    cmath synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nnamespace std\n{\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <math.h>\n#include <type_traits>\n\n#ifdef _LIBCPP_MSVCRT\n#include \"support/win32/math_win32.h\"\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nusing ::signbit;\nusing ::fpclassify;\nusing ::isfinite;\nusing ::isinf;\nusing ::isnan;\nusing ::isnormal;\nusing ::isgreater;\nusing ::isgreaterequal;\nusing ::isless;\nusing ::islessequal;\nusing ::islessgreater;\nusing ::isunordered;\nusing ::isunordered;\n\nusing ::float_t;\nusing ::double_t;\n\n// abs\n\n#if !defined(_AIX)\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !defined(_AIX)\n\n#ifndef __sun__\n\n// acos\n\nusing ::acos;\nusing ::acosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\nusing ::asin;\nusing ::asinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\nusing ::atan;\nusing ::atanf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\nusing ::atan2;\nusing ::atan2f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\nusing ::ceil;\nusing ::ceilf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\nusing ::cos;\nusing ::cosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\nusing ::cosh;\nusing ::coshf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n#endif // __sun__\n// exp\n\nusing ::exp;\nusing ::expf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\nusing ::fabs;\nusing ::fabsf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\nusing ::floor;\nusing ::floorf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#endif //__sun__\nusing ::fmod;\nusing ::fmodf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n\n// frexp\n\nusing ::frexp;\nusing ::frexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\nusing ::ldexp;\nusing ::ldexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#endif // __sun__\nusing ::log;\nusing ::logf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n\n// log10\n\nusing ::log10;\nusing ::log10f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\nusing ::modf;\nusing ::modff;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#endif // __sun__ \nusing ::pow;\nusing ::powf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\nusing ::sin;\nusing ::sinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\nusing ::sinh;\nusing ::sinhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#endif // __sun__\nusing ::sqrt;\nusing ::sqrtf;\n\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(__sun__) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\nusing ::tan;\nusing ::tanf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\nusing ::tanh;\nusing ::tanhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::acosh;\nusing ::acoshf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::asinh;\nusing ::asinhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::atanh;\nusing ::atanhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\nusing ::cbrt;\nusing ::cbrtf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\nusing ::copysign;\nusing ::copysignf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       copysign(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return copysignf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double copysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return copysignl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\nusing ::erf;\nusing ::erff;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\nusing ::erfc;\nusing ::erfcf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\nusing ::exp2;\nusing ::exp2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\nusing ::expm1;\nusing ::expm1f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\nusing ::fdim;\nusing ::fdimf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\nusing ::fmaf;\nusing ::fma;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value &&\n    is_arithmetic<_A3>::value,\n    typename __promote<_A1, _A2, _A3>::type\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value &&\n                      is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\nusing ::fmax;\nusing ::fmaxf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\nusing ::fmin;\nusing ::fminf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\nusing ::hypot;\nusing ::hypotf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\nusing ::ilogb;\nusing ::ilogbf;\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\nusing ::lgamma;\nusing ::lgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n\n// llrint\n\nusing ::llrint;\nusing ::llrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\nusing ::llround;\nusing ::llroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\nusing ::log1p;\nusing ::log1pf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\nusing ::log2;\nusing ::log2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\nusing ::logb;\nusing ::logbf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\nusing ::lrint;\nusing ::lrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\nusing ::lround;\nusing ::lroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n#endif // _LIBCPP_MSVCRT\n#endif // __sun__\n\n// nan\n\n#ifndef _LIBCPP_MSVCRT\nusing ::nan;\nusing ::nanf;\n#endif // _LIBCPP_MSVCRT\n\n#ifndef __sun__\n#ifndef _LIBCPP_MSVCRT\n\n// nearbyint\n\nusing ::nearbyint;\nusing ::nearbyintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\nusing ::nextafter;\nusing ::nextafterf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\nusing ::nexttoward;\nusing ::nexttowardf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\nusing ::remainder;\nusing ::remainderf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\nusing ::remquo;\nusing ::remquof;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\nusing ::rint;\nusing ::rintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\nusing ::round;\nusing ::roundf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\nusing ::scalbln;\nusing ::scalblnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\nusing ::scalbn;\nusing ::scalbnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\nusing ::tgamma;\nusing ::tgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\nusing ::trunc;\nusing ::truncf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\nusing ::acosl;\nusing ::asinl;\nusing ::atanl;\nusing ::atan2l;\nusing ::ceill;\nusing ::cosl;\nusing ::coshl;\nusing ::expl;\nusing ::fabsl;\nusing ::floorl;\nusing ::fmodl;\nusing ::frexpl;\nusing ::ldexpl;\nusing ::logl;\nusing ::log10l;\nusing ::modfl;\nusing ::powl;\nusing ::sinl;\nusing ::sinhl;\nusing ::sqrtl;\nusing ::tanl;\n#ifndef _LIBCPP_MSVCRT\nusing ::tanhl;\nusing ::acoshl;\nusing ::asinhl;\nusing ::atanhl;\nusing ::cbrtl;\n#endif  // !_LIBCPP_MSVCRT\nusing ::copysignl;\n#ifndef _LIBCPP_MSVCRT\nusing ::erfl;\nusing ::erfcl;\nusing ::exp2l;\nusing ::expm1l;\nusing ::fdiml;\nusing ::fmal;\nusing ::fmaxl;\nusing ::fminl;\nusing ::hypotl;\nusing ::ilogbl;\nusing ::lgammal;\nusing ::llrintl;\nusing ::llroundl;\nusing ::log1pl;\nusing ::log2l;\nusing ::logbl;\nusing ::lrintl;\nusing ::lroundl;\nusing ::nanl;\nusing ::nearbyintl;\nusing ::nextafterl;\nusing ::nexttowardl;\nusing ::remainderl;\nusing ::remquol;\nusing ::rintl;\nusing ::roundl;\nusing ::scalblnl;\nusing ::scalbnl;\nusing ::tgammal;\nusing ::truncl;\n#endif // !_LIBCPP_MSVCRT\n\n#else \nusing ::lgamma;\nusing ::lgammaf;\n#endif // __sun__\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CMATH\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/func_geometric.inl\n/// @date 2008-08-03 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#include \"func_exponential.hpp\"\n#include \"func_common.hpp\"\n#include \"type_vec2.hpp\"\n#include \"type_vec4.hpp\"\n#include \"type_float.hpp\"\n\nnamespace glm{\nnamespace detail\n{\n\ttemplate <template <class, precision> class vecType, typename T, precision P>\n\tstruct compute_dot{};\n\n\ttemplate <typename T, precision P>\n\tstruct compute_dot<tvec1, T, P>\n\t{\n\t\tGLM_FUNC_QUALIFIER static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)\n\t\t{\n\t\t\treturn a.x * b.x;\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct compute_dot<tvec2, T, P>\n\t{\n\t\tGLM_FUNC_QUALIFIER static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)\n\t\t{\n\t\t\ttvec2<T, P> tmp(x * y);\n\t\t\treturn tmp.x + tmp.y;\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct compute_dot<tvec3, T, P>\n\t{\n\t\tGLM_FUNC_QUALIFIER static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)\n\t\t{\n\t\t\ttvec3<T, P> tmp(x * y);\n\t\t\treturn tmp.x + tmp.y + tmp.z;\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct compute_dot<tvec4, T, P>\n\t{\n\t\tGLM_FUNC_QUALIFIER static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)\n\t\t{\n\t\t\ttvec4<T, P> tmp(x * y);\n\t\t\treturn (tmp.x + tmp.y) + (tmp.z + tmp.w);\n\t\t}\n\t};\n}//namespace detail\n\n\t// length\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType length(genType x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'length' only accept floating-point inputs\");\n\n\t\treturn abs(x);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER T length(vecType<T, P> const & v)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'length' only accept floating-point inputs\");\n\n\t\treturn sqrt(dot(v, v));\n\t}\n\n\t// distance\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType distance(genType const & p0, genType const & p1)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'distance' only accept floating-point inputs\");\n\n\t\treturn length(p1 - p0);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)\n\t{\n\t\treturn length(p1 - p0);\n\t}\n\n\t// dot\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER T dot(T x, T y)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'dot' only accept floating-point inputs\");\n\t\treturn x * y;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER T dot(vecType<T, P> const & x, vecType<T, P> const & y)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'dot' only accept floating-point inputs\");\n\t\treturn detail::compute_dot<vecType, T, P>::call(x, y);\n\t}\n\n\t// cross\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'cross' only accept floating-point inputs\");\n\n\t\treturn tvec3<T, P>(\n\t\t\tx.y * y.z - y.y * x.z,\n\t\t\tx.z * y.x - y.z * x.x,\n\t\t\tx.x * y.y - y.x * x.y);\n\t}\n\n\t// normalize\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType normalize(genType const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'normalize' only accept floating-point inputs\");\n\n\t\treturn x < genType(0) ? genType(-1) : genType(1);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> normalize(vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'normalize' only accept floating-point inputs\");\n\n\t\treturn x * inversesqrt(dot(x, x));\n\t}\n\n\t// faceforward\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType faceforward(genType const & N, genType const & I, genType const & Nref)\n\t{\n\t\treturn dot(Nref, I) < static_cast<genType>(0) ? N : -N;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> faceforward(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)\n\t{\n\t\treturn dot(Nref, I) < static_cast<T>(0) ? N : -N;\n\t}\n\n\t// reflect\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType reflect(genType const & I, genType const & N)\n\t{\n\t\treturn I - N * dot(N, I) * static_cast<genType>(2);\n\t}\n\n\t// refract\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType refract(genType const & I, genType const & N, genType const & eta)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'refract' only accept floating-point inputs\");\n\n\t\tgenType const dotValue(dot(N, I));\n\t\tgenType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));\n\t\treturn (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'refract' only accept floating-point inputs\");\n\n\t\tT const dotValue(dot(N, I));\n\t\tT const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));\n\t\treturn (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));\n\t}\n}//namespace glm\n","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/detail/func_exponential.inl\n/// @date 2008-08-03 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#include \"func_vector_relational.hpp\"\n#include \"_vectorize.hpp\"\n#include <limits>\n#include <cmath>\n#include <cassert>\n\nnamespace glm{\nnamespace detail\n{\n#\tif GLM_HAS_CXX11_STL\n\t\tusing std::log2;\n#\telse\n\t\ttemplate <typename genType>\n\t\tgenType log2(genType Value)\n\t\t{\n\t\t\treturn std::log(Value) * static_cast<genType>(1.4426950408889634073599246810019);\n\t\t}\n#\tendif\n\n\ttemplate <typename T, precision P, template <class, precision> class vecType, bool isFloat = true>\n\tstruct compute_log2\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & vec)\n\t\t{\n\t\t\treturn detail::functor1<T, T, P, vecType>::call(log2, vec);\n\t\t}\n\t};\n\n\ttemplate <template <class, precision> class vecType, typename T, precision P>\n\tstruct compute_inversesqrt\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x)\n\t\t{\n\t\t\treturn static_cast<T>(1) / sqrt(x);\n\t\t}\n\t};\n\t\t\n\ttemplate <template <class, precision> class vecType>\n\tstruct compute_inversesqrt<vecType, float, lowp>\n\t{\n\t\tGLM_FUNC_QUALIFIER static vecType<float, lowp> call(vecType<float, lowp> const & x)\n\t\t{\n\t\t\tvecType<float, lowp> tmp(x);\n\t\t\tvecType<float, lowp> xhalf(tmp * 0.5f);\n\t\t\tvecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));\n\t\t\tvecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));\n\t\t\tvecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);\n\t\t\ttmp = *ptmp;\n\t\t\ttmp = tmp * (1.5f - xhalf * tmp * tmp);\n\t\t\treturn tmp;\n\t\t}\n\t};\n}//namespace detail\n\n\t// pow\n\tusing std::pow;\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent)\n\t{\n\t\treturn detail::functor2<T, P, vecType>::call(pow, base, exponent);\n\t}\n\n\t// exp\n\tusing std::exp;\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> exp(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(exp, x);\n\t}\n\n\t// log\n\tusing std::log;\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> log(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(log, x);\n\t}\n\n\t//exp2, ln2 = 0.69314718055994530941723212145818f\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType exp2(genType x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'exp2' only accept floating-point inputs\");\n\n\t\treturn std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> exp2(vecType<T, P> const & x)\n\t{\n\t\treturn detail::functor1<T, T, P, vecType>::call(exp2, x);\n\t}\n\n\t// log2, ln2 = 0.69314718055994530941723212145818f\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType log2(genType x)\n\t{\n\t\treturn log2(tvec1<genType>(x)).x;\n\t}\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> log2(vecType<T, P> const & x)\n\t{\n\t\treturn detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559>::call(x);\n\t}\n\n\t// sqrt\n\tusing std::sqrt;\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> sqrt(vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'sqrt' only accept floating-point inputs\");\n\t\treturn detail::functor1<T, T, P, vecType>::call(sqrt, x);\n\t}\n\n\t// inversesqrt\n\ttemplate <typename genType>\n\tGLM_FUNC_QUALIFIER genType inversesqrt(genType x)\n\t{\n\t\treturn static_cast<genType>(1) / sqrt(x);\n\t}\n\t\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\n\tGLM_FUNC_QUALIFIER vecType<T, P> inversesqrt(vecType<T, P> const & x)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'inversesqrt' only accept floating-point inputs\");\n\t\treturn detail::compute_inversesqrt<vecType, T, P>::call(x);\n\t}\n}//namespace glm\n","//\n// Created by Michał Łaszczewski on 18/08/16.\n//\n\n#ifndef FASTANIM_LAYERCOMPOSITION_H\n#define FASTANIM_LAYERCOMPOSITION_H\n\n#include <fastgfx.h>\n#include <memory>\n\nnamespace fanim {\n\n  class LayerComposition : public Composition{\n  public:\n    std::shared_ptr<fgfx::Layer> layer;\n\n    GLenum source_blending;\n    GLenum destination_blending;\n\n    LayerComposition(std::shared_ptr<fgfx::Layer> layerp, GLenum srcp, GLenum destp)\n        : layer(layerp), source_blending(srcp), destination_blending(destp) {}\n    LayerComposition(std::shared_ptr<fgfx::Layer> layerp)\n        : layer(layerp), source_blending(GL_SRC_ALPHA), destination_blending(GL_ONE_MINUS_SRC_ALPHA) {}\n\n    virtual ~LayerComposition() {}\n    virtual void reset() {\n      Composition::reset();\n      layer->reset();\n    }\n    virtual void upload() {\n      Composition::upload();\n      layer->upload();\n    };\n    virtual void render(const glm::mat4& cameraMatrix) {\n      glEnable(GL_BLEND);\n      glBlendFunc(source_blending, destination_blending);\n      layer->render(cameraMatrix);\n      Composition::render(cameraMatrix);\n    };\n  };\n\n}\n\n\n#endif //FASTANIM_LAYERCOMPOSITION_H\n","//\n// Created by Michał Łaszczewski on 18/08/16.\n//\n\n#ifndef FASTANIM_COMPOSITION_H\n#define FASTANIM_COMPOSITION_H\n\nnamespace fanim {\n\n  class Composition {\n  public:\n    std::vector<std::shared_ptr<Composition>> children;\n\n    Composition() {}\n    virtual ~Composition() {}\n    virtual void reset() {\n      for(auto child : children) {\n        child->reset();\n      }\n    }\n    virtual void upload() {\n      for(auto child : children) {\n        child->upload();\n      }\n    }\n    virtual void render(const glm::mat4& cameraMatrix) {\n      for(auto child : children) {\n        child->render(cameraMatrix);\n      }\n    }\n  };\n\n}\n\n#endif //FASTANIM_COMPOSITION_H\n","//\n// Created by Michał Łaszczewski on 17/08/16.\n//\n\n#ifndef FASTANIM_VIEW_H\n#define FASTANIM_VIEW_H\n\n#include <fastgfx.h>\n#include <memory>\n#include \"../value/Value.h\"\n#include \"../camera/Camera.h\"\n#include \"../node/Node.h\"\n#include \"../Animated.h\"\n\nnamespace fanim {\n\n  class View {\n  public:\n    std::shared_ptr<Value<glm::vec4>> backgroundColor;\n    std::shared_ptr<Camera> camera;\n    std::shared_ptr<Node> scene;\n\n    Animator animator;\n\n    std::shared_ptr<Composition> composition;\n\n    View(\n        std::shared_ptr<Node> scenep,\n        std::shared_ptr<Composition> compositionp,\n        std::shared_ptr<Camera> camerap)\n        : camera(camerap), scene(scenep), composition(compositionp) {\n    }\n    ~View() {\n    }\n\n    void advance(float delta) {\n      animator.advance(delta);\n    }\n    void upload() {\n      camera->computeMatrix(fgfx::engine->width, fgfx::engine->height);\n      composition->reset();\n      scene->computeMatrix(glm::mat4(),*camera);\n      scene->render();\n      composition->upload();\n    }\n    void render() {\n      if(backgroundColor) {\n        glm::vec4 color = backgroundColor->get();\n        glClearColor(color.r, color.g, color.b, color.a);\n      } else {\n        glClearColor(0, 0, 0, 0);\n      }\n      glClear(GL_COLOR_BUFFER_BIT);\n\n      composition->render(camera->camera);\n    }\n\n  };\n\n\n}\n\n#endif //FASTANIM_VIEW_H\n","//\n// Created by Michał Łaszczewski on 27/07/16.\n//\n\n#ifndef FASTANIM_ANIMATOR_H\n#define FASTANIM_ANIMATOR_H\n\n#import \"FastSet.h\"\n#import \"Animated.h\"\n\nnamespace fanim {\n\n  class Animator : public FastSet<Animated> {\n  public:\n    void advance(float by) {\n      for(auto animated : *this) {\n        animated->advance(by);\n      }\n    }\n  };\n\n}\n\n#endif //FASTANIM_ANIMATOR_H\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","// (C) Copyright David Abrahams 2002.\n// (C) Copyright Jeremy Siek    2002.\n// (C) Copyright Thomas Witt    2002.\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n#ifndef BOOST_ITERATOR_FACADE_23022003THW_HPP\n#define BOOST_ITERATOR_FACADE_23022003THW_HPP\n\n#include <boost/config.hpp>\n#include <boost/iterator.hpp>\n#include <boost/iterator/interoperable.hpp>\n#include <boost/iterator/iterator_traits.hpp>\n#include <boost/iterator/iterator_categories.hpp>\n\n#include <boost/iterator/detail/facade_iterator_category.hpp>\n#include <boost/iterator/detail/enable_if.hpp>\n\n#include <boost/static_assert.hpp>\n#include <boost/utility/addressof.hpp>\n\n#include <boost/type_traits/is_same.hpp>\n#include <boost/type_traits/add_const.hpp>\n#include <boost/type_traits/add_pointer.hpp>\n#include <boost/type_traits/add_lvalue_reference.hpp>\n#include <boost/type_traits/remove_const.hpp>\n#include <boost/type_traits/remove_reference.hpp>\n#include <boost/type_traits/is_convertible.hpp>\n#include <boost/type_traits/is_pod.hpp>\n\n#include <boost/mpl/eval_if.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/or.hpp>\n#include <boost/mpl/and.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/mpl/always.hpp>\n#include <boost/mpl/apply.hpp>\n#include <boost/mpl/identity.hpp>\n\n#include <boost/iterator/detail/config_def.hpp> // this goes last\n\nnamespace boost {\nnamespace iterators {\n\n  // This forward declaration is required for the friend declaration\n  // in iterator_core_access\n  template <class I, class V, class TC, class R, class D> class iterator_facade;\n\n  namespace detail\n  {\n    // A binary metafunction class that always returns bool.  VC6\n    // ICEs on mpl::always<bool>, probably because of the default\n    // parameters.\n    struct always_bool2\n    {\n        template <class T, class U>\n        struct apply\n        {\n            typedef bool type;\n        };\n    };\n\n    // The type trait checks if the category or traversal is at least as advanced as the specified required traversal\n    template< typename CategoryOrTraversal, typename Required >\n    struct is_traversal_at_least :\n        public boost::is_convertible< typename iterator_category_to_traversal< CategoryOrTraversal >::type, Required >\n    {};\n\n    //\n    // enable if for use in operator implementation.\n    //\n    template <\n        class Facade1\n      , class Facade2\n      , class Return\n    >\n    struct enable_if_interoperable :\n        public boost::iterators::enable_if<\n            is_interoperable< Facade1, Facade2 >\n          , Return\n        >\n    {};\n\n    //\n    // enable if for use in implementation of operators specific for random access traversal.\n    //\n    template <\n        class Facade1\n      , class Facade2\n      , class Return\n    >\n    struct enable_if_interoperable_and_random_access_traversal :\n        public boost::iterators::enable_if<\n            mpl::and_<\n                is_interoperable< Facade1, Facade2 >\n              , is_traversal_at_least< typename iterator_category< Facade1 >::type, random_access_traversal_tag >\n              , is_traversal_at_least< typename iterator_category< Facade2 >::type, random_access_traversal_tag >\n            >\n          , Return\n        >\n    {};\n\n    //\n    // Generates associated types for an iterator_facade with the\n    // given parameters.\n    //\n    template <\n        class ValueParam\n      , class CategoryOrTraversal\n      , class Reference\n      , class Difference\n    >\n    struct iterator_facade_types\n    {\n        typedef typename facade_iterator_category<\n            CategoryOrTraversal, ValueParam, Reference\n        >::type iterator_category;\n\n        typedef typename remove_const<ValueParam>::type value_type;\n\n        // Not the real associated pointer type\n        typedef typename mpl::eval_if<\n            boost::iterators::detail::iterator_writability_disabled<ValueParam,Reference>\n          , add_pointer<const value_type>\n          , add_pointer<value_type>\n        >::type pointer;\n\n# if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)                          \\\n    && (BOOST_WORKAROUND(_STLPORT_VERSION, BOOST_TESTED_AT(0x452))              \\\n        || BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, BOOST_TESTED_AT(310)))     \\\n    || BOOST_WORKAROUND(BOOST_RWSTD_VER, BOOST_TESTED_AT(0x20101))              \\\n    || BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, <= 310)\n\n        // To interoperate with some broken library/compiler\n        // combinations, user-defined iterators must be derived from\n        // std::iterator.  It is possible to implement a standard\n        // library for broken compilers without this limitation.\n#  define BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE 1\n\n        typedef\n           iterator<iterator_category, value_type, Difference, pointer, Reference>\n        base;\n# endif\n    };\n\n    // iterators whose dereference operators reference the same value\n    // for all iterators into the same sequence (like many input\n    // iterators) need help with their postfix ++: the referenced\n    // value must be read and stored away before the increment occurs\n    // so that *a++ yields the originally referenced element and not\n    // the next one.\n    template <class Iterator>\n    class postfix_increment_proxy\n    {\n        typedef typename iterator_value<Iterator>::type value_type;\n     public:\n        explicit postfix_increment_proxy(Iterator const& x)\n          : stored_value(*x)\n        {}\n\n        // Returning a mutable reference allows nonsense like\n        // (*r++).mutate(), but it imposes fewer assumptions about the\n        // behavior of the value_type.  In particular, recall that\n        // (*r).mutate() is legal if operator* returns by value.\n        value_type&\n        operator*() const\n        {\n            return this->stored_value;\n        }\n     private:\n        mutable value_type stored_value;\n    };\n\n    //\n    // In general, we can't determine that such an iterator isn't\n    // writable -- we also need to store a copy of the old iterator so\n    // that it can be written into.\n    template <class Iterator>\n    class writable_postfix_increment_proxy\n    {\n        typedef typename iterator_value<Iterator>::type value_type;\n     public:\n        explicit writable_postfix_increment_proxy(Iterator const& x)\n          : stored_value(*x)\n          , stored_iterator(x)\n        {}\n\n        // Dereferencing must return a proxy so that both *r++ = o and\n        // value_type(*r++) can work.  In this case, *r is the same as\n        // *r++, and the conversion operator below is used to ensure\n        // readability.\n        writable_postfix_increment_proxy const&\n        operator*() const\n        {\n            return *this;\n        }\n\n        // Provides readability of *r++\n        operator value_type&() const\n        {\n            return stored_value;\n        }\n\n        // Provides writability of *r++\n        template <class T>\n        T const& operator=(T const& x) const\n        {\n            *this->stored_iterator = x;\n            return x;\n        }\n\n        // This overload just in case only non-const objects are writable\n        template <class T>\n        T& operator=(T& x) const\n        {\n            *this->stored_iterator = x;\n            return x;\n        }\n\n        // Provides X(r++)\n        operator Iterator const&() const\n        {\n            return stored_iterator;\n        }\n\n     private:\n        mutable value_type stored_value;\n        Iterator stored_iterator;\n    };\n\n# ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n\n    template <class Reference, class Value>\n    struct is_non_proxy_reference_impl\n    {\n        static Reference r;\n\n        template <class R>\n        static typename mpl::if_<\n            is_convertible<\n                R const volatile*\n              , Value const volatile*\n            >\n          , char[1]\n          , char[2]\n        >::type& helper(R const&);\n\n        BOOST_STATIC_CONSTANT(bool, value = sizeof(helper(r)) == 1);\n    };\n\n    template <class Reference, class Value>\n    struct is_non_proxy_reference\n      : mpl::bool_<\n            is_non_proxy_reference_impl<Reference, Value>::value\n        >\n    {};\n# else\n    template <class Reference, class Value>\n    struct is_non_proxy_reference\n      : is_convertible<\n            typename remove_reference<Reference>::type\n            const volatile*\n          , Value const volatile*\n        >\n    {};\n# endif\n\n    // A metafunction to choose the result type of postfix ++\n    //\n    // Because the C++98 input iterator requirements say that *r++ has\n    // type T (value_type), implementations of some standard\n    // algorithms like lexicographical_compare may use constructions\n    // like:\n    //\n    //          *r++ < *s++\n    //\n    // If *r++ returns a proxy (as required if r is writable but not\n    // multipass), this sort of expression will fail unless the proxy\n    // supports the operator<.  Since there are any number of such\n    // operations, we're not going to try to support them.  Therefore,\n    // even if r++ returns a proxy, *r++ will only return a proxy if\n    // *r also returns a proxy.\n    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>\n    struct postfix_increment_result\n      : mpl::eval_if<\n            mpl::and_<\n                // A proxy is only needed for readable iterators\n                is_convertible<\n                    Reference\n                    // Use add_lvalue_reference to form `reference to Value` due to\n                    // some (strict) C++03 compilers (e.g. `gcc -std=c++03`) reject\n                    // 'reference-to-reference' in the template which described in CWG\n                    // DR106.\n                    // http://www.open-std.org/Jtc1/sc22/wg21/docs/cwg_defects.html#106\n                  , typename add_lvalue_reference<Value const>::type\n                >\n\n                // No multipass iterator can have values that disappear\n                // before positions can be re-visited\n              , mpl::not_<\n                    is_convertible<\n                        typename iterator_category_to_traversal<CategoryOrTraversal>::type\n                      , forward_traversal_tag\n                    >\n                >\n            >\n          , mpl::if_<\n                is_non_proxy_reference<Reference,Value>\n              , postfix_increment_proxy<Iterator>\n              , writable_postfix_increment_proxy<Iterator>\n            >\n          , mpl::identity<Iterator>\n        >\n    {};\n\n    // operator->() needs special support for input iterators to strictly meet the\n    // standard's requirements. If *i is not a reference type, we must still\n    // produce an lvalue to which a pointer can be formed.  We do that by\n    // returning a proxy object containing an instance of the reference object.\n    template <class Reference, class Pointer>\n    struct operator_arrow_dispatch // proxy references\n    {\n        struct proxy\n        {\n            explicit proxy(Reference const & x) : m_ref(x) {}\n            Reference* operator->() { return boost::addressof(m_ref); }\n            // This function is needed for MWCW and BCC, which won't call\n            // operator-> again automatically per 13.3.1.2 para 8\n            operator Reference*() { return boost::addressof(m_ref); }\n            Reference m_ref;\n        };\n        typedef proxy result_type;\n        static result_type apply(Reference const & x)\n        {\n            return result_type(x);\n        }\n    };\n\n    template <class T, class Pointer>\n    struct operator_arrow_dispatch<T&, Pointer> // \"real\" references\n    {\n        typedef Pointer result_type;\n        static result_type apply(T& x)\n        {\n            return boost::addressof(x);\n        }\n    };\n\n    // A proxy return type for operator[], needed to deal with\n    // iterators that may invalidate referents upon destruction.\n    // Consider the temporary iterator in *(a + n)\n    template <class Iterator>\n    class operator_brackets_proxy\n    {\n        // Iterator is actually an iterator_facade, so we do not have to\n        // go through iterator_traits to access the traits.\n        typedef typename Iterator::reference  reference;\n        typedef typename Iterator::value_type value_type;\n\n     public:\n        operator_brackets_proxy(Iterator const& iter)\n          : m_iter(iter)\n        {}\n\n        operator reference() const\n        {\n            return *m_iter;\n        }\n\n        operator_brackets_proxy& operator=(value_type const& val)\n        {\n            *m_iter = val;\n            return *this;\n        }\n\n     private:\n        Iterator m_iter;\n    };\n\n    // A metafunction that determines whether operator[] must return a\n    // proxy, or whether it can simply return a copy of the value_type.\n    template <class ValueType, class Reference>\n    struct use_operator_brackets_proxy\n      : mpl::not_<\n            mpl::and_<\n                // Really we want an is_copy_constructible trait here,\n                // but is_POD will have to suffice in the meantime.\n                boost::is_POD<ValueType>\n              , iterator_writability_disabled<ValueType,Reference>\n            >\n        >\n    {};\n\n    template <class Iterator, class Value, class Reference>\n    struct operator_brackets_result\n    {\n        typedef typename mpl::if_<\n            use_operator_brackets_proxy<Value,Reference>\n          , operator_brackets_proxy<Iterator>\n          , Value\n        >::type type;\n    };\n\n    template <class Iterator>\n    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)\n    {\n        return operator_brackets_proxy<Iterator>(iter);\n    }\n\n    template <class Iterator>\n    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)\n    {\n      return *iter;\n    }\n\n    struct choose_difference_type\n    {\n        template <class I1, class I2>\n        struct apply\n          :\n# ifdef BOOST_NO_ONE_WAY_ITERATOR_INTEROP\n          iterator_difference<I1>\n# else\n          mpl::eval_if<\n              is_convertible<I2,I1>\n            , iterator_difference<I1>\n            , iterator_difference<I2>\n          >\n# endif\n        {};\n\n    };\n\n    template <\n        class Derived\n      , class Value\n      , class CategoryOrTraversal\n      , class Reference\n      , class Difference\n      , bool IsBidirectionalTraversal\n      , bool IsRandomAccessTraversal\n    >\n    class iterator_facade_base;\n\n  } // namespace detail\n\n\n  // Macros which describe the declarations of binary operators\n# ifdef BOOST_NO_STRICT_ITERATOR_INTEROPERABILITY\n#  define BOOST_ITERATOR_FACADE_INTEROP_HEAD_IMPL(prefix, op, result_type, enabler)       \\\n    template <                                                              \\\n        class Derived1, class V1, class TC1, class Reference1, class Difference1 \\\n      , class Derived2, class V2, class TC2, class Reference2, class Difference2 \\\n    >                                                                       \\\n    prefix typename mpl::apply2<result_type,Derived1,Derived2>::type \\\n    operator op(                                                            \\\n        iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs   \\\n      , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)\n# else\n#  define BOOST_ITERATOR_FACADE_INTEROP_HEAD_IMPL(prefix, op, result_type, enabler)   \\\n    template <                                                          \\\n        class Derived1, class V1, class TC1, class Reference1, class Difference1 \\\n      , class Derived2, class V2, class TC2, class Reference2, class Difference2 \\\n    >                                                                   \\\n    prefix typename enabler<                                            \\\n        Derived1, Derived2                                              \\\n      , typename mpl::apply2<result_type,Derived1,Derived2>::type       \\\n    >::type                                                             \\\n    operator op(                                                        \\\n        iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs   \\\n      , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)\n# endif\n\n#  define BOOST_ITERATOR_FACADE_INTEROP_HEAD(prefix, op, result_type)       \\\n    BOOST_ITERATOR_FACADE_INTEROP_HEAD_IMPL(prefix, op, result_type, boost::iterators::detail::enable_if_interoperable)\n\n#  define BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS_HEAD(prefix, op, result_type)       \\\n    BOOST_ITERATOR_FACADE_INTEROP_HEAD_IMPL(prefix, op, result_type, boost::iterators::detail::enable_if_interoperable_and_random_access_traversal)\n\n#  define BOOST_ITERATOR_FACADE_PLUS_HEAD(prefix,args)              \\\n    template <class Derived, class V, class TC, class R, class D>   \\\n    prefix typename boost::iterators::enable_if<                    \\\n        boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >,  \\\n        Derived                                                     \\\n    >::type operator+ args\n\n  //\n  // Helper class for granting access to the iterator core interface.\n  //\n  // The simple core interface is used by iterator_facade. The core\n  // interface of a user/library defined iterator type should not be made public\n  // so that it does not clutter the public interface. Instead iterator_core_access\n  // should be made friend so that iterator_facade can access the core\n  // interface through iterator_core_access.\n  //\n  class iterator_core_access\n  {\n# if defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)\n      // Tasteless as this may seem, making all members public allows member templates\n      // to work in the absence of member template friends.\n   public:\n# else\n\n      template <class I, class V, class TC, class R, class D> friend class iterator_facade;\n      template <class I, class V, class TC, class R, class D, bool IsBidirectionalTraversal, bool IsRandomAccessTraversal>\n      friend class detail::iterator_facade_base;\n\n#  define BOOST_ITERATOR_FACADE_RELATION(op)                                \\\n      BOOST_ITERATOR_FACADE_INTEROP_HEAD(friend,op, boost::iterators::detail::always_bool2);\n\n      BOOST_ITERATOR_FACADE_RELATION(==)\n      BOOST_ITERATOR_FACADE_RELATION(!=)\n\n#  undef BOOST_ITERATOR_FACADE_RELATION\n\n#  define BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(op)                                \\\n      BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS_HEAD(friend,op, boost::iterators::detail::always_bool2);\n\n      BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(<)\n      BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(>)\n      BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(<=)\n      BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(>=)\n\n#  undef BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION\n\n      BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS_HEAD(\n          friend, -, boost::iterators::detail::choose_difference_type)\n      ;\n\n      BOOST_ITERATOR_FACADE_PLUS_HEAD(\n          friend inline\n        , (iterator_facade<Derived, V, TC, R, D> const&\n        , typename Derived::difference_type)\n      )\n      ;\n\n      BOOST_ITERATOR_FACADE_PLUS_HEAD(\n          friend inline\n        , (typename Derived::difference_type\n        , iterator_facade<Derived, V, TC, R, D> const&)\n      )\n      ;\n\n# endif\n\n      template <class Facade>\n      static typename Facade::reference dereference(Facade const& f)\n      {\n          return f.dereference();\n      }\n\n      template <class Facade>\n      static void increment(Facade& f)\n      {\n          f.increment();\n      }\n\n      template <class Facade>\n      static void decrement(Facade& f)\n      {\n          f.decrement();\n      }\n\n      template <class Facade1, class Facade2>\n      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)\n      {\n          return f1.equal(f2);\n      }\n\n      template <class Facade1, class Facade2>\n      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)\n      {\n          return f2.equal(f1);\n      }\n\n      template <class Facade>\n      static void advance(Facade& f, typename Facade::difference_type n)\n      {\n          f.advance(n);\n      }\n\n      template <class Facade1, class Facade2>\n      static typename Facade1::difference_type distance_from(\n          Facade1 const& f1, Facade2 const& f2, mpl::true_)\n      {\n          return -f1.distance_to(f2);\n      }\n\n      template <class Facade1, class Facade2>\n      static typename Facade2::difference_type distance_from(\n          Facade1 const& f1, Facade2 const& f2, mpl::false_)\n      {\n          return f2.distance_to(f1);\n      }\n\n      //\n      // Curiously Recurring Template interface.\n      //\n      template <class I, class V, class TC, class R, class D>\n      static I& derived(iterator_facade<I,V,TC,R,D>& facade)\n      {\n          return *static_cast<I*>(&facade);\n      }\n\n      template <class I, class V, class TC, class R, class D>\n      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)\n      {\n          return *static_cast<I const*>(&facade);\n      }\n\n      // objects of this class are useless\n      BOOST_DELETED_FUNCTION(iterator_core_access())\n  };\n\n  namespace detail {\n\n    // Implementation for forward traversal iterators\n    template <\n        class Derived\n      , class Value\n      , class CategoryOrTraversal\n      , class Reference\n      , class Difference\n    >\n    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >\n# ifdef BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE\n        : public boost::iterators::detail::iterator_facade_types<\n             Value, CategoryOrTraversal, Reference, Difference\n          >::base\n#  undef BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE\n# endif\n    {\n    private:\n        typedef boost::iterators::detail::iterator_facade_types<\n            Value, CategoryOrTraversal, Reference, Difference\n        > associated_types;\n\n        typedef boost::iterators::detail::operator_arrow_dispatch<\n            Reference\n          , typename associated_types::pointer\n        > operator_arrow_dispatch_;\n\n    public:\n        typedef typename associated_types::value_type value_type;\n        typedef Reference reference;\n        typedef Difference difference_type;\n\n        typedef typename operator_arrow_dispatch_::result_type pointer;\n\n        typedef typename associated_types::iterator_category iterator_category;\n\n    public:\n        reference operator*() const\n        {\n            return iterator_core_access::dereference(this->derived());\n        }\n\n        pointer operator->() const\n        {\n            return operator_arrow_dispatch_::apply(*this->derived());\n        }\n\n        Derived& operator++()\n        {\n            iterator_core_access::increment(this->derived());\n            return this->derived();\n        }\n\n    protected:\n        //\n        // Curiously Recurring Template interface.\n        //\n        Derived& derived()\n        {\n            return *static_cast<Derived*>(this);\n        }\n\n        Derived const& derived() const\n        {\n            return *static_cast<Derived const*>(this);\n        }\n    };\n\n    // Implementation for bidirectional traversal iterators\n    template <\n        class Derived\n      , class Value\n      , class CategoryOrTraversal\n      , class Reference\n      , class Difference\n    >\n    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > :\n        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >\n    {\n    public:\n        Derived& operator--()\n        {\n            iterator_core_access::decrement(this->derived());\n            return this->derived();\n        }\n\n        Derived operator--(int)\n        {\n            Derived tmp(this->derived());\n            --*this;\n            return tmp;\n        }\n    };\n\n    // Implementation for random access traversal iterators\n    template <\n        class Derived\n      , class Value\n      , class CategoryOrTraversal\n      , class Reference\n      , class Difference\n    >\n    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, true > :\n        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false >\n    {\n    private:\n        typedef iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > base_type;\n\n    public:\n        typedef typename base_type::reference reference;\n        typedef typename base_type::difference_type difference_type;\n\n    public:\n        typename boost::iterators::detail::operator_brackets_result<Derived, Value, reference>::type\n        operator[](difference_type n) const\n        {\n            typedef boost::iterators::detail::use_operator_brackets_proxy<Value, Reference> use_proxy;\n\n            return boost::iterators::detail::make_operator_brackets_result<Derived>(\n                this->derived() + n\n              , use_proxy()\n            );\n        }\n\n        Derived& operator+=(difference_type n)\n        {\n            iterator_core_access::advance(this->derived(), n);\n            return this->derived();\n        }\n\n        Derived& operator-=(difference_type n)\n        {\n            iterator_core_access::advance(this->derived(), -n);\n            return this->derived();\n        }\n\n        Derived operator-(difference_type x) const\n        {\n            Derived result(this->derived());\n            return result -= x;\n        }\n    };\n\n  } // namespace detail\n\n  //\n  // iterator_facade - use as a public base class for defining new\n  // standard-conforming iterators.\n  //\n  template <\n      class Derived             // The derived iterator type being constructed\n    , class Value\n    , class CategoryOrTraversal\n    , class Reference   = Value&\n    , class Difference  = std::ptrdiff_t\n  >\n  class iterator_facade :\n      public detail::iterator_facade_base<\n          Derived,\n          Value,\n          CategoryOrTraversal,\n          Reference,\n          Difference,\n          detail::is_traversal_at_least< CategoryOrTraversal, bidirectional_traversal_tag >::value,\n          detail::is_traversal_at_least< CategoryOrTraversal, random_access_traversal_tag >::value\n      >\n  {\n  protected:\n      // For use by derived classes\n      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;\n  };\n\n  template <class I, class V, class TC, class R, class D>\n  inline typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type\n  operator++(\n      iterator_facade<I,V,TC,R,D>& i\n    , int\n  )\n  {\n      typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type\n          tmp(*static_cast<I*>(&i));\n\n      ++i;\n\n      return tmp;\n  }\n\n\n  //\n  // Comparison operator implementation. The library supplied operators\n  // enables the user to provide fully interoperable constant/mutable\n  // iterator types. I.e. the library provides all operators\n  // for all mutable/constant iterator combinations.\n  //\n  // Note though that this kind of interoperability for constant/mutable\n  // iterators is not required by the standard for container iterators.\n  // All the standard asks for is a conversion mutable -> constant.\n  // Most standard library implementations nowadays provide fully interoperable\n  // iterator implementations, but there are still heavily used implementations\n  // that do not provide them. (Actually it's even worse, they do not provide\n  // them for only a few iterators.)\n  //\n  // ?? Maybe a BOOST_ITERATOR_NO_FULL_INTEROPERABILITY macro should\n  //    enable the user to turn off mixed type operators\n  //\n  // The library takes care to provide only the right operator overloads.\n  // I.e.\n  //\n  // bool operator==(Iterator,      Iterator);\n  // bool operator==(ConstIterator, Iterator);\n  // bool operator==(Iterator,      ConstIterator);\n  // bool operator==(ConstIterator, ConstIterator);\n  //\n  //   ...\n  //\n  // In order to do so it uses c++ idioms that are not yet widely supported\n  // by current compiler releases. The library is designed to degrade gracefully\n  // in the face of compiler deficiencies. In general compiler\n  // deficiencies result in less strict error checking and more obscure\n  // error messages, functionality is not affected.\n  //\n  // For full operation compiler support for \"Substitution Failure Is Not An Error\"\n  // (aka. enable_if) and boost::is_convertible is required.\n  //\n  // The following problems occur if support is lacking.\n  //\n  // Pseudo code\n  //\n  // ---------------\n  // AdaptorA<Iterator1> a1;\n  // AdaptorA<Iterator2> a2;\n  //\n  // // This will result in a no such overload error in full operation\n  // // If enable_if or is_convertible is not supported\n  // // The instantiation will fail with an error hopefully indicating that\n  // // there is no operator== for Iterator1, Iterator2\n  // // The same will happen if no enable_if is used to remove\n  // // false overloads from the templated conversion constructor\n  // // of AdaptorA.\n  //\n  // a1 == a2;\n  // ----------------\n  //\n  // AdaptorA<Iterator> a;\n  // AdaptorB<Iterator> b;\n  //\n  // // This will result in a no such overload error in full operation\n  // // If enable_if is not supported the static assert used\n  // // in the operator implementation will fail.\n  // // This will accidently work if is_convertible is not supported.\n  //\n  // a == b;\n  // ----------------\n  //\n\n# ifdef BOOST_NO_ONE_WAY_ITERATOR_INTEROP\n#  define BOOST_ITERATOR_CONVERTIBLE(a,b) mpl::true_()\n# else\n#  define BOOST_ITERATOR_CONVERTIBLE(a,b) is_convertible<a,b>()\n# endif\n\n# define BOOST_ITERATOR_FACADE_INTEROP(op, result_type, return_prefix, base_op) \\\n  BOOST_ITERATOR_FACADE_INTEROP_HEAD(inline, op, result_type)                   \\\n  {                                                                             \\\n      /* For those compilers that do not support enable_if */                   \\\n      BOOST_STATIC_ASSERT((                                                     \\\n          is_interoperable< Derived1, Derived2 >::value                         \\\n      ));                                                                       \\\n      return_prefix iterator_core_access::base_op(                              \\\n          *static_cast<Derived1 const*>(&lhs)                                   \\\n        , *static_cast<Derived2 const*>(&rhs)                                   \\\n        , BOOST_ITERATOR_CONVERTIBLE(Derived2,Derived1)                         \\\n      );                                                                        \\\n  }\n\n# define BOOST_ITERATOR_FACADE_RELATION(op, return_prefix, base_op) \\\n  BOOST_ITERATOR_FACADE_INTEROP(                                    \\\n      op                                                            \\\n    , boost::iterators::detail::always_bool2                                   \\\n    , return_prefix                                                 \\\n    , base_op                                                       \\\n  )\n\n  BOOST_ITERATOR_FACADE_RELATION(==, return, equal)\n  BOOST_ITERATOR_FACADE_RELATION(!=, return !, equal)\n\n# undef BOOST_ITERATOR_FACADE_RELATION\n\n\n# define BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS(op, result_type, return_prefix, base_op) \\\n  BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS_HEAD(inline, op, result_type)                   \\\n  {                                                                             \\\n      /* For those compilers that do not support enable_if */                   \\\n      BOOST_STATIC_ASSERT((                                                     \\\n          is_interoperable< Derived1, Derived2 >::value &&                      \\\n          boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && \\\n          boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value \\\n      ));                                                                       \\\n      return_prefix iterator_core_access::base_op(                              \\\n          *static_cast<Derived1 const*>(&lhs)                                   \\\n        , *static_cast<Derived2 const*>(&rhs)                                   \\\n        , BOOST_ITERATOR_CONVERTIBLE(Derived2,Derived1)                         \\\n      );                                                                        \\\n  }\n\n# define BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(op, return_prefix, base_op) \\\n  BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS(                                    \\\n      op                                                            \\\n    , boost::iterators::detail::always_bool2                                   \\\n    , return_prefix                                                 \\\n    , base_op                                                       \\\n  )\n\n  BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(<, return 0 >, distance_from)\n  BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(>, return 0 <, distance_from)\n  BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(<=, return 0 >=, distance_from)\n  BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION(>=, return 0 <=, distance_from)\n\n# undef BOOST_ITERATOR_FACADE_RANDOM_ACCESS_RELATION\n\n  // operator- requires an additional part in the static assertion\n  BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS(\n      -\n    , boost::iterators::detail::choose_difference_type\n    , return\n    , distance_from\n  )\n\n# undef BOOST_ITERATOR_FACADE_INTEROP\n# undef BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS\n\n# define BOOST_ITERATOR_FACADE_PLUS(args)           \\\n  BOOST_ITERATOR_FACADE_PLUS_HEAD(inline, args)     \\\n  {                                                 \\\n      Derived tmp(static_cast<Derived const&>(i));  \\\n      return tmp += n;                              \\\n  }\n\n  BOOST_ITERATOR_FACADE_PLUS((\n      iterator_facade<Derived, V, TC, R, D> const& i\n    , typename Derived::difference_type n\n  ))\n\n  BOOST_ITERATOR_FACADE_PLUS((\n      typename Derived::difference_type n\n    , iterator_facade<Derived, V, TC, R, D> const& i\n  ))\n\n# undef BOOST_ITERATOR_FACADE_PLUS\n# undef BOOST_ITERATOR_FACADE_PLUS_HEAD\n\n# undef BOOST_ITERATOR_FACADE_INTEROP_HEAD\n# undef BOOST_ITERATOR_FACADE_INTEROP_RANDOM_ACCESS_HEAD\n# undef BOOST_ITERATOR_FACADE_INTEROP_HEAD_IMPL\n\n} // namespace iterators\n\nusing iterators::iterator_core_access;\nusing iterators::iterator_facade;\n\n} // namespace boost\n\n#include <boost/iterator/detail/config_undef.hpp>\n\n#endif // BOOST_ITERATOR_FACADE_23022003THW_HPP\n","// (C) Copyright David Abrahams 2002.\n// (C) Copyright Jeremy Siek    2002.\n// (C) Copyright Thomas Witt    2002.\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n#ifndef BOOST_FILTER_ITERATOR_23022003THW_HPP\n#define BOOST_FILTER_ITERATOR_23022003THW_HPP\n\n#include <boost/iterator.hpp>\n#include <boost/iterator/iterator_adaptor.hpp>\n#include <boost/iterator/iterator_categories.hpp>\n\n#include <boost/type_traits/is_class.hpp>\n#include <boost/static_assert.hpp>\n\nnamespace boost {\nnamespace iterators {\n\n  template <class Predicate, class Iterator>\n  class filter_iterator;\n\n  namespace detail\n  {\n    template <class Predicate, class Iterator>\n    struct filter_iterator_base\n    {\n        typedef iterator_adaptor<\n            filter_iterator<Predicate, Iterator>\n          , Iterator\n          , use_default\n          , typename mpl::if_<\n                is_convertible<\n                    typename iterator_traversal<Iterator>::type\n                  , random_access_traversal_tag\n                >\n              , bidirectional_traversal_tag\n              , use_default\n            >::type\n        > type;\n    };\n  }\n\n  template <class Predicate, class Iterator>\n  class filter_iterator\n    : public detail::filter_iterator_base<Predicate, Iterator>::type\n  {\n      typedef typename detail::filter_iterator_base<\n          Predicate, Iterator\n      >::type super_t;\n\n      friend class iterator_core_access;\n\n   public:\n      filter_iterator() { }\n\n      filter_iterator(Predicate f, Iterator x, Iterator end_ = Iterator())\n          : super_t(x), m_predicate(f), m_end(end_)\n      {\n          satisfy_predicate();\n      }\n\n      filter_iterator(Iterator x, Iterator end_ = Iterator())\n        : super_t(x), m_predicate(), m_end(end_)\n      {\n        // Pro8 is a little too aggressive about instantiating the\n        // body of this function.\n#if !BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))\n          // Don't allow use of this constructor if Predicate is a\n          // function pointer type, since it will be 0.\n          BOOST_STATIC_ASSERT(is_class<Predicate>::value);\n#endif\n          satisfy_predicate();\n      }\n\n      template<class OtherIterator>\n      filter_iterator(\n          filter_iterator<Predicate, OtherIterator> const& t\n          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0\n          )\n          : super_t(t.base()), m_predicate(t.predicate()), m_end(t.end()) {}\n\n      Predicate predicate() const { return m_predicate; }\n\n      Iterator end() const { return m_end; }\n\n   private:\n      void increment()\n      {\n          ++(this->base_reference());\n          satisfy_predicate();\n      }\n\n      void decrement()\n      {\n        while(!this->m_predicate(*--(this->base_reference()))){};\n      }\n\n      void satisfy_predicate()\n      {\n          while (this->base() != this->m_end && !this->m_predicate(*this->base()))\n              ++(this->base_reference());\n      }\n\n      // Probably should be the initial base class so it can be\n      // optimized away via EBO if it is an empty class.\n      Predicate m_predicate;\n      Iterator m_end;\n  };\n\n  template <class Predicate, class Iterator>\n  inline filter_iterator<Predicate,Iterator>\n  make_filter_iterator(Predicate f, Iterator x, Iterator end = Iterator())\n  {\n      return filter_iterator<Predicate,Iterator>(f,x,end);\n  }\n\n  template <class Predicate, class Iterator>\n  inline filter_iterator<Predicate,Iterator>\n  make_filter_iterator(\n      typename iterators::enable_if<\n          is_class<Predicate>\n        , Iterator\n      >::type x\n    , Iterator end = Iterator())\n  {\n      return filter_iterator<Predicate,Iterator>(x,end);\n  }\n\n} // namespace iterators\n\nusing iterators::filter_iterator;\nusing iterators::make_filter_iterator;\n\n} // namespace boost\n\n#endif // BOOST_FILTER_ITERATOR_23022003THW_HPP\n","// (C) Copyright David Abrahams 2002.\n// (C) Copyright Jeremy Siek    2002.\n// (C) Copyright Thomas Witt    2002.\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n#ifndef BOOST_ITERATOR_ADAPTOR_23022003THW_HPP\n#define BOOST_ITERATOR_ADAPTOR_23022003THW_HPP\n\n#include <boost/static_assert.hpp>\n#include <boost/iterator.hpp>\n#include <boost/detail/iterator.hpp>\n\n#include <boost/iterator/iterator_categories.hpp>\n#include <boost/iterator/iterator_facade.hpp>\n#include <boost/iterator/detail/enable_if.hpp>\n\n#include <boost/mpl/and.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/mpl/or.hpp>\n\n#include <boost/type_traits/is_same.hpp>\n#include <boost/type_traits/is_convertible.hpp>\n\n#ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY\n# include <boost/type_traits/remove_reference.hpp>\n#endif\n\n#include <boost/type_traits/add_reference.hpp>\n#include <boost/iterator/detail/config_def.hpp>\n\n#include <boost/iterator/iterator_traits.hpp>\n\nnamespace boost {\nnamespace iterators {\n\n  // Used as a default template argument internally, merely to\n  // indicate \"use the default\", this can also be passed by users\n  // explicitly in order to specify that the default should be used.\n  struct use_default;\n\n} // namespace iterators\n\nusing iterators::use_default;\n\n// the incompleteness of use_default causes massive problems for\n// is_convertible (naturally).  This workaround is fortunately not\n// needed for vc6/vc7.\ntemplate<class To>\nstruct is_convertible<use_default,To>\n  : mpl::false_ {};\n\nnamespace iterators {\n\n  namespace detail\n  {\n\n    //\n    // Result type used in enable_if_convertible meta function.\n    // This can be an incomplete type, as only pointers to\n    // enable_if_convertible< ... >::type are used.\n    // We could have used void for this, but conversion to\n    // void* is just to easy.\n    //\n    struct enable_type;\n  }\n\n\n  //\n  // enable_if for use in adapted iterators constructors.\n  //\n  // In order to provide interoperability between adapted constant and\n  // mutable iterators, adapted iterators will usually provide templated\n  // conversion constructors of the following form\n  //\n  // template <class BaseIterator>\n  // class adapted_iterator :\n  //   public iterator_adaptor< adapted_iterator<Iterator>, Iterator >\n  // {\n  // public:\n  //\n  //   ...\n  //\n  //   template <class OtherIterator>\n  //   adapted_iterator(\n  //       OtherIterator const& it\n  //     , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0);\n  //\n  //   ...\n  // };\n  //\n  // enable_if_convertible is used to remove those overloads from the overload\n  // set that cannot be instantiated. For all practical purposes only overloads\n  // for constant/mutable interaction will remain. This has the advantage that\n  // meta functions like boost::is_convertible do not return false positives,\n  // as they can only look at the signature of the conversion constructor\n  // and not at the actual instantiation.\n  //\n  // enable_if_interoperable can be safely used in user code. It falls back to\n  // always enabled for compilers that don't support enable_if or is_convertible.\n  // There is no need for compiler specific workarounds in user code.\n  //\n  // The operators implementation relies on boost::is_convertible not returning\n  // false positives for user/library defined iterator types. See comments\n  // on operator implementation for consequences.\n  //\n#  if defined(BOOST_NO_IS_CONVERTIBLE) || defined(BOOST_NO_SFINAE)\n\n  template <class From, class To>\n  struct enable_if_convertible\n  {\n      typedef boost::iterators::detail::enable_type type;\n  };\n\n#  elif BOOST_WORKAROUND(_MSC_FULL_VER, BOOST_TESTED_AT(13102292))\n\n  // For some reason vc7.1 needs us to \"cut off\" instantiation\n  // of is_convertible in a few cases.\n  template<typename From, typename To>\n  struct enable_if_convertible\n    : iterators::enable_if<\n        mpl::or_<\n            is_same<From,To>\n          , is_convertible<From, To>\n        >\n      , boost::iterators::detail::enable_type\n    >\n  {};\n\n#  else\n\n  template<typename From, typename To>\n  struct enable_if_convertible\n    : iterators::enable_if<\n          is_convertible<From, To>\n        , boost::iterators::detail::enable_type\n      >\n  {};\n\n# endif\n\n  //\n  // Default template argument handling for iterator_adaptor\n  //\n  namespace detail\n  {\n    // If T is use_default, return the result of invoking\n    // DefaultNullaryFn, otherwise return T.\n    template <class T, class DefaultNullaryFn>\n    struct ia_dflt_help\n      : mpl::eval_if<\n            is_same<T, use_default>\n          , DefaultNullaryFn\n          , mpl::identity<T>\n        >\n    {\n    };\n\n    // A metafunction which computes an iterator_adaptor's base class,\n    // a specialization of iterator_facade.\n    template <\n        class Derived\n      , class Base\n      , class Value\n      , class Traversal\n      , class Reference\n      , class Difference\n    >\n    struct iterator_adaptor_base\n    {\n        typedef iterator_facade<\n            Derived\n\n# ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY\n          , typename boost::iterators::detail::ia_dflt_help<\n                Value\n              , mpl::eval_if<\n                    is_same<Reference,use_default>\n                  , iterator_value<Base>\n                  , remove_reference<Reference>\n                >\n            >::type\n# else\n          , typename boost::iterators::detail::ia_dflt_help<\n                Value, iterator_value<Base>\n            >::type\n# endif\n\n          , typename boost::iterators::detail::ia_dflt_help<\n                Traversal\n              , iterator_traversal<Base>\n            >::type\n\n          , typename boost::iterators::detail::ia_dflt_help<\n                Reference\n              , mpl::eval_if<\n                    is_same<Value,use_default>\n                  , iterator_reference<Base>\n                  , add_reference<Value>\n                >\n            >::type\n\n          , typename boost::iterators::detail::ia_dflt_help<\n                Difference, iterator_difference<Base>\n            >::type\n        >\n        type;\n    };\n\n    // workaround for aC++ CR JAGaf33512\n    template <class Tr1, class Tr2>\n    inline void iterator_adaptor_assert_traversal ()\n    {\n      BOOST_STATIC_ASSERT((is_convertible<Tr1, Tr2>::value));\n    }\n  }\n\n  //\n  // Iterator Adaptor\n  //\n  // The parameter ordering changed slightly with respect to former\n  // versions of iterator_adaptor The idea is that when the user needs\n  // to fiddle with the reference type it is highly likely that the\n  // iterator category has to be adjusted as well.  Any of the\n  // following four template arguments may be ommitted or explicitly\n  // replaced by use_default.\n  //\n  //   Value - if supplied, the value_type of the resulting iterator, unless\n  //      const. If const, a conforming compiler strips constness for the\n  //      value_type. If not supplied, iterator_traits<Base>::value_type is used\n  //\n  //   Category - the traversal category of the resulting iterator. If not\n  //      supplied, iterator_traversal<Base>::type is used.\n  //\n  //   Reference - the reference type of the resulting iterator, and in\n  //      particular, the result type of operator*(). If not supplied but\n  //      Value is supplied, Value& is used. Otherwise\n  //      iterator_traits<Base>::reference is used.\n  //\n  //   Difference - the difference_type of the resulting iterator. If not\n  //      supplied, iterator_traits<Base>::difference_type is used.\n  //\n  template <\n      class Derived\n    , class Base\n    , class Value        = use_default\n    , class Traversal    = use_default\n    , class Reference    = use_default\n    , class Difference   = use_default\n  >\n  class iterator_adaptor\n    : public boost::iterators::detail::iterator_adaptor_base<\n        Derived, Base, Value, Traversal, Reference, Difference\n      >::type\n  {\n      friend class iterator_core_access;\n\n   protected:\n      typedef typename boost::iterators::detail::iterator_adaptor_base<\n          Derived, Base, Value, Traversal, Reference, Difference\n      >::type super_t;\n   public:\n      iterator_adaptor() {}\n\n      explicit iterator_adaptor(Base const &iter)\n          : m_iterator(iter)\n      {\n      }\n\n      typedef Base base_type;\n\n      Base const& base() const\n        { return m_iterator; }\n\n   protected:\n      // for convenience in derived classes\n      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;\n\n      //\n      // lvalue access to the Base object for Derived\n      //\n      Base const& base_reference() const\n        { return m_iterator; }\n\n      Base& base_reference()\n        { return m_iterator; }\n\n   private:\n      //\n      // Core iterator interface for iterator_facade.  This is private\n      // to prevent temptation for Derived classes to use it, which\n      // will often result in an error.  Derived classes should use\n      // base_reference(), above, to get direct access to m_iterator.\n      //\n      typename super_t::reference dereference() const\n        { return *m_iterator; }\n\n      template <\n      class OtherDerived, class OtherIterator, class V, class C, class R, class D\n      >\n      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const\n      {\n        // Maybe readd with same_distance\n        //           BOOST_STATIC_ASSERT(\n        //               (detail::same_category_and_difference<Derived,OtherDerived>::value)\n        //               );\n          return m_iterator == x.base();\n      }\n\n      typedef typename iterator_category_to_traversal<\n          typename super_t::iterator_category\n      >::type my_traversal;\n\n# define BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(cat) \\\n      boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, cat>();\n\n      void advance(typename super_t::difference_type n)\n      {\n          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(random_access_traversal_tag)\n          m_iterator += n;\n      }\n\n      void increment() { ++m_iterator; }\n\n      void decrement()\n      {\n          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(bidirectional_traversal_tag)\n           --m_iterator;\n      }\n\n      template <\n          class OtherDerived, class OtherIterator, class V, class C, class R, class D\n      >\n      typename super_t::difference_type distance_to(\n          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const\n      {\n          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(random_access_traversal_tag)\n          // Maybe readd with same_distance\n          //           BOOST_STATIC_ASSERT(\n          //               (detail::same_category_and_difference<Derived,OtherDerived>::value)\n          //               );\n          return y.base() - m_iterator;\n      }\n\n# undef BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL\n\n   private: // data members\n      Base m_iterator;\n  };\n\n} // namespace iterators\n\nusing iterators::iterator_adaptor;\nusing iterators::enable_if_convertible;\n\n} // namespace boost\n\n#include <boost/iterator/detail/config_undef.hpp>\n\n#endif // BOOST_ITERATOR_ADAPTOR_23022003THW_HPP\n","//  (C) Copyright John Maddock 2015. \n//  Use, modification and distribution are subject to the \n//  Boost Software License, Version 1.0. (See accompanying file \n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_TYPE_TRAITS_INTEGRAL_CONSTANT_HPP\n#define BOOST_TYPE_TRAITS_INTEGRAL_CONSTANT_HPP\n\n#include <boost/config.hpp>\n#include <boost/detail/workaround.hpp>\n\n#if (BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1400)) \\\n   || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \\\n   || BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840)) \\\n   || BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3202)) \\\n   || BOOST_WORKAROUND(BOOST_INTEL_CXX_VERSION, BOOST_TESTED_AT(810)) )\n\n\nnamespace boost{\n   namespace mpl\n   {\n      template <bool B> struct bool_;\n      template <class I, I val> struct integral_c;\n      struct integral_c_tag;\n   }\n}\n\n#else\n\nnamespace mpl_{\n\n   template <bool B> struct bool_;\n   template <class I, I val> struct integral_c;\n   struct integral_c_tag;\n}\n\nnamespace boost\n{\n   namespace mpl\n   {\n      using ::mpl_::bool_;\n      using ::mpl_::integral_c;\n      using ::mpl_::integral_c_tag;\n   }\n}\n\n#endif\n\nnamespace boost{\n\n   template <class T, T val>\n   struct integral_constant\n   {\n      typedef mpl::integral_c_tag tag;\n      typedef T value_type;\n      typedef integral_constant<T, val> type;\n      static const T value = val;\n      //\n      // This helper function is just to disable type-punning \n      // warnings from GCC:\n      //\n      template <class U>\n      static U& dereference(U* p) { return *p; }\n\n      operator const mpl::integral_c<T, val>& ()const\n      {\n         static const char data[sizeof(long)] = { 0 };\n         return dereference(reinterpret_cast<const mpl::integral_c<T, val>*>(&data));\n      }\n      BOOST_CONSTEXPR operator T()const { return val; }\n   };\n\n   template <class T, T val>\n   T const integral_constant<T, val>::value;\n      \n   template <bool val>\n   struct integral_constant<bool, val>\n   {\n      typedef mpl::integral_c_tag tag;\n      typedef bool value_type;\n      typedef integral_constant<bool, val> type;\n      static const bool value = val;\n      //\n      // This helper function is just to disable type-punning \n      // warnings from GCC:\n      //\n      template <class T>\n      static T& dereference(T* p) { return *p; }\n\n      operator const mpl::bool_<val>& ()const\n      {\n         static const char data = 0;\n         return dereference(reinterpret_cast<const mpl::bool_<val>*>(&data));\n      }\n      BOOST_CONSTEXPR operator bool()const { return val; }\n   };\n\n   template <bool val>\n   bool const integral_constant<bool, val>::value;\n\n   typedef integral_constant<bool, true> true_type;\n   typedef integral_constant<bool, false> false_type;\n\n}\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n    const char* __type_name;\n#else\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        : __type_name(__n) {}\n#else\n        : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name;}\n#else\n        {return reinterpret_cast<const char*>(__type_name & ~_LIBCPP_NONUNIQUE_RTTI_BIT);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name < __arg.__type_name;}\n#else\n        {if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return __type_name < __arg.__type_name;\n         return __compare_nonunique_names(__arg) < 0;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n#else\n        {if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT)) return __type_name;\n         const char *__ptr = name();\n         size_t __hash = 5381;\n         while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n           __hash = (__hash * 33) ^ __c;\n         return __hash;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name == __arg.__type_name;}\n#else\n        {if (__type_name == __arg.__type_name) return true;\n         if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return false;\n         return __compare_nonunique_names(__arg) == 0;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n#ifdef _LIBCPP_NONUNIQUE_RTTI_BIT\n  private:\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n        {return __builtin_strcmp(name(), __arg.name());}\n#endif\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n","#include \"Engine.h\"\n#include <emscripten.h>\n\nnamespace fgfx {\n\n  std::shared_ptr<Engine> engine;\n\n  Engine::Engine() {\n    SpriteLayer::initializeSpriteProgram();\n    LineLayer::initializeLineProgram();\n    PolygonLayer::initializePolygonProgram();\n\n    //currentTime=0;\n  }\n\n  Engine::~Engine() {\n\n  }\n\n  std::shared_ptr<Sprite> Engine::getSprite(std::string spriteName) {\n    emscripten_log(EM_LOG_ERROR, \"LOADING SPRITE!!! %s\\n\",spriteName.c_str());\n    auto it = sprites.find(spriteName);\n    if (it != sprites.end()) {\n      std::shared_ptr<Sprite> sprite = it->second;\n      if(sprite->unloaded) reloadSprite(sprite);\n    }\n    std::shared_ptr<Sprite> sprite = std::make_shared<Sprite>(spriteName);\n    spritesToLoad.push_back(sprite);\n    sprites[spriteName] = sprite;\n    return sprite;\n  }\n\n  void Engine::reloadSprite(std::shared_ptr<Sprite> spritep) {\n    spritesToLoad.push_back(spritep);\n    spritep->unloaded=false;\n  }\n\n  std::shared_ptr<SpriteFont> Engine::getSpriteFont(std::string spriteFontName) {\n    auto it = spriteFonts.find(spriteFontName);\n    if (it != spriteFonts.end()) return it->second;\n    std::shared_ptr<SpriteFont> spriteFont = std::make_shared<SpriteFont>(spriteFontName);\n    spriteFontsToLoad.push_back(spriteFont);\n    spriteFonts[spriteFontName] = spriteFont;\n    return spriteFont;\n  }\n\n  int Engine::getSpritesToLoadCount() {\n    return spritesToLoad.size();\n  }\n  std::shared_ptr<Sprite> Engine::getSpriteToLoad(int n) {\n    return spritesToLoad[n];\n  }\n  void Engine::clearSpritesToLoad() {\n    spritesToLoad.clear();\n  }\n\n\n  int Engine::getSpriteFontsToLoadCount() {\n    return spriteFontsToLoad.size();\n  }\n  std::shared_ptr<SpriteFont> Engine::getSpriteFontToLoad(int n) {\n    return spriteFontsToLoad[n];\n  }\n  void Engine::clearSpriteFontsToLoad() {\n    spriteFontsToLoad.clear();\n  }\n\n  void Engine::setRenderFunction(std::function<void(float,float)> renderFunctionp) {\n    renderFunction=renderFunctionp;\n  }\n\n  void Engine::render(double time, float delta, int widthp, int heightp) {\n    renderTime = time;\n    renderDelta = delta;\n    width = widthp;\n    height = heightp;\n    if(renderFunction) renderFunction(time,delta);\n  }\n\n  std::shared_ptr<SpriteLayer> Engine::createSpriteLayer() {\n    return std::make_shared<SpriteLayer>(this);\n  }\n  std::shared_ptr<PolygonLayer> Engine::createPolygonLayer() {\n    return std::make_shared<PolygonLayer>(this);\n  }\n  std::shared_ptr<LineLayer> Engine::createLineLayer() {\n    return std::make_shared<LineLayer>(this);\n  }\n\n};\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value\n#if __has_feature(is_final)\n                                                        && !__is_final(_Compare)\n#endif\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#if __cplusplus >= 201103L\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(_Args&& ...__args)\n        : __cc(std::forward<_Args>(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const __value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type&& __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__value_type() {__cc.~value_type();}\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type() {}\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0)\n        : __cc(__a0) {}\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0, const _A1& __a1)\n        : __cc(__a0, __a1) {}\n};\n\n#endif\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_const_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(\n            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)\n                _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        pair<iterator, bool>\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif\n    __node_holder __construct_node_with_key(const key_type& __k);\n\n    __node_base_pointer&\n        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);\n    __node_base_const_pointer\n        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;\n};\n\n// Find place to insert if __k doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k)\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_const_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_const_pointer __parent;\n    __node_base_const_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_const_pointer>(__child)->__value_.__cc.second;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\npair<typename map<_Key, _Tp, _Compare, _Allocator>::iterator, bool>\nmap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __tree_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::iterator\nmap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                   _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_unique(__p.__i_, __h.get());\n    if (__r.__i_.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                                    __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        iterator\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                   {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                        _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multimap;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY set;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multiset;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Allocator> class __map_node_destructor;\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(false)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_end_node\n             <\n                typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__tree_node_base<_VoidPtr> >\n#else\n                     rebind<__tree_node_base<_VoidPtr> >::other\n#endif\n             >\n{\n    __tree_node_base(const __tree_node_base&);\n    __tree_node_base& operator=(const __tree_node_base&);\npublic:\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__tree_node_base>\n#else\n            rebind<__tree_node_base>::other\n#endif\n                                                pointer;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const __tree_node_base>\n#else\n            rebind<const __tree_node_base>::other\n#endif\n                                                const_pointer;\n    typedef __tree_end_node<pointer> base;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_node_base() _NOEXCEPT\n        : __right_(), __parent_(), __is_black_(false) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef __tree_node_base<_VoidPtr> base;\n    typedef _Tp value_type;\n\n    value_type __value_;\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tree_node(_Args&& ...__args)\n            : __value_(_VSTD::forward<_Args>(__args)...) {}\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node(const value_type& __v)\n            : __value_(__v) {}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n};\n\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_iterator\n{\n    typedef _NodePtr                                              __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename __node_base::pointer                         __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag iterator_category;\n    typedef _Tp                        value_type;\n    typedef _DiffType                  difference_type;\n    typedef value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n};\n\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator\n{\n    typedef _ConstNodePtr                                         __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node_base>\n#else\n            rebind<__node_base>::other\n#endif\n                                                                  __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef _DiffType                        difference_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef typename remove_const<__node>::type  __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                 __non_const_node_pointer;\n    typedef __tree_iterator<value_type, __non_const_node_pointer, difference_type>\n                                                 __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef typename __alloc_traits::void_pointer  __void_pointer;\n\n    typedef __tree_node<value_type, __void_pointer> __node;\n    typedef __tree_node_base<__void_pointer>        __node_base;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef typename __node_base::pointer            __node_base_pointer;\n    typedef typename __node_base::pointer            __node_base_const_pointer;\nprivate:\n    typedef typename __node_base::base __end_node_t;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_ptr;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_const_ptr;\n\n    __node_pointer                                          __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>\n               (\n                   pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_const_pointer>\n               (\n                   pointer_traits<__end_node_const_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first()))\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() _NOEXCEPT\n        {return static_cast<__node_pointer>      (__end_node()->__left_);}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_const_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value));\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        pair<iterator, bool>\n        __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n        iterator\n        __emplace_hint_unique(const_iterator __p, _Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Vp>\n        pair<iterator, bool> __insert_unique(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_unique(const_iterator __p, _Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(const_iterator __p, _Vp&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    pair<iterator, bool> __insert_unique(const value_type& __v);\n    iterator __insert_unique(const_iterator __p, const value_type& __v);\n    iterator __insert_multi(const value_type& __v);\n    iterator __insert_multi(const_iterator __p, const value_type& __v);\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const value_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        __node_holder __construct_node(const value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _VSTD::move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _VSTD::addressof(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n    _NOEXCEPT_(\n        __is_nothrow_swappable<value_compare>::value &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value))\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_alloc(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const value_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    iterator __r = __node_insert_unique(__p, __h.get());\n    if (__r.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::destroy(__na, const_cast<value_type*>(_VSTD::addressof(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_const_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s) {return strlen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz || __sz - __pos < __n)\n        return __npos;\n    if (__n == 0)\n        return __pos;\n    const _CharT* __r = \n        _VSTD::__search(__p + __pos, __p + __sz,\n                        __s, __s + __n, _Traits::eq,\n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p + __ip);\n#else\n    return iterator(__p + __ip);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","#ifndef SPRITE_H\n#define SPRITE_H\n\n#include <glm/vec2.hpp>\n#include <string>\n#include <memory>\n\nnamespace fgfx {\n\n  class Sprite : public std::enable_shared_from_this<Sprite> {\n    friend class SpriteBuffer;\n  protected:\n    glm::vec2 coords[4];\n  public:\n    std::string name;\n    int textureId;\n    int width;\n    int height;\n    float ratio;\n    int lastUseTime;\n    bool preloaded;\n    bool unloaded;\n    Sprite(std::string namep);\n    void setTextureFragment(int textureIdp, float left, float top, float right, float bottom, int widthp, int heightp,\n                            bool preloadedp);\n    std::string getSpriteName();\n    void unload();\n  };\n\n};\n\n#endif // SPRITE_H\n","// -*- C++ -*-\n//===-------------------------- exception ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_EXCEPTION\n#define _LIBCPP_EXCEPTION\n\n/*\n    exception synopsis\n\nnamespace std\n{\n\nclass exception\n{\npublic:\n    exception() noexcept;\n    exception(const exception&) noexcept;\n    exception& operator=(const exception&) noexcept;\n    virtual ~exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_exception\n    : public exception\n{\npublic:\n    bad_exception() noexcept;\n    bad_exception(const bad_exception&) noexcept;\n    bad_exception& operator=(const bad_exception&) noexcept;\n    virtual ~bad_exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\ntypedef void (*unexpected_handler)();\nunexpected_handler set_unexpected(unexpected_handler  f ) noexcept;\nunexpected_handler get_unexpected() noexcept;\n[[noreturn]] void unexpected();\n\ntypedef void (*terminate_handler)();\nterminate_handler set_terminate(terminate_handler  f ) noexcept;\nterminate_handler get_terminate() noexcept;\n[[noreturn]] void terminate() noexcept;\n\nbool uncaught_exception() noexcept;\n\ntypedef unspecified exception_ptr;\n\nexception_ptr current_exception() noexcept;\nvoid rethrow_exception [[noreturn]] (exception_ptr p);\ntemplate<class E> exception_ptr make_exception_ptr(E e) noexcept;\n\nclass nested_exception\n{\npublic:\n    nested_exception() noexcept;\n    nested_exception(const nested_exception&) noexcept = default;\n    nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() = default;\n\n    // access functions\n    [[noreturn]] void rethrow_nested() const;\n    exception_ptr nested_ptr() const noexcept;\n};\n\ntemplate <class T> [[noreturn]] void throw_with_nested(T&& t);\ntemplate <class E> void rethrow_if_nested(const E& e);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <cstddef>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}\n    virtual ~exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_exception\n    : public exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY bad_exception() _NOEXCEPT {}\n    virtual ~bad_exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\ntypedef void (*unexpected_handler)();\n_LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();\n\ntypedef void (*terminate_handler)();\n_LIBCPP_FUNC_VIS terminate_handler set_terminate(terminate_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS terminate_handler get_terminate() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void terminate() _NOEXCEPT;\n\n_LIBCPP_FUNC_VIS bool uncaught_exception() _NOEXCEPT;\n\nclass _LIBCPP_TYPE_VIS exception_ptr;\n\n_LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n\nclass _LIBCPP_TYPE_VIS exception_ptr\n{\n    void* __ptr_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {}\n    _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {}\n    exception_ptr(const exception_ptr&) _NOEXCEPT;\n    exception_ptr& operator=(const exception_ptr&) _NOEXCEPT;\n    ~exception_ptr() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT\n        operator bool() const _NOEXCEPT {return __ptr_ != nullptr;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return !(__x == __y);}\n\n    friend _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n    friend _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n};\n\ntemplate<class _Ep>\nexception_ptr\nmake_exception_ptr(_Ep __e) _NOEXCEPT\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n        throw __e;\n    }\n    catch (...)\n    {\n        return current_exception();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\n// nested_exception\n\nclass _LIBCPP_EXCEPTION_ABI nested_exception\n{\n    exception_ptr __ptr_;\npublic:\n    nested_exception() _NOEXCEPT;\n//     nested_exception(const nested_exception&) noexcept = default;\n//     nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() _NOEXCEPT;\n\n    // access functions\n    _LIBCPP_NORETURN void rethrow_nested() const;\n    _LIBCPP_INLINE_VISIBILITY exception_ptr nested_ptr() const _NOEXCEPT {return __ptr_;}\n};\n\ntemplate <class _Tp>\nstruct __nested\n    : public _Tp,\n      public nested_exception\n{\n    _LIBCPP_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}\n};\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  is_class<typename remove_reference<_Tp>::type>::value &&\n                  !is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw __nested<typename remove_reference<_Tp>::type>(_VSTD::forward<_Tp>(__t));\n#endif\n}\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  !is_class<typename remove_reference<_Tp>::type>::value ||\n                  is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw _VSTD::forward<_Tp>(__t);\n#endif\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep& __e, typename enable_if<\n                                   is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);\n    if (__nep)\n        __nep->rethrow_nested();\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep&, typename enable_if<\n                                   !is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n}\n\n}  // std\n\n#endif  // _LIBCPP_EXCEPTION\n","#ifndef SPRITELAYER_H\n#define SPRITELAYER_H\n\n#include \"Sprite.h\"\n#include \"SpriteBuffer.h\"\n#include \"Layer.h\"\n#include <glm/glm.hpp>\n#include <vector>\n#include <map>\n\n#include <string>\n\n#include \"shaders.h\"\n\nnamespace fgfx {\n\n  class Engine;\n\n  class SpriteLayer : public Layer {\n  protected:\n    std::vector<SpriteBuffer*> buffers;\n    SpriteBuffer* getBuffer(int textureId);\n\n    friend class Engine;\n    friend class SpriteBuffer;\n\n    static GLuint spriteProgram;\n    static GLuint spriteProgramAttribPosition;\n    static GLuint spriteProgramAttribColor;\n    static GLuint spriteProgramAttribCoord;\n    static GLuint spriteProgramUniformCameraMatrix;\n    static GLuint spriteProgramUniformSampler;\n\n    static void initializeSpriteProgram();\n    void beginDraw(glm::mat4 cameraMatrix);\n    void endDraw();\n  public:\n    SpriteLayer(Engine* enginep);\n\n    void bufferSprite(const std::shared_ptr<Sprite>& sprite, glm::vec2 pos, glm::vec4 color, float size, float rotation);\n    void bufferSprite(const std::shared_ptr<Sprite>& sprite, const glm::mat4 &mat, glm::vec4 color);\n    void rawBufferSprite(const std::shared_ptr<Sprite>& sprite, const glm::mat4 &mat, glm::vec4 color);\n\n    virtual void reset() override ;\n    virtual void upload() override ;\n    virtual void render(glm::mat4 cameraMatrix) override ;\n  };\n\n}\n#endif // SPRITELAYER_H\n","//\n// Created by Michał Łaszczewski on 09/07/16.\n//\n\n#include <fastgfx.h>\n\n#include <vector>\n#include <memory>\n#include <fastgfx.h>\n#include <emscripten.h>\n\nnamespace fgfx {\n  int init() {\n    EM_ASM(Module.initializeFastGfxRuntime());\n    emscripten_log(EM_LOG_ERROR, \"ENGINE INITIALIZATION\\n\");\n    fgfx::engine = std::make_shared<fgfx::Engine>();\n    EM_ASM(Module.initializeFastGfxTextureManager());\n    return 0;\n  }\n}\n\nusing namespace fgfx;\n\nextern \"C\" {\n\nEMSCRIPTEN_KEEPALIVE\nvoid fgfx_render(double time, float delta, int widthp, int heightp) {\n  fgfx::engine->render(time, delta, widthp, heightp);\n}\n\nEMSCRIPTEN_KEEPALIVE\nint fgfx_getSpritesToLoadCount() {\n  return fgfx::engine->getSpritesToLoadCount();\n}\n\nEMSCRIPTEN_KEEPALIVE\nfgfx::Sprite* fgfx_getSpriteToLoad(int id) {\n  return fgfx::engine->getSpriteToLoad(id).get();\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid fgfx_clearSpritesToLoad(int id) {\n  fgfx::engine->clearSpritesToLoad();\n}\n\nEMSCRIPTEN_KEEPALIVE\nfgfx::Sprite* fgfx_getSprite(const char* spriteName) {\n  return fgfx::engine->getSprite(spriteName).get();\n}\n\nEMSCRIPTEN_KEEPALIVE\nconst char* fgfx_Sprite_getName(fgfx::Sprite* sprite) {\n  return sprite->name.c_str();\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid fgfx_Sprite_setTextureFragment(fgfx::Sprite* sprite, int textureIdp, float left, float top, float right, float bottom,\n                                    int widthp, int heightp, bool preloaded) {\n  sprite->setTextureFragment(textureIdp, left, top, right, bottom, widthp, heightp, preloaded);\n}\n\nEMSCRIPTEN_KEEPALIVE\nint fgfx_getSpriteFontsToLoadCount() {\n  return fgfx::engine->getSpriteFontsToLoadCount();\n}\n\nEMSCRIPTEN_KEEPALIVE\nfgfx::SpriteFont* fgfx_getSpriteFontToLoad(int id) {\n  return fgfx::engine->getSpriteFontToLoad(id).get();\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid fgfx_clearSpriteFontsToLoad(int id) {\n  fgfx::engine->clearSpriteFontsToLoad();\n}\n\nEMSCRIPTEN_KEEPALIVE\nconst char* fgfx_SpriteFont_getName(fgfx::SpriteFont* font) {\n  return font->name.c_str();\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid fgfx_SpriteFont_setHeight(fgfx::SpriteFont* font, float linep, float basep) {\n  font -> setHeight(linep, basep);\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid fgfx_SpriteFont_setCharacter(fgfx::SpriteFont* font, unsigned short character, fgfx::Sprite* sprite,\n                            float xSize, float ySize, float xOffset, float yOffset, float advance) {\n  font -> setCharacter(character,sprite->shared_from_this(),glm::vec2(xSize,ySize),glm::vec2(xOffset,yOffset),advance);\n}\n\n\n};","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2014 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/core/type_tvec2.inl\n/// @date 2008-08-18 / 2011-06-15\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\nnamespace glm\n{\n\t// -- Implicit basic constructors --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2()\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT\n\t\t\t\t: x(0), y(0)\n#\t\t\tendif\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(tvec2<T, P> const & v)\n\t\t\t: x(v.x), y(v.y)\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <precision Q>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(tvec2<T, Q> const & v)\n\t\t: x(v.x), y(v.y)\n\t{}\n\n\t// -- Explicit basic constructors --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(ctor)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(T const & scalar)\n\t\t: x(scalar), y(scalar)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(T const & s1, T const & s2)\n\t\t: x(s1), y(s2)\n\t{}\n\n\t// -- Conversion scalar constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(A const & a, B const & b)\n\t\t: x(static_cast<T>(a))\n\t\t, y(static_cast<T>(b))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(tvec1<A, P> const & a, tvec1<B, P> const & b)\n\t\t: x(static_cast<T>(a.x))\n\t\t, y(static_cast<T>(b.x))\n\t{}\n\n\t// -- Conversion vector constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(tvec2<U, Q> const & v)\n\t\t: x(static_cast<T>(v.x))\n\t\t, y(static_cast<T>(v.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(tvec3<U, Q> const & v)\n\t\t: x(static_cast<T>(v.x))\n\t\t, y(static_cast<T>(v.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tvec2<T, P>::tvec2(tvec4<U, Q> const & v)\n\t\t: x(static_cast<T>(v.x))\n\t\t, y(static_cast<T>(v.y))\n\t{}\n\n\t// -- Component accesses --\n\n#\tifdef GLM_FORCE_SIZE_FUNC\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec2<T, P>::size_type tvec2<T, P>::size() const\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T & tvec2<T, P>::operator[](typename tvec2<T, P>::size_type i)\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T const & tvec2<T, P>::operator[](typename tvec2<T, P>::size_type i) const\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n#\telse\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec2<T, P>::length_type tvec2<T, P>::length() const\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i)\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER T const & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i) const\n\t\t{\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\n\t\t\treturn (&x)[i];\n\t\t}\n#\tendif//GLM_FORCE_SIZE_FUNC\n\n\t// -- Unary arithmetic operators --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator=(tvec2<T, P> const & v)\n\t\t{\n\t\t\tthis->x = v.x;\n\t\t\tthis->y = v.y;\n\t\t\treturn *this;\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x = static_cast<T>(v.x);\n\t\tthis->y = static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator+=(U scalar)\n\t{\n\t\tthis->x += static_cast<T>(scalar);\n\t\tthis->y += static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x += static_cast<T>(v.x);\n\t\tthis->y += static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x += static_cast<T>(v.x);\n\t\tthis->y += static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator-=(U scalar)\n\t{\n\t\tthis->x -= static_cast<T>(scalar);\n\t\tthis->y -= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x -= static_cast<T>(v.x);\n\t\tthis->y -= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x -= static_cast<T>(v.x);\n\t\tthis->y -= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator*=(U scalar)\n\t{\n\t\tthis->x *= static_cast<T>(scalar);\n\t\tthis->y *= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator/=(U scalar)\n\t{\n\t\tthis->x /= static_cast<T>(scalar);\n\t\tthis->y /= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\t// -- Increment and decrement operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator++()\n\t{\n\t\t++this->x;\n\t\t++this->y;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator--()\n\t{\n\t\t--this->x;\n\t\t--this->y;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec2<T, P> tvec2<T, P>::operator++(int)\n\t{\n\t\ttvec2<T, P> Result(*this);\n\t\t++*this;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec2<T, P> tvec2<T, P>::operator--(int)\n\t{\n\t\ttvec2<T, P> Result(*this);\n\t\t--*this;\n\t\treturn Result;\n\t}\n\n\t// -- Unary bit operators --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator%=(U scalar)\n\t{\n\t\tthis->x %= static_cast<T>(scalar);\n\t\tthis->y %= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x %= static_cast<T>(v.x);\n\t\tthis->y %= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x %= static_cast<T>(v.x);\n\t\tthis->y %= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator&=(U scalar)\n\t{\n\t\tthis->x &= static_cast<T>(scalar);\n\t\tthis->y &= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x &= static_cast<T>(v.x);\n\t\tthis->y &= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x &= static_cast<T>(v.x);\n\t\tthis->y &= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator|=(U scalar)\n\t{\n\t\tthis->x |= static_cast<T>(scalar);\n\t\tthis->y |= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x |= static_cast<T>(v.x);\n\t\tthis->y |= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x |= static_cast<T>(v.x);\n\t\tthis->y |= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator^=(U scalar)\n\t{\n\t\tthis->x ^= static_cast<T>(scalar);\n\t\tthis->y ^= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x ^= static_cast<T>(v.x);\n\t\tthis->y ^= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x ^= static_cast<T>(v.x);\n\t\tthis->y ^= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator<<=(U scalar)\n\t{\n\t\tthis->x <<= static_cast<T>(scalar);\n\t\tthis->y <<= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator>>=(U scalar)\n\t{\n\t\tthis->x >>= static_cast<T>(scalar);\n\t\tthis->y >>= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.y);\n\t\treturn *this;\n\t}\n\n\t// -- Unary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v)\n\t{\n\t\treturn v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\t-v.x, \n\t\t\t-v.y);\n\t}\n\n\t// -- Binary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x + scalar,\n\t\t\tv.y + scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.y + v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar + v.x,\n\t\t\tscalar + v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.x + v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.y + v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x - scalar,\n\t\t\tv.y - scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.y - v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar - v.x,\n\t\t\tscalar - v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.x - v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.y - v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec2<T, P> const & v1, T const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x * v2,\n\t\t\tv1.y * v2);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.y * v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar * v.x,\n\t\t\tscalar * v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.x * v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.y * v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x / scalar,\n\t\t\tv.y / scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.y / v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar / v.x,\n\t\t\tscalar / v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.x / v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.y / v2.y);\n\t}\n\n\t// -- Binary bit operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x % scalar,\n\t\t\tv.y % scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x % v2.x,\n\t\t\tv1.y % v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar % v.x,\n\t\t\tscalar % v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x % v2.x,\n\t\t\tv1.x % v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x % v2.x,\n\t\t\tv1.y % v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x & scalar,\n\t\t\tv.y & scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x & v2.x,\n\t\t\tv1.y & v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar & v.x,\n\t\t\tscalar & v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x & v2.x,\n\t\t\tv1.x & v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x & v2.x,\n\t\t\tv1.y & v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x | scalar,\n\t\t\tv.y | scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x | v2.x,\n\t\t\tv1.y | v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar | v.x,\n\t\t\tscalar | v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x | v2.x,\n\t\t\tv1.x | v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x | v2.x,\n\t\t\tv1.y | v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x ^ scalar,\n\t\t\tv.y ^ scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x ^ v2.x,\n\t\t\tv1.y ^ v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar ^ v.x,\n\t\t\tscalar ^ v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x ^ v2.x,\n\t\t\tv1.x ^ v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x ^ v2.x,\n\t\t\tv1.y ^ v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x << scalar,\n\t\t\tv.y << scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x << v2.x,\n\t\t\tv1.y << v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar << v.x,\n\t\t\tscalar << v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x << v2.x,\n\t\t\tv1.x << v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x << v2.x,\n\t\t\tv1.y << v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec2<T, P> const & v, T const & scalar)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv.x >> scalar,\n\t\t\tv.y >> scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x >> v2.x,\n\t\t\tv1.y >> v2.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(T const & scalar, tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tscalar >> v.x,\n\t\t\tscalar >> v.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x >> v2.x,\n\t\t\tv1.x >> v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\tv1.x >> v2.x,\n\t\t\tv1.y >> v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator~(tvec2<T, P> const & v)\n\t{\n\t\treturn tvec2<T, P>(\n\t\t\t~v.x,\n\t\t\t~v.y);\n\t}\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn (v1.x == v2.x) && (v1.y == v2.y);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\n\t{\n\t\treturn (v1.x != v2.x) || (v1.y != v2.y);\n\t}\n}//namespace glm\n","#include \"Layer.h\"\n\n\nnamespace fgfx {\n\n  Layer::Layer(Engine *enginep) :  engine(enginep), composition(2),\n    frozen(false), visible(true), camera(false) {\n  }\n\n  Layer::~Layer() {\n  }\n\n  void Layer::setFrozen(bool frozenp) {\n    frozen = frozenp;\n  }\n  void Layer::setComposition(int compositionp) {\n    composition = compositionp;\n  }\n  void Layer::setCamera(bool camerap) {\n    camera = camerap;\n  }\n  void Layer::setVisible(bool visiblep) {\n    visible = visiblep;\n  }\n\n  bool Layer::isVisible() {\n    return visible;\n  }\n\n};\n","//\n// Created by Michał Łaszczewski on 20/04/16.\n//\n\n#include \"LineLayer.h\"\n\n\n#include <glm/gtc/type_ptr.hpp>\n#include <emscripten.h>\n\nnamespace fgfx {\n\n  GLuint LineLayer::lineProgram = 0;\n  GLuint LineLayer::lineProgramAttribColor = 0;\n  GLuint LineLayer::lineProgramAttribPosition = 0;\n  GLuint LineLayer::lineProgramUniformCameraMatrix = 0;\n  \n  void LineLayer::initializeLineProgram() {\n    \n    const char vShaderStr[] =\n      \"attribute vec3 aVertexPosition;\\n\"\\\n      \"attribute vec4 aVertexColor;\\n\"\n      \"uniform mat4 uCameraMatrix;\\n\"\n      \"varying vec4 vColor;\\n\"\n      \"void main() {\\n\"\n      \"  gl_Position = uCameraMatrix*vec4(aVertexPosition, 1.0);\\n\"\n      \"  vColor = aVertexColor;\\n\"\n      \"}\\n\";\n\n    const char fShaderStr[] =\n      \"precision mediump float;\\n\"\\\n      \"varying vec4 vColor;\\n\"\n      \"void main() {\\n\"\n      \"  gl_FragColor = vColor;\\n\"\n      \"}\\n\";\n\n    auto vertexShader = fgfx::loadShader(GL_VERTEX_SHADER, vShaderStr);\n    auto fragmentShader = fgfx::loadShader(GL_FRAGMENT_SHADER, fShaderStr);\n\n    auto lineProgram = fgfx::createProgram(vertexShader, fragmentShader);\n    if (!lineProgram) throw \"nie ma programu!\";\n    LineLayer::lineProgram = lineProgram;\n\n    LineLayer::lineProgramAttribPosition = glGetAttribLocation(lineProgram, \"aVertexPosition\");\n    LineLayer::lineProgramAttribColor = glGetAttribLocation(lineProgram, \"aVertexColor\");\n    LineLayer::lineProgramUniformCameraMatrix = glGetUniformLocation(lineProgram, \"uCameraMatrix\");\n  }\n\n  void LineLayer::beginDraw(glm::mat4 cameraMatrix) {\n    glUseProgram(LineLayer::lineProgram);\n    glEnableVertexAttribArray(LineLayer::lineProgramAttribPosition);\n    glEnableVertexAttribArray(LineLayer::lineProgramAttribColor);\n\n    glUniformMatrix4fv(LineLayer::lineProgramUniformCameraMatrix, 1, GL_FALSE, (GLfloat*)glm::value_ptr(cameraMatrix));\n  }\n\n  void LineLayer::endDraw() {\n    glDisableVertexAttribArray(LineLayer::lineProgramAttribPosition);\n    glDisableVertexAttribArray(LineLayer::lineProgramAttribColor);\n  }\n\n\n  LineLayer::LineLayer(Engine* enginep) : Layer(enginep), linePointsCount(0) {\n    glGenBuffers(1,&positionBuffer);\n    glGenBuffers(1,&colorBuffer);\n  }\n  LineLayer::~LineLayer() {\n    glDeleteBuffers(1,&positionBuffer);\n    glDeleteBuffers(1,&colorBuffer);\n  }\n\n  void LineLayer::reserve(int pointCount) {\n    lineVertices.reserve(pointCount);\n    lineColors.reserve(pointCount);\n  }\n\n  void LineLayer::bufferPoint(glm::vec3 pos, glm::vec4 color) {\n    if(frozen && uploaded) return;\n    /*emscripten_log(EM_LOG_ERROR,\"BUFFER LINE POINT %d (%f %f %f) COLOR (%f %f %f %f)\\n\",linePointsCount,\n                   pos.x,pos.y,pos.z,color.r,color.g,color.b,color.a);*/\n    lineVertices.push_back(pos);\n    lineColors.push_back(color);\n    linePointsCount++;\n  }\n  void LineLayer::bufferLine(glm::vec3 p1, glm::vec3 p2, glm::vec4 color) {\n    bufferPoint(p1,color);\n    bufferPoint(p2,color);\n  }\n\n  void LineLayer::reset() {\n    if(frozen) return;\n    lineVertices.clear();\n    lineColors.clear();\n    linePointsCount = 0;\n    uploaded=false;\n  }\n  void LineLayer::upload() {\n    if(!visible) return;\n    if(uploaded) return;\n    if(!linePointsCount) return;\n\n    glBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\n    glBufferData(GL_ARRAY_BUFFER, linePointsCount * sizeof(glm::vec3),lineVertices.data(),\n                 GL_DYNAMIC_DRAW);\n\n    glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n    glBufferData(GL_ARRAY_BUFFER, linePointsCount * sizeof(glm::vec4),lineColors.data(),\n                 GL_DYNAMIC_DRAW);\n\n    uploaded=true;\n  }\n  void LineLayer::render(glm::mat4 cameraMatrix) {\n    if(!visible) return;\n    if(!linePointsCount) return;\n\n    beginDraw(cameraMatrix);\n\n    glBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\n    glVertexAttribPointer(LineLayer::lineProgramAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n    glVertexAttribPointer(LineLayer::lineProgramAttribColor, 4, GL_FLOAT, GL_FALSE, 0, 0);\n\n    glDrawArrays(GL_LINES, 0, linePointsCount);\n\n    endDraw();\n  }\n}","///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// Restrictions:\n///\t\tBy making use of the Software for military purposes, you choose to make\n///\t\ta Bunny unhappy.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref gtc_type_ptr\n/// @file glm/gtc/type_ptr.inl\n/// @date 2011-06-15 / 2011-12-07\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#include <cstring>\n\nnamespace glm\n{\n\t/// @addtogroup gtc_type_ptr\n\t/// @{\n\n\t/// Return the constant address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttvec2<T, P> const & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t//! Return the address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttvec2<T, P> & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t/// Return the constant address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttvec3<T, P> const & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t//! Return the address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttvec3<T, P> & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\t\n\t\ttvec4<T, P> const & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t//! Return the address to the data of the vector input.\n\t//! From GLM_GTC_type_ptr extension.\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\t\n\t\ttvec4<T, P> & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat2x2<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat2x2<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat3x3<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat3x3<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat4x4<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t//! From GLM_GTC_type_ptr extension.\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat4x4<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat2x3<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat2x3<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat3x2<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat3x2<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat2x4<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat2x4<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat4x2<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\t\n\t\ttmat4x2<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat3x4<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat3x4<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat4x3<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t/// Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr(tmat4x3<T, P> & mat)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t/// Return the constant address to the data of the input parameter.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttquat<T, P> const & q\n\t)\n\t{\n\t\treturn &(q[0]);\n\t}\n\n\t/// Return the address to the data of the quaternion input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttquat<T, P> & q\n\t)\n\t{\n\t\treturn &(q[0]);\n\t}\n\n\t/// Build a vector from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tvec2<T, defaultp> make_vec2(T const * const ptr)\n\t{\n\t\ttvec2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a vector from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tvec3<T, defaultp> make_vec3(T const * const ptr)\n\t{\n\t\ttvec3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a vector from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tvec4<T, defaultp> make_vec4(T const * const ptr)\n\t{\n\t\ttvec4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x2<T, defaultp> make_mat2x2(T const * const ptr)\n\t{\n\t\ttmat2x2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x3<T, defaultp> make_mat2x3(T const * const ptr)\n\t{\n\t\ttmat2x3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x4<T, defaultp> make_mat2x4(T const * const ptr)\n\t{\n\t\ttmat2x4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x2<T, defaultp> make_mat3x2(T const * const ptr)\n\t{\n\t\ttmat3x2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x3<T, defaultp> make_mat3x3(T const * const ptr)\n\t{\n\t\ttmat3x3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x4<T, defaultp> make_mat3x4(T const * const ptr)\n\t{\n\t\ttmat3x4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x2<T, defaultp> make_mat4x2(T const * const ptr)\n\t{\n\t\ttmat4x2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x3<T, defaultp> make_mat4x3(T const * const ptr)\n\t{\n\t\ttmat4x3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> make_mat4x4(T const * const ptr)\n\t{\n\t\ttmat4x4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x2<T, defaultp> make_mat2(T const * const ptr)\n\t{\n\t\treturn make_mat2x2(ptr);\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x3<T, defaultp> make_mat3(T const * const ptr)\n\t{\n\t\treturn make_mat3x3(ptr);\n\t}\n\t\t\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> make_mat4(T const * const ptr)\n\t{\n\t\treturn make_mat4x4(ptr);\n\t}\n\n\t//! Build a quaternion from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tquat<T, defaultp> make_quat(T const * const ptr)\n\t{\n\t\ttquat<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// @}\n}//namespace glm\n\n","//\n// Created by Michał Łaszczewski on 20/04/16.\n//\n\n#include \"PolygonLayer.h\"\n\n#include <glm/gtc/type_ptr.hpp>\n#include <emscripten.h>\n\nnamespace fgfx {\n\n  GLuint PolygonLayer::polygonProgram = 0;\n  GLuint PolygonLayer::polygonProgramAttribColor = 0;\n  GLuint PolygonLayer::polygonProgramAttribPosition = 0;\n  GLuint PolygonLayer::polygonProgramUniformCameraMatrix = 0;\n  \n  void PolygonLayer::initializePolygonProgram() {\n    \n    const char vShaderStr[] =\n      \"attribute vec3 aVertexPosition;\\n\"\\\n      \"attribute vec4 aVertexColor;\\n\"\n      \"uniform mat4 uCameraMatrix;\\n\"\n      \"varying vec4 vColor;\\n\"\n      \"void main() {\\n\"\n      \"  gl_Position = uCameraMatrix*vec4(aVertexPosition, 1.0);\\n\"\n      \"  vColor = aVertexColor;\\n\"\n      \"}\\n\";\n\n    const char fShaderStr[] =\n      \"precision mediump float;\\n\"\\\n      \"varying vec4 vColor;\\n\"\n      \"void main() {\\n\"\n      \"  gl_FragColor = vColor;\\n\"\n      \"}\\n\";\n\n    auto vertexShader = fgfx::loadShader(GL_VERTEX_SHADER, vShaderStr);\n    auto fragmentShader = fgfx::loadShader(GL_FRAGMENT_SHADER, fShaderStr);\n\n    auto polygonProgram = fgfx::createProgram(vertexShader, fragmentShader);\n    if (!polygonProgram) throw \"nie ma programu!\";\n    PolygonLayer::polygonProgram = polygonProgram;\n\n    PolygonLayer::polygonProgramAttribPosition = glGetAttribLocation(polygonProgram, \"aVertexPosition\");\n    PolygonLayer::polygonProgramAttribColor = glGetAttribLocation(polygonProgram, \"aVertexColor\");\n    PolygonLayer::polygonProgramUniformCameraMatrix = glGetUniformLocation(polygonProgram, \"uCameraMatrix\");\n  }\n\n  void PolygonLayer::beginDraw(glm::mat4 cameraMatrix) {\n    glUseProgram(PolygonLayer::polygonProgram);\n    glEnableVertexAttribArray(PolygonLayer::polygonProgramAttribPosition);\n    glEnableVertexAttribArray(PolygonLayer::polygonProgramAttribColor);\n\n    glUniformMatrix4fv(PolygonLayer::polygonProgramUniformCameraMatrix, 1, GL_FALSE, (GLfloat*)glm::value_ptr(cameraMatrix));\n  }\n\n  void PolygonLayer::endDraw() {\n    glDisableVertexAttribArray(PolygonLayer::polygonProgramAttribPosition);\n    glDisableVertexAttribArray(PolygonLayer::polygonProgramAttribColor);\n  }\n\n  PolygonLayer::PolygonLayer(Engine* enginep) : Layer(enginep), polygonPointsCount(0) {\n    glGenBuffers(1,&positionBuffer);\n    glGenBuffers(1,&colorBuffer);\n  }\n  PolygonLayer::~PolygonLayer() {\n    glDeleteBuffers(1,&positionBuffer);\n    glDeleteBuffers(1,&colorBuffer);\n  }\n\n  void PolygonLayer::reserve(int pointCount) {\n    polygonVertices.reserve(pointCount);\n    polygonColors.reserve(pointCount);\n  }\n\n  void PolygonLayer::bufferPoint(glm::vec3 pos, glm::vec4 color) {\n    if(frozen && uploaded) return;\n    /*emscripten_log(EM_LOG_ERROR,\"BUFFER POLYGON POINT %d (%f %f %f) COLOR (%f %f %f %f)\\n\",polygonPointsCount,\n                   pos.x,pos.y,pos.z,color.r,color.g,color.b,color.a);*/\n    polygonVertices.push_back(pos);\n    polygonColors.push_back(color);\n    polygonPointsCount++;\n  }\n  void PolygonLayer::bufferTriangle(glm::vec3 p1, glm::vec3 p2, glm::vec3 p3, glm::vec4 color) {\n    bufferPoint(p1,color);\n    bufferPoint(p2,color);\n    bufferPoint(p3,color);\n  }\n  void PolygonLayer::bufferTriangle(glm::vec3 p[3], glm::vec4 color) {\n    bufferPoint(p[0],color);\n    bufferPoint(p[1],color);\n    bufferPoint(p[2],color);\n  }\n  void PolygonLayer::bufferQuad(glm::vec3 p1, glm::vec3 p2, glm::vec3 p3, glm::vec3 p4, glm::vec4 color) {\n    bufferPoint(p1,color);\n    bufferPoint(p2,color);\n    bufferPoint(p3,color);\n    bufferPoint(p1,color);\n    bufferPoint(p3,color);\n    bufferPoint(p4,color);\n  }\n  void PolygonLayer::bufferQuad(glm::vec3 p[4], glm::vec4 color) {\n    bufferPoint(p[0],color);\n    bufferPoint(p[1],color);\n    bufferPoint(p[2],color);\n    bufferPoint(p[0],color);\n    bufferPoint(p[2],color);\n    bufferPoint(p[3],color);\n  }\n\n  void PolygonLayer::reset() {\n    if(!visible) return;\n    if(frozen) return;\n    polygonVertices.clear();\n    polygonColors.clear();\n    polygonPointsCount = 0;\n    uploaded=false;\n  }\n  void PolygonLayer::upload() {\n    if(!visible) return;\n    if(uploaded) return;\n    if(!polygonPointsCount) return;\n\n    glBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\n    glBufferData(GL_ARRAY_BUFFER, polygonPointsCount * sizeof(glm::vec3),polygonVertices.data(),\n                 GL_DYNAMIC_DRAW);\n\n    glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n    glBufferData(GL_ARRAY_BUFFER, polygonPointsCount * sizeof(glm::vec4),polygonColors.data(),\n                 GL_DYNAMIC_DRAW);\n\n    uploaded=true;\n  }\n  void PolygonLayer::render(glm::mat4 cameraMatrix) {\n    if(!polygonPointsCount) return;\n\n    beginDraw(cameraMatrix);\n\n    glBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\n    glVertexAttribPointer(PolygonLayer::polygonProgramAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n    glVertexAttribPointer(PolygonLayer::polygonProgramAttribColor, 4, GL_FLOAT, GL_FALSE, 0, 0);\n\n    glDrawArrays(GL_TRIANGLES, 0, polygonPointsCount);\n\n    endDraw();\n  }\n}","//\n// Created by Michał Łaszczewski on 15/04/16.\n//\n\n#include \"shaders.h\"\n#include <cstddef>\n#include <cstdio>\n\nnamespace fgfx {\n\n  GLuint loadShader(GLenum type, const char *shaderSrc) {\n    GLuint shader;\n    GLint compiled;\n\n    // Create the shader object\n    shader = glCreateShader(type);\n\n    if (shader == 0)\n      return 0;\n\n    // Load the shader source\n    glShaderSource(shader, 1, &shaderSrc, NULL);\n\n    // Compile the shader\n    glCompileShader(shader);\n\n    // Check the compile status\n    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n\n    if (!compiled) {\n      GLint infoLen = 0;\n\n      glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);\n\n      if (infoLen > 1) {\n        char *infoLog = new char[infoLen];\n\n        glGetShaderInfoLog(shader, infoLen, NULL, infoLog);\n        printf(\"Error compiling shader:\\n%s\\n\", infoLog);\n\n        delete[] infoLog;\n      }\n\n      glDeleteShader(shader);\n      return 0;\n    }\n\n    return shader;\n\n  }\n\n  GLuint createProgram( GLuint vertexShader, GLuint fragmentShader) {\n    // Create the program object\n    auto programObject = glCreateProgram ( );\n\n    if ( programObject == 0 )\n      return 0;\n\n    glAttachShader ( programObject, vertexShader );\n    glAttachShader ( programObject, fragmentShader );\n\n    // Bind vPosition to attribute 0\n    glBindAttribLocation ( programObject, 0, \"vPosition\" );\n\n    // Link the program\n    glLinkProgram ( programObject );\n\n    GLint linked;\n\n    // Check the link status\n    glGetProgramiv ( programObject, GL_LINK_STATUS, &linked );\n\n    if ( !linked )\n    {\n      GLint infoLen = 0;\n\n      glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &infoLen );\n\n      if ( infoLen > 1 )\n      {\n        char* infoLog = new char[infoLen];\n\n        glGetProgramInfoLog ( programObject, infoLen, NULL, infoLog );\n        printf( \"Error linking program:\\n%s\\n\", infoLog );\n\n        delete[] infoLog;\n      }\n\n      glDeleteProgram ( programObject );\n      return GL_FALSE;\n    }\n\n    return programObject;\n  }\n\n}","#include \"Sprite.h\"\n\n#include <emscripten.h>\n#include <cstring>\n\nnamespace fgfx {\n\n  Sprite::Sprite(std::string namep) : name(namep), textureId(-1), width(0), height(0) {\n  }\n\n  std::string Sprite::getSpriteName() {\n   // emscripten_log(EM_LOG_ERROR, \"GET SPRITE NAME = %s\\n\",stringName.c_str());\n    return name;\n  }\n\n  void Sprite::setTextureFragment(int textureIdp, float left, float top, float right, float bottom, int widthp,\n                                  int heightp, bool preloadedp) {\n    emscripten_log(EM_LOG_ERROR, \"SET TEXTURE FRAGMENT %s %d %d %d\\n\",name.c_str(),textureIdp,width,height);\n    textureId = textureIdp;\n    coords[0] = glm::vec2(left,bottom);\n    coords[1] = glm::vec2(right,bottom);\n    coords[2] = glm::vec2(right,top);\n    coords[3] = glm::vec2(left,top);\n    width = widthp;\n    height = heightp;\n    ratio = 1.0*width/height;\n    preloaded = preloadedp;\n  }\n\n  void Sprite::unload() {\n    textureId = -1;\n    unloaded = true;\n  }\n\n};\n","//\n// Created by Michał Łaszczewski on 04/05/16.\n//\n\n#include \"SpriteFont.h\"\n\n#include <glm/gtc/matrix_transform.hpp>\n\n#include <emscripten.h>\n\nnamespace fgfx {\n\n  SpriteFont::SpriteFont(std::string namep) : name(namep) {\n\n  }\n  SpriteFont::~SpriteFont() {\n\n  }\n\n  void SpriteFont::setHeight(float linep, float basep) {\n    lineHeight = linep;\n    baseLine = basep;\n  }\n  void SpriteFont::setCharacter(unsigned short character, std::shared_ptr<Sprite> sprite, glm::vec2 size,\n                                glm::vec2 offset, float advance) {\n    //emscripten_log(EM_LOG_ERROR,\"SETUP %s CHAR: %c %d\\n\",name.c_str(),character,character);\n    SpriteCharacter characterStruct;\n    characterStruct.size = size;\n    characterStruct.offset = offset;\n    characterStruct.sprite = sprite;\n    characterStruct.advance = advance;\n    characters[character] = characterStruct;\n  }\n  void SpriteFont::renderString(std::shared_ptr<SpriteLayer> layer, glm::mat4 mat, glm::vec4 color, std::string text){\n    //emscripten_log(EM_LOG_ERROR,\"RENDER %s STRING: %s\\n\",name.c_str(),text.c_str());\n    float x=0;\n    for(int i=0; i<text.size(); i++) {\n\n      char c = text[i];\n      //emscripten_log(EM_LOG_ERROR,\"CHAR: %c %d\\n\",c,c);\n      auto it=characters.find(c);\n      if(it!=characters.end()) {\n        SpriteCharacter charStruct = it->second;\n        //emscripten_log(EM_LOG_ERROR,\"RENDER CHAR: %c %d\\n\",c,c);\n        glm::vec2 pos(x + charStruct.size.x*0.5 - charStruct.offset.x*0.5,-charStruct.size.y*0.5-charStruct.offset.y);\n        auto translate = glm::translate(glm::mat4(),glm::vec3(pos,0));\n        auto scale = glm::scale(glm::mat4(),glm::vec3(charStruct.size.x*0.5,charStruct.size.y*0.5,1));\n        layer->rawBgiufferSprite(charStruct.sprite,mat*translate*scale,color);\n        x += charStruct.advance;\n      }\n    }\n  }\n\n  glm::vec2 SpriteFont::measureString(std::string text) {\n    float height=0;\n    float width=0;\n    for(int i=0; i<text.size(); i++) {\n      char c = text[i];\n      auto it=characters.find(c);\n      if(it!=characters.end()) {\n        SpriteCharacter charStruct = it->second;\n        float h = charStruct.size.y+charStruct.offset.y;\n        if(h>height) height = h;\n        width+=charStruct.advance;\n      }\n    }\n    return glm::vec2(width,lineHeight);\n  }\n\n  void SpriteFont::renderColorCodedString(std::shared_ptr<SpriteLayer> layer, glm::mat4 mat, glm::vec4 color, std::string text) {\n    glm::vec4 ccolor = color;\n    float x = 0;\n    for(int i = 0; i<text.size(); i++) {\n      char c = text[i];\n\n      if(c == L'\\\\') {\n        i++;\n        int j;\n        for(j = i+1; j<text.size(); j++) {\n          if(text[j] == '\\\\') break;\n        }\n        int len = j-i;\n        //  emscripten_log(EM_LOG_CONSOLE,\"COLOR CODE %d %d %d\\n\",i,j,len);\n        if(len == 0) {\n          c = '\\\\';\n        } else {\n          if(len>2) {\n            std::string rs(\"0\");\n            std::string gs(\"0\");\n            std::string bs(\"0\");\n            std::string as(\"f\");\n            switch(len) {\n              case 3 :\n                rs = text.substr(i+0,1);\n                gs = text.substr(i+1,1);\n                bs = text.substr(i+2,1);\n                as = std::string(\"f\");\n                break;\n              case 4 :\n                rs = text.substr(i+0,1);\n                gs = text.substr(i+1,1);\n                bs = text.substr(i+2,1);\n                as = text.substr(i+3,1);\n                break;\n              case 6 :\n                rs = text.substr(i+0,2);\n                gs = text.substr(i+2,2);\n                bs = text.substr(i+4,2);\n                as = std::string(\"ff\");\n                break;\n              case 8 :\n                rs = text.substr(i+0,2);\n                gs = text.substr(i+2,2);\n                bs = text.substr(i+4,2);\n                as = text.substr(i+6,2);\n                break;\n            }\n            if(rs.size() == 2) {\n              ccolor = glm::vec4(\n                  std::stoi(rs,NULL,16)/255,\n                  std::stoi(gs,NULL,16)/255,\n                  std::stoi(bs,NULL,16)/255,\n                  std::stoi(as,NULL,16)/255);\n            } else {\n              ccolor = glm::vec4(\n                  std::stoi(rs,NULL,16)/15,\n                  std::stoi(gs,NULL,16)/15,\n                  std::stoi(bs,NULL,16)/15,\n                  std::stoi(as,NULL,16)/15);\n            }\n          } else {\n            ccolor = color;\n          }\n          i=j+1;\n          if(i >= text.size()) break;\n          c = text[i];\n        }\n      }\n      auto it = characters.find(c);\n      if (it != characters.end()) {\n        SpriteCharacter charStruct = it->second;\n        glm::vec2 pos(x + charStruct.size.x * 0.5 - charStruct.offset.x * 0.5,\n                      -charStruct.size.y * 0.5 - charStruct.offset.y);\n        auto translate = glm::translate(glm::mat4(), glm::vec3(pos, 0));\n        auto scale = glm::scale(glm::mat4(), glm::vec3(charStruct.size.x * 0.5, charStruct.size.y * 0.5, 1));\n        layer->bufferSprite(charStruct.sprite, mat * translate * scale, ccolor);\n        x += charStruct.advance;\n      }\n\n    }\n  }\n\n  glm::vec2 SpriteFont::measureColorCodeString(std::string text) {\n    float height=0;\n    float width=0;\n    for(int i=0; i<text.size(); i++) {\n      char c = text[i];\n      if(c == L'\\\\') {\n        i++;\n        int j;\n        for(j = i+1; j<text.size(); j++) {\n          if(text[j] == '\\\\') break;\n        }\n        int len = j-i;\n        //  emscripten_log(EM_LOG_CONSOLE,\"COLOR CODE %d %d %d\\n\",i,j,len);\n        if(len == 0) {\n          c = '\\\\';\n        } else {\n          i=j+1;\n          if(i >= text.size()) break;\n          c = text[i];\n        }\n      }\n      auto it=characters.find(c);\n      if(it!=characters.end()) {\n        SpriteCharacter charStruct = it->second;\n        float h = charStruct.size.y+charStruct.offset.y;\n        if(h>height) height = h;\n        width+=charStruct.advance;\n      }\n    }\n    return glm::vec2(width,lineHeight);\n  }\n\n}\n\n","//\n// Created by Michał Łaszczewski on 04/05/16.\n//\n\n#ifndef ENGINE_SPRITEFONT_H\n#define ENGINE_SPRITEFONT_H\n\n#include <glm/glm.hpp>\n#include \"SpriteLayer.h\"\n\nnamespace fgfx {\n\n  class SpriteCharacter {\n  public:\n    std::shared_ptr<Sprite> sprite;\n    glm::vec2 size;\n    glm::vec2 offset;\n    float advance;\n  };\n\n  class SpriteFont {\n  public:\n    std::string name;\n    std::map<unsigned short, SpriteCharacter> characters;\n\n    float lineHeight;\n    float baseLine;\n\n    SpriteFont(std::string namep);\n    ~SpriteFont();\n\n    void setHeight(float linep, float basep);\n    void setCharacter(unsigned short character, std::shared_ptr<Sprite> sprite, glm::vec2 size, glm::vec2 offset,\n                      float advance);\n    void renderString(std::shared_ptr<SpriteLayer> layer, glm::mat4 mat, glm::vec4 color, std::string text);\n    void renderColorCodedString(std::shared_ptr<SpriteLayer> layer, glm::mat4 mat, glm::vec4 color, std::string text);\n    glm::vec2 measureString(std::string text);\n    glm::vec2 measureColorCodeString(std::string text);\n  };\n\n}\n\n#endif //ENGINE_SPRITEFONT_H\n","#include \"SpriteLayer.h\"\n#include \"SpriteBuffer.h\"\n#include \"Engine.h\"\n\n#include <glm/gtc/type_ptr.hpp>\n#include <emscripten.h>\n\nnamespace fgfx {\n\n  SpriteLayer::SpriteLayer(Engine* enginep) : Layer(enginep) {\n    composition=1;\n  };\n\n  SpriteBuffer* SpriteLayer::getBuffer(int textureId) {\n    for(auto it=buffers.begin(); it!=buffers.end(); ++it) {\n      if((*it)->textureId == textureId) return *it;\n    }\n    SpriteBuffer* buf = new SpriteBuffer(textureId);\n    buffers.push_back(buf);\n    return buf;\n  }\n\n  void SpriteLayer::bufferSprite(const std::shared_ptr<Sprite>& sprite, glm::vec2 pos, glm::vec4 color, float size, float rotation) {\n    //emscripten_log(EM_LOG_ERROR,\"BUFFER SPRITE (%04.4lf,%04.4lf) %04.4lf textureId=%d\\n\",pos.x,pos.y,size,sprite->textureId);\n    //emscripten_log(EM_LOG_ERROR,\"BUFFER SPRITE %s textureId=%d\\n\",sprite->name.c_str(),sprite->textureId);\n    //sprite->lastUseTime = engine->currentTime;\n    if(sprite->unloaded) engine->reloadSprite(sprite);\n    if(sprite->textureId == -1) return;\n    SpriteBuffer* buf = getBuffer(sprite->textureId);\n    buf->bufferSprite(sprite, pos, color, size, rotation);\n  }\n\n  void SpriteLayer::bufferSprite(const std::shared_ptr<Sprite>& sprite, const glm::mat4 &mat, glm::vec4 color) {\n    //emscripten_log(EM_LOG_ERROR,\"BUFFER SPRITE %s textureId=%d\\n\",sprite->name.c_str(),sprite->textureId);\n    //sprite->lastUseTime = engine->currentTime;\n    if(sprite->unloaded) engine->reloadSprite(sprite);\n    if(sprite->textureId == -1) return;\n    SpriteBuffer* buf = getBuffer(sprite->textureId);\n    buf->bufferSprite(sprite, mat, color);\n  }\n\n  void SpriteLayer::rawBufferSprite(const std::shared_ptr<Sprite>& sprite, const glm::mat4 &mat, glm::vec4 color) {\n    //emscripten_log(EM_LOG_ERROR,\"BUFFER SPRITE %s textureId=%d\\n\",sprite->name.c_str(),sprite->textureId);\n    //sprite->lastUseTime = engine->currentTime;\n    if(sprite->unloaded) engine->reloadSprite(sprite);\n    if(sprite->textureId == -1) return;\n    SpriteBuffer* buf = getBuffer(sprite->textureId);\n    buf->rawBufferSprite(sprite, mat, color);\n  }\n\n  GLuint SpriteLayer::spriteProgram = 0;\n  GLuint SpriteLayer::spriteProgramAttribColor = 0;\n  GLuint SpriteLayer::spriteProgramAttribPosition = 0;\n  GLuint SpriteLayer::spriteProgramAttribCoord = 0;\n  GLuint SpriteLayer::spriteProgramUniformSampler = 0;\n  GLuint SpriteLayer::spriteProgramUniformCameraMatrix = 0;\n\n  void SpriteLayer::initializeSpriteProgram() {\n\n    const char vShaderStr[] =\n        \"attribute vec3 aVertexPosition;\\n\"\\\n        \"attribute vec4 aVertexColor;\\n\"\n        \"attribute vec2 aTextureCoord;\\n\"\n        \"uniform mat4 uCameraMatrix;\\n\"\n        \"varying vec4 vColor;\\n\"\n        \"varying highp vec2 vTextureCoord;\\n\"\n        \"void main() {\\n\"\n        \"  gl_Position =uCameraMatrix*vec4(aVertexPosition, 1.0);\\n\"\n        \"  vColor = aVertexColor;\\n\"\n        \"  vTextureCoord = aTextureCoord;\\n\"\n        \"}\\n\";\n\n    const char fShaderStr[] =\n        \"precision mediump float;\\n\"\\\n        \"varying vec4 vColor;\\n\"\n        \"uniform sampler2D uSampler;\\n\"\n        \"varying highp vec2 vTextureCoord;\\n\"\n        \"void main() {\\n\"\n        \"  vec4 textureColor = texture2D(uSampler, vTextureCoord);\\n\"\n        \"  gl_FragColor = vColor*textureColor;\\n\"\n        \"}\\n\";\n\n    auto vertexShader = fgfx::loadShader ( GL_VERTEX_SHADER, vShaderStr );\n    auto fragmentShader = fgfx::loadShader ( GL_FRAGMENT_SHADER, fShaderStr );\n\n    auto spriteProgram = fgfx::createProgram (vertexShader, fragmentShader);\n    if(!spriteProgram) throw \"nie ma programu!\";\n    SpriteLayer::spriteProgram = spriteProgram;\n\n    SpriteLayer::spriteProgramAttribPosition = glGetAttribLocation(spriteProgram,\"aVertexPosition\");\n    SpriteLayer::spriteProgramAttribColor = glGetAttribLocation(spriteProgram,\"aVertexColor\");\n    SpriteLayer::spriteProgramAttribCoord = glGetAttribLocation(spriteProgram,\"aTextureCoord\");\n\n    SpriteLayer::spriteProgramUniformCameraMatrix = glGetUniformLocation(spriteProgram,\"uCameraMatrix\");\n    SpriteLayer::spriteProgramUniformSampler = glGetUniformLocation(spriteProgram,\"uSampler\");\n  }\n\n  void SpriteLayer::beginDraw(glm::mat4 cameraMatrix) {\n    glUseProgram(SpriteLayer::spriteProgram);\n    glEnableVertexAttribArray(SpriteLayer::spriteProgramAttribPosition);\n    glEnableVertexAttribArray(SpriteLayer::spriteProgramAttribColor);\n    glEnableVertexAttribArray(SpriteLayer::spriteProgramAttribCoord);\n\n    glUniformMatrix4fv(SpriteLayer::spriteProgramUniformCameraMatrix, 1, GL_FALSE, (GLfloat*)glm::value_ptr(cameraMatrix));\n  }\n\n  void SpriteLayer::endDraw() {\n    glDisableVertexAttribArray(SpriteLayer::spriteProgramAttribPosition);\n    glDisableVertexAttribArray(SpriteLayer::spriteProgramAttribColor);\n    glDisableVertexAttribArray(SpriteLayer::spriteProgramAttribCoord);\n  }\n\n  void SpriteLayer::reset() {\n    for(auto it = buffers.begin(); it!=buffers.end(); ++it) {\n      SpriteBuffer *buffer = *it;\n      buffer->reset();\n    }\n  }\n\n  void SpriteLayer::upload() {\n    if(!visible) return;\n    for(auto it = buffers.begin(); it!=buffers.end(); ++it) {\n      SpriteBuffer *buffer = *it;\n      buffer->upload();\n    }\n  }\n\n  void SpriteLayer::render(glm::mat4 cameraMatrix) {\n    if(!visible) return;\n    beginDraw(cameraMatrix);\n    glActiveTexture(GL_TEXTURE0);\n    glDisable(GL_CULL_FACE);\n    for(auto it = buffers.begin(); it!=buffers.end(); ++it) {\n      SpriteBuffer* buffer=*it;\n      glBindTexture(GL_TEXTURE_2D, buffer->textureId);\n      glUniform1i(SpriteLayer::spriteProgramUniformSampler, 0);\n      buffer->render();\n    }\n\n    endDraw();\n  }\n\n\n}\n","//\n// Created by Michał Łaszczewski on 14/04/16.\n//\n\n#include \"SpriteBuffer.h\"\n#include \"SpriteLayer.h\"\n#include <cmath>\n#include <emscripten.h>\n\n#define SQRT_2 1.41421356237\n#define INV_SQRT_2 0.70710678118\n\nnamespace fgfx {\n  \n  SpriteBuffer::SpriteBuffer(int textureIdp) : textureId(textureIdp) {\n    glGenBuffers(1,&positionBuffer);\n    glGenBuffers(1,&colorBuffer);\n    glGenBuffers(1,&coordBuffer);\n  }\n  SpriteBuffer::~SpriteBuffer() {\n    glDeleteBuffers(1,&positionBuffer);\n    glDeleteBuffers(1,&colorBuffer);\n    glDeleteBuffers(1,&coordBuffer);\n  }\n\n  void SpriteBuffer::reserve(int pointCount) {\n    spriteVertices.reserve(pointCount);\n    spriteColors.reserve(pointCount);\n    spriteCoords.reserve(pointCount);\n  }\n  void SpriteBuffer::bufferPoint(glm::vec3 pos, glm::vec4 color, glm::vec2 coord) {\n    spriteVertices.push_back(pos);\n    spriteColors.push_back(color);\n    spriteCoords.push_back(coord);\n    spritePointsCount++;\n    //emscripten_log(EM_LOG_ERROR, \"BUFFER POINT (%.4lf,%.4lf) (%.2lf,%.2lf,%.2lf,%.2lf) (%.2lf,%.2lf)\\n\",\n    //               pos.x,pos.y,color.r,color.g,color.b,color.a,coord.x,coord.y);\n  }\n  void SpriteBuffer::bufferPoint(glm::vec2 pos, glm::vec4 color, glm::vec2 coord) {\n    spriteVertices.push_back(glm::vec3(pos.x,pos.y,0));\n    spriteColors.push_back(color);\n    spriteCoords.push_back(coord);\n    spritePointsCount++;\n   // emscripten_log(EM_LOG_ERROR, \"BUFFER POINT (%.4lf,%.4lf) (%.2lf,%.2lf,%.2lf,%.2lf) (%.2lf,%.2lf)\\n\",\n    //               pos.x,pos.y,color.r,color.g,color.b,color.a,coord.x,coord.y);\n  }\n  void SpriteBuffer::bufferSprite(const std::shared_ptr<Sprite>& sprite, glm::vec2 pos, glm::vec4 color, double size, double rotation) {\n    double sv = sin(rotation); // Rotation\n    double cv = cos(rotation);\n    glm::vec2 up(sv * size, -cv * size);\n    glm::vec2 right(cv * size * sprite->ratio, sv * size * sprite->ratio);\n    glm::vec2 m1 = up - right;\n    glm::vec2 m2 = up + right;\n\n    bufferPoint(pos + m1, color, sprite->coords[0]); // upper left\n    bufferPoint(pos + m2, color, sprite->coords[1]); // upper right\n    bufferPoint(pos - m1, color, sprite->coords[2]); // lower right\n\n    bufferPoint(pos - m2, color, sprite->coords[3]); // lower left\n    bufferPoint(pos + m1, color, sprite->coords[0]); // upper left\n    bufferPoint(pos - m1, color, sprite->coords[2]); // lower right\n  }\n  void SpriteBuffer::bufferSprite(const std::shared_ptr<Sprite>& sprite, const glm::mat4 &mat, glm::vec4 color) {\n    auto r = sprite->ratio;\n    glm::vec3 p1 = glm::vec3(mat*glm::vec4(-1*r,-1,0,1));\n    glm::vec3 p2 = glm::vec3(mat*glm::vec4(1*r,-1,0,1));\n    glm::vec3 p3 = glm::vec3(mat*glm::vec4(1*r,1,0,1));\n    glm::vec3 p4 = glm::vec3(mat*glm::vec4(-1*r,1,0,1));\n\n    bufferPoint(p1, color, sprite->coords[0]); // upper left\n    bufferPoint(p2, color, sprite->coords[1]); // upper right\n    bufferPoint(p3, color, sprite->coords[2]); // lower right\n\n    bufferPoint(p4, color, sprite->coords[3]); // lower left\n    bufferPoint(p1, color, sprite->coords[0]); // upper left\n    bufferPoint(p3, color, sprite->coords[2]); // lower right\n  }\n  void SpriteBuffer::rawBufferSprite(const std::shared_ptr<Sprite>& sprite, const glm::mat4 &mat, glm::vec4 color) {\n    glm::vec3 p1 = glm::vec3(mat*glm::vec4(-1,-1,0,1));\n    glm::vec3 p2 = glm::vec3(mat*glm::vec4(1,-1,0,1));\n    glm::vec3 p3 = glm::vec3(mat*glm::vec4(1,1,0,1));\n    glm::vec3 p4 = glm::vec3(mat*glm::vec4(-1,1,0,1));\n\n    bufferPoint(p1, color, sprite->coords[0]); // upper left\n    bufferPoint(p2, color, sprite->coords[1]); // upper right\n    bufferPoint(p3, color, sprite->coords[2]); // lower right\n\n    bufferPoint(p4, color, sprite->coords[3]); // lower left\n    bufferPoint(p1, color, sprite->coords[0]); // upper left\n    bufferPoint(p3, color, sprite->coords[2]); // lower right\n  }\n  void SpriteBuffer::reset() {\n    spriteVertices.clear();\n    spriteColors.clear();\n    spriteCoords.clear();\n    spritePointsCount=0;\n  }\n  void SpriteBuffer::upload() {\n    /// TODO: test GL_STREAM_DRAW\n\n    if(!spritePointsCount) return;\n\n//    GLfloat* points = (GLfloat*)spriteVertices.data();\n\n    /*printf(\"FIRST 3 VERTICES (%f %f %f) (%f %f %f) (%f %f %f)\\n\",\n           points[0],points[1],points[2],\n           points[3],points[4],points[5],\n           points[6],points[7],points[8]);*/\n\n    glBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\n    glBufferData(GL_ARRAY_BUFFER, spritePointsCount*sizeof(glm::vec3),spriteVertices.data(),\n                 GL_DYNAMIC_DRAW);\n\n    glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n    glBufferData(GL_ARRAY_BUFFER, spritePointsCount*sizeof(glm::vec4),spriteColors.data(),\n                 GL_DYNAMIC_DRAW);\n\n    glBindBuffer(GL_ARRAY_BUFFER, coordBuffer);\n    glBufferData(GL_ARRAY_BUFFER, spritePointsCount*sizeof(glm::vec2),spriteCoords.data(),\n                 GL_DYNAMIC_DRAW);\n\n  }\n  void SpriteBuffer::render() {\n    if(!spritePointsCount) return;\n\n    glBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\n    glVertexAttribPointer(SpriteLayer::spriteProgramAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    glBindBuffer(GL_ARRAY_BUFFER, coordBuffer);\n    glVertexAttribPointer( SpriteLayer::spriteProgramAttribCoord, 2, GL_FLOAT, GL_FALSE, 0, 0);\n    glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n    glVertexAttribPointer( SpriteLayer::spriteProgramAttribColor, 4, GL_FLOAT, GL_FALSE, 0, 0);\n\n    glDrawArrays(GL_TRIANGLES, 0, spritePointsCount);\n  }\n\n}","#include <emscripten/bind.h>\r\n#ifdef USE_CXA_DEMANGLE\r\n#include <../lib/libcxxabi/include/cxxabi.h>\r\n#endif\r\n#include <list>\r\n#include <vector>\r\n#include <typeinfo>\r\n#include <algorithm>\r\n#include <emscripten/emscripten.h>\r\n#include <climits>\r\n#include <limits>\r\n\r\nusing namespace emscripten;\r\n\r\nextern \"C\" {\r\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\r\n        if (has_unbound_type_names) {\r\n#ifdef USE_CXA_DEMANGLE\r\n            int stat;\r\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\r\n            if (stat == 0 && demangled) {\r\n                return demangled;\r\n            }\r\n\r\n            switch (stat) {\r\n                case -1:\r\n                    return strdup(\"<allocation failure>\");\r\n                case -2:\r\n                    return strdup(\"<invalid C++ symbol>\");\r\n                case -3:\r\n                    return strdup(\"<invalid argument>\");\r\n                default:\r\n                    return strdup(\"<unknown error>\");\r\n            }\r\n#else\r\n            return strdup(ti->name());\r\n#endif\r\n        } else {\r\n            char str[80];\r\n            sprintf(str, \"%p\", ti);\r\n            return strdup(str);\r\n        }\r\n    }\r\n}\r\n\r\nnamespace {\r\n    template<typename T>\r\n    static void register_integer(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\r\n    }\r\n\r\n    template<typename T>\r\n    static void register_float(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\r\n    }\r\n\r\n\r\n    // matches typeMapping in embind.js\r\n    enum TypedArrayIndex {\r\n        Int8Array,\r\n        Uint8Array,\r\n        Int16Array,\r\n        Uint16Array,\r\n        Int32Array,\r\n        Uint32Array,\r\n        Float32Array,\r\n        Float64Array,\r\n    };\r\n\r\n    template<typename T>\r\n    constexpr TypedArrayIndex getTypedArrayIndex() {\r\n        static_assert(\r\n            (std::is_floating_point<T>::value && (sizeof(T) == 4 || sizeof(T) == 8)) ||\r\n            (std::is_integral<T>::value && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4)),\r\n            \"type does not map to a typed array\");\r\n        return std::is_floating_point<T>::value\r\n            ? (sizeof(T) == 4\r\n               ? Float32Array\r\n               : Float64Array)\r\n            : (sizeof(T) == 1\r\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\r\n               : (sizeof(T) == 2\r\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\r\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\r\n    }\r\n\r\n    template<typename T>\r\n    static void register_memory_view(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\r\n    }\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\r\n    using namespace emscripten::internal;\r\n\r\n    _embind_register_void(TypeID<void>::get(), \"void\");\r\n    \r\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\r\n\r\n    register_integer<char>(\"char\");\r\n    register_integer<signed char>(\"signed char\");\r\n    register_integer<unsigned char>(\"unsigned char\");\r\n    register_integer<signed short>(\"short\");\r\n    register_integer<unsigned short>(\"unsigned short\");\r\n    register_integer<signed int>(\"int\");\r\n    register_integer<unsigned int>(\"unsigned int\");\r\n    register_integer<signed long>(\"long\");\r\n    register_integer<unsigned long>(\"unsigned long\");\r\n    \r\n    register_float<float>(\"float\");\r\n    register_float<double>(\"double\");\r\n    \r\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\r\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\r\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\r\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\r\n\r\n    // Some of these types are aliases for each other. Luckily,\r\n    // embind.js's _embind_register_memory_view ignores duplicate\r\n    // registrations rather than asserting, so the first\r\n    // register_memory_view call for a particular type will take\r\n    // precedence.\r\n\r\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\r\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\r\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\r\n\r\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\r\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\r\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\r\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\r\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\r\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\r\n\r\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\r\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\r\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\r\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\r\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\r\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\r\n\r\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\r\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\r\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\r\n}\r\n","#pragma once\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                    ? &typeid(C)\n                    : CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                ? &typeid(value)\n                : LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n"]}